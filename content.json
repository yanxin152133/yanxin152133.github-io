{"meta":{"title":"Yan's blog","subtitle":null,"description":null,"author":"Yan","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2019-05-02T03:51:18.000Z","updated":"2019-05-02T03:52:19.545Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-05-02T03:51:26.000Z","updated":"2019-05-02T03:52:17.154Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"PHP入门","slug":"PHP入门","date":"2019-08-01T12:41:00.188Z","updated":"2019-08-07T14:46:03.842Z","comments":true,"path":"2019/08/01/PHP入门/","link":"","permalink":"http://yoursite.com/2019/08/01/PHP入门/","excerpt":"代码仓库仓库地址：GitHub 环境： Apache/2.4.39 (Win64) PHP 7.3.6 PhpStorm 2019.2 MySQL 5.6 软件安装路径 Apache D:\\server\\apache PHP D:\\server\\php7 PHP手册文件名为php_manual_zh.chm即为PHP手册。 打不开参考下面链接： 解决win10中无法打开CHM文件的方法 搭建环境（Windows）较早版本Apache 下载下载地址：Apache msi","text":"代码仓库仓库地址：GitHub 环境： Apache/2.4.39 (Win64) PHP 7.3.6 PhpStorm 2019.2 MySQL 5.6 软件安装路径 Apache D:\\server\\apache PHP D:\\server\\php7 PHP手册文件名为php_manual_zh.chm即为PHP手册。 打不开参考下面链接： 解决win10中无法打开CHM文件的方法 搭建环境（Windows）较早版本Apache 下载下载地址：Apache msi 较早版本Apache 安装 双击下载的文件。 相关配置。 选择自定义安装模式 Apache 目录结构说明 Apache-httpd.exe介绍Httpd.exe的详细应用 服务器进程：运行之后才能够使用。 用来查看Apache具有哪些功能以及配置文件是否有错：httpd或者httpd.exe（文件所在目录） 查看使用的模块：httpd -M 验证配置文件是否有效：httpd -t Apache/2.4.39 (Win64)下载与安装下载下载地址： Apache/2.4.39 (Win64) 点击之后以Apache Lounge为例进行下载 之后根据自己安装的是哪个vc对应进行下载 安装、运行、卸载 对下载的文件进行解压，选择自己需要安装的地方。 打开conf\\httpd.conf，将所有的c:/Apache24 替换为自己的安装目录。 以管理员身份运行CMD，进入\\bin 目录（httpd.exe所在目录）。 输入 httpd.exe -k install -n “Apache24” 进行安装。 至此，安装基本完成。到安装目录下的bin目录中找到 ApacheMonitor.exe ,双击运行,启动apache服务。 如果要卸载这个服务 先要停止这个服务，然后输入httpd.exe -k uninstall –n “Apache24”进行卸载。 PHP 安装下载下载地址：PHP 7.3 (7.3.7) 关于php下载时VC各版本的区别和Non Thread Safe、Thread safe的简单辨析 参考：php下载时VC各版本的区别和Non Thread Safe、Thread safe的简单辨析 安装 解压缩 将压缩包放到E:/server/,同时重命名为PHP7 配置 Apache 加载 PHP 模块需改内容之后都需要重启apache Apache 加载 PHP 模块：在Apache的主配置文件中加载对应的PHP提供的模块 在apache安装目录的conf目录下对httpd.conf进行添加一下内容： #加载PHP LoadModule php7_module &#39;D:/server/php7/php7apache2_4.dll&#39; 验证 需改内容之后都需要重启apache Microsoft Windows [版本 10.0.17763.615] (c) 2018 Microsoft Corporation。保留所有权利。 C:\\Users\\Yan&gt;D: D:\\&gt;cd server\\apache\\bin D:\\server\\apache\\bin&gt;httpd.exe -t AH00558: httpd.exe: Could not reliably determine the server&#39;s fully qualified domain name, using fe80::3993:9c4f:39af:664d. Set the &#39;ServerName&#39; directive globally to suppress this message Syntax OK D:\\server\\apache\\bin&gt;httpd.exe -M AH00558: httpd.exe: Could not reliably determine the server&#39;s fully qualified domain name, using fe80::3993:9c4f:39af:664d. Set the &#39;ServerName&#39; directive globally to suppress this message Loaded Modules: core_module (static) win32_module (static) mpm_winnt_module (static) http_module (static) so_module (static) actions_module (shared) alias_module (shared) allowmethods_module (shared) asis_module (shared) auth_basic_module (shared) authn_core_module (shared) authn_file_module (shared) authz_core_module (shared) authz_groupfile_module (shared) authz_host_module (shared) authz_user_module (shared) autoindex_module (shared) cgi_module (shared) dir_module (shared) env_module (shared) include_module (shared) isapi_module (shared) log_config_module (shared) mime_module (shared) negotiation_module (shared) setenvif_module (shared) php7_module (shared) ##需要出现这个即可 Apache 分配工作给PHP模块：如果是PHP代码就交给PHP处理（通过文件后缀名.php进行识别） 在apache安装目录的conf目录下对httpd.conf进行添加一下内容： # 分配给PHP AddType application/x-httpd-php .php 需改内容之后都需要重启apache 将PHP的配置文件加载到Apache配置文件中，使之共同生效。 在Apache中指定PHP配置文件所在路径 httpd.conf中添加： #加载PHP配置文件 PHPIniDir &#39;D:/server/php7&#39; php.ini 文件是默认不存在的，是以development和production格式存在，需要格式化。 将php安装目录中的php.ini-development文件复制一个副本并重名为php.ini,然后重启Apache。 说明：PHP的配置文件已经加入到Apache的配置项中，意味着php.ini的修改需要Apache重启才会生效。 httpd.conf#加载PHP LoadModule php7_module &#39;D:/server/php7/php7apache2_4.dll&#39; #加载PHP配置文件 PHPIniDir &#39;D:/server/php7&#39; # 分配给PHP AddType application/x-httpd-php .php 安装MySQL为了方便安装，使用docker来搭建MySQL环境。没有条件的可以百度自行安装MySQL。 安装Docker参考： Ubuntu18.04 安装 Docker 安装MySQL输入以下命令： ## 拉取官方的镜像,标签为5.6 docker pull mysql:5.6 ## 运行 docker run --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.6 --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci ## -p 3306:3306：将容器的 3306 端口映射到主机的 3306 端口。 ## e MYSQL_ROOT_PASSWORD=123456：初始化 root 用户的密码。 ## --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci：解决中文问题 ## 进入MySQL docker exec -it mysql bash ## 登录MySQL mysql -u root -p ## 然后输入密码 MySQL的目录结构说明（Windows） bin目录 软件设计结构：C/S和B/SC/S:Client客户端/Server服务端，用户需要安装客户端产品才能访问服务器，而且只能访问一种软件（当前自己）B/S:Browser浏览器和/Server服务端，用户只需要安装浏览器，就可以访问所有的服务器（B/S架构服务） MySQL的访问流程 MySQL是一款C/S架构的软件，需要通过客户端来访问服务（MySQL其实也提供了其他模式的访问：通过一些插件扩展来充当客户端） 启用MySQL客户端：mysql.exe,该软件本身可以通过CMD控制台运行。 MySQL客户端访问服务端需要进行寻找匹配：连接认证连接：ip和端口确认，如果是本地都可以省略。 -h 主机地址—-》 -hlocalhost(可以是IP) -P 端口—》-P3306 认证：通过用户名和密码进入服务器 -u 用户名—》-uroot,不可以省略（匿名用户除外） -p 密码—》-proot 退出命令：\\q 注意：通常连接认证的时候密码不建议明文，可以在输入-p之后回车，系统会再次让输入密码，这个时候就是密文 PHP连接MySQL数据库PHP7正式移除了mysql 扩展，推荐使用mysqli或者pdo_mysql php7配置mysqli或者pdo_mysql和使用mysqli或者pdo_mysql连接MySQL我是该用 MySQLi ，还是 PDO? 如果你需要一个简短的回答，即 “你习惯哪个就用哪个”。MySQLi 和 PDO 有它们自己的优势：PDO 应用在 12 种不同数据库中， MySQLi 只针对 MySQL 数据库。所以，如果你的项目需要在多种数据库中切换，建议使用 PDO ，这样你只需要修改连接字符串和部分查询语句即可。 使用 MySQLi, 如果不同数据库，你需要重新编写所有代码，包括查询。两者都是面向对象, 但 MySQLi 还提供了 API 接口。两者都支持预处理语句。 预处理语句可以防止 SQL 注入，对于 web 项目的安全性是非常重要的。 首先配置php.ini文件 编辑php.ini 将 ;extension=mysqli 改为extension=mysqli。有的版本中会是 ;extension=php_mysqli.dll，原理都是将前面的 ; 去掉 将 ;extension=pdo_mysql 改为extension=pdo_mysql。有的版本中会是 ;extension=php_pdo.dll，原理都是将前面的 ; 去掉 再次编辑php.ini 将 extension_dir = “ext”改为 extension_dir = “D:/server/php7/ext”，D:/server/php7/ext为自己安装php的绝对路径 重启apache服务 编辑index.php &lt;?php phpinfo(); ?&gt; 浏览器输入：http://localhost:80/index.php 验证 数据库连接（三种方式） MySQLi - 面向对象 &lt;?php $servername = &quot;localhost&quot;; $username = &quot;username&quot;; $password = &quot;password&quot;; // 创建连接 $conn = new mysqli($servername, $username, $password); // 检测连接 if ($conn-&gt;connect_error) { die(&quot;连接失败: &quot; . $conn-&gt;connect_error); } echo &quot;连接成功&quot;; ?&gt; MySQLi - 面向过程 &lt;?php $servername = &quot;localhost&quot;; $username = &quot;username&quot;; $password = &quot;password&quot;; // 创建连接 $conn = mysqli_connect($servername, $username, $password); // 检测连接 if (!$conn) { die(&quot;Connection failed: &quot; . mysqli_connect_error()); } echo &quot;连接成功&quot;; ?&gt; PDO &lt;?php $servername = &quot;localhost&quot;; $username = &quot;username&quot;; $password = &quot;password&quot;; try { $conn = new PDO(&quot;mysql:host=$servername;&quot;, $username, $password); echo &quot;连接成功&quot;; } catch(PDOException $e) { echo $e-&gt;getMessage(); } ?&gt; 参考链接： PHP 连接 MySQL 设定PHP的系统时区 编辑php.ini 修改为以下内容 date.timezone = PRC 重启Apache服务 PHP标记与注释PHP语法初步PHP是一种运行在服务器端的脚本语言，可以嵌入到HTML中。 PHP代码标记在PHP历史发展中，可以使用多种标记来区分PHP脚本。 ASP标记：&lt;% php 代码 %&gt; 短标记：&lt;? php代码 ?&gt; 以上两种基本弃用，如果需要使用则需要在配置文件中开启。 脚本标记：&lt; script language=”php”&gt;php代码&lt;/ script &gt; &lt;html&gt; &lt;body&gt; &lt;b&gt; &lt;script language=&quot;php&quot;&gt; &lt;!--脚本标记--&gt; echo &#39;hello world&#39;; &lt;/script&gt; &lt;/b&gt; &lt;/body&gt; &lt;/html&gt; 注：移除了 ASP 和 script PHP 标签 标准标记（常用）：&lt;?php php代码?&gt; &lt;html&gt; &lt;body&gt; &lt;b&gt; &lt;?php echo &#39;hello world&#39;; ?&gt; &lt;/b&gt; &lt;/body&gt; &lt;/html&gt; PHP注释 习惯：所有的代码在写的过程中都必须进行注释。 PHP注释分为两种：行注释和块注释。 行注释：一次注释一行 //：后面跟的所有内容都是注释 #：与//一样 块注释：一次注释多行 /**/:**之间的全部都是注释。 代码示例： &lt;?php // 在脚本开始前：会对脚本功能进行简单阐述 // 注释的内容会在PHP解析的过程中忽略 // 块注释 /* * @功能说明：注释说明 * @作者：XXX * @版本：Version01 */ echo &#39;hello world&#39;; ?&gt; PHP语句分隔符语句分隔符：在PHP中，代码是以行为单位，系统需要通过判断行的结束，该结束通常都是一个符号：分号”;“(英文状态下的分号)。 代码示例： &lt;?php /** * Create by PhpStorm * Date: 2019/8/6 * Time: 21:38 * Features: 语句分隔符 */ // 语句结束符 // 动手试一下前一个语句不加语句结束符的概况和后一个语句不加语句结束符的概况 // echo &#39;hello world&#39; echo &#39;hello world&#39;; ?&gt; 特殊说明： PHP标记结束符?&gt;有自带语句结束符的效果，最后一行PHP代码可以没有语句结束符”;“。 PHP中其实很多代码的书写并不是嵌入到HTML中，而是单独存在，通常书写习惯中就不建议使用标记结束符?&gt;，PHP会自动从开始到最后全部认为是PHP代码，从而解析。 变量 PHP是一种动态网站开发的脚本语言,动态语言特点是交互性，会有数据的传递，而PHP作为”中间人“，需要进行数据的传递，传递的前提就是PHP能自己存储数据（临时存储）。 变量的基本概念 变量来源于数学，是计算机语言中能储存计算结果或能表示值抽象概念。变量可以通过变量名访问。在指令式语言中，变量通常是可变的。 变量是用来存储数据的。 变量是存在名字的。 变量是通过名字来访问的：数据 变量是可以改变的：数据。 变量的使用 PHP中的所有变量都必须使用”$“符号。 定义：在系统中增加对应的变量名字（内存中） 赋值：可以将数据赋值给变量名（可以在定义的同时完成） 可以通过变量名访问存储的数据 可以将变量从内存中删除 代码示例： &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/6 * Time: 22:03 * Features: 定义变量 * */ // 变量 // 定义变量：在PHP中不需要任何关键字诋毁能够以变量（赋值） $var1; //定义变量 $var1=1; $var2=1; //定义同时赋值 // 访问变量 echo $var2; //通过var2变量名字找到存储的内容1，然后输出 //修改变量 $var2=2; echo &#39;&lt;hr/&gt;&#39;,$var2; // 删除变量：使用unset(变量名字) unset($var2); echo $var2; // 第一，文件末尾的 ? &gt;可以省略 // 第二，该脚本若被其他脚本包含，所以该脚本不需要结束，否则会报错，因为是要和其他脚本衔接，只有在php代码后面需要写html的才使用闭合标签。 ?&gt; 变量命名规则 在PHP中变量名必须以“$”符号开始； 名字由字母、数字和下划线“_”构成，但是不能以数字开头； 在PHP中本身还允许中文变量（不建议） 代码示例： // 变量命名规则 $var_1;$var_var_1;$_var1; //正确格式 $1var; //不正确格式 // 中文变量 $中国=‘china’; 预定义变量 预定义变量：提前定义的变量，系统定义的变量，存储许多需要用到的数据（预定义变量都是数组）。 $_GET：获取所有表单以get方式提交的数据 $_POST：POST提交的数据都会保存在此 $_REQUEST：GET和POST提交的都会保存 $GLOBALS：PHP中所有的全局变量 $_SERVER：服务器信息 $_SESSION：session会话数据 $_COOKIE：cookie会话数据 $_ENV：环境信息 $_FILES：用户上传的文件信息 可变变量 可变变量：如果 一个变量保存的值 刚好是另外一个变量的名字，那么可以直接通过访问一个变量得到另外一个变量的值：在变量前面在多加一个$符号。 代码示例： &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/7 * Time: 15:15 * Features: 可变变量 */ // 可变变量 // 定义两个变量 $a = &#39;b&#39;; $b = &#39;bb&#39;; echo $$a; // 1、找到$a，解析结果：b // 2、将前面的$符号与结果 b绑定：$b // 3、解析 ?&gt; 变量传值 将一个变量赋值给另外一个变量：变量传值。 变量传值一共有两个方式：值传递 ，引用传递。 值传递：将变量保存的值赋值一份，然后将新的值给另外一个变量保存。（两个变量没有关系） 引用传递：将变量保存的值所在的内存地址，传递给另外一个变量：两个变量指向同一块内存空间。（两个变量是同一个值） 在内存中，通常有以下几个分区： 栈区：程序可以操作的内存部分（不存数据，运行程序代码），少但是快 代码段：存储程序的内部部分（不执行） 数据段：存储普通数据 （全局区和静态区） 堆区：存储复杂数据，大但是效率低 代码示例： &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/7 * Time: 16:04 * Features: 变量传值 */ // 变量传值 // 值传递 $a=10; $b=$a; $b=5; echo $a,$b,&#39;&lt;/br&gt;&#39;; //引用传递 $c=10; $d=&amp;$c; $c=5; echo $c,$d,&#39;&lt;/br&gt;&#39;; ?&gt; 常量 常量与变量 一样，都是用来保存数据的。 常量基本概念 常量：const/constant，是一种在程序运行当中，不可改变的量（数据）。常量一旦定义，通常数据不可改变（用户级别）。 常量定义形式在PHP中常量有两种定义方式（5.3之后才有两种）： 使用定义常量的函数:define(&#39;常量名&#39;,常量值); 5.3之后才有的：const 常量名=值; 代码示例： &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/7 * Time: 16:27 * Features: 常量 */ // 常量 // 使用函数定义常量:define define(&#39;PI&#39;,3.14); // 使用const关键字定义 const PII=3; ?&gt; 常量名字的命名规则： 常量不需要使用“$”符号，一旦使用系统就会认为是变量 常量的名字组成由字母、数字和下划线组成，不能以数字开头 常量的名字通常是以大写字母为主（与变量以示区别） 常量命名的规则比变量要松散，可以使用一些特殊字符，该方式只能使用define定义 代码示例： &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/7 * Time: 16:27 * Features: 常量 */ // 常量 // 使用函数定义常量:define define(&#39;PI&#39;,3.14); // 使用const关键字定义 const PII=3; // 定义特使常量 define(&#39;-_-&#39;,&#39;small&#39;); // const -_-=&#39;smali&#39;; //错误 ?&gt; 注意细节： define和const定义的常量是由区别的：在于访问权限区别。 定义常量通常不区分大写写，但是可以区分，可以参照define函数的第三个参数。 常量使用形式 常量的使用与变量一样：不可改变值（在定义的时候必须赋值）。 有的时候还需要使用另外一种形式来访问（针对的是特殊名字的常量），需要用到另外一个访问常量的函数：constant(&#39;常量名&#39;)。 说明：常量和变量的使用 凡是数据会可能变化的，那么肯定使用变量 数据不一定会变，可以使用常量或者变量（变量居多） 数据不允许被修改的，一定用常量 代码示例： &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/7 * Time: 16:27 * Features: 常量 */ // 常量 // 使用函数定义常量:define define(&#39;PI&#39;,3.14); // 使用const关键字定义 const PII=3; // 定义特使常量 define(&#39;-_-&#39;,&#39;small&#39;); // const -_-=&#39;smali&#39;; //错误 // 使用常量 echo PI; // echo -_-; //特殊符号不能直接使用 echo constant(&#39;-_-&#39;); ?&gt; 系统常量 系统常量：系统帮助用户定义的常量，用户可以直接使用。 常用的几个系统常量 PHP_VERSION:PHP版本号PHP_INT_SIZE:整型大小PHP_INT_MAX:整型能表示的最大值(PHP中整型是允许出现负数的：带符号) 代码示例： &lt;?php // 系统常量 echo &#39;&lt;/br&gt;&#39;,PHP_VERSION,&#39;&lt;/br&gt;&#39;,PHP_INT_SIZE,&#39;&lt;/br&gt;&#39;,PHP_INT_MAX; ?&gt; 在PHP中还有一些特殊的常量，他们由双下划线开始+常量名+双下划线结束，这种常量称之为系统魔术常量：魔术常量的值通常会跟着环境变化，但是用户改变不了。 __DIR__:当前被执行的脚本所在电脑的绝对路径__FILE__:当前被执行的脚本所在的电脑的绝对路径（带自己文件的名字）___LINE__:当前所属的行数_NAMESPACE__:当前所属的命名空间__CLASS__:当前所属的类__METHOD__:当前所属的方法 代码示例： &lt;?php // 魔术常量 echo &#39;&lt;hr/&gt;&#39;; echo __DIR__,&#39;&lt;br/&gt;&#39;,__FILE__,&#39;&lt;br/&gt;&#39;,__LINE__,&#39;&lt;br/&gt;&#39;; echo __LINE__; ?&gt; 数据类型PHP的八种数据类型类型转换类型判断","categories":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/categories/PHP/"},{"name":"入门","slug":"PHP/入门","permalink":"http://yoursite.com/categories/PHP/入门/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/tags/PHP/"},{"name":"入门","slug":"入门","permalink":"http://yoursite.com/tags/入门/"}]},{"title":"饥荒游戏服务器端搭建","slug":"饥荒游戏服务器端搭建","date":"2019-07-29T10:20:26.091Z","updated":"2019-08-02T12:18:10.401Z","comments":true,"path":"2019/07/29/饥荒游戏服务器端搭建/","link":"","permalink":"http://yoursite.com/2019/07/29/饥荒游戏服务器端搭建/","excerpt":"Linux服务器要求 上行带宽：8KBps 一个玩家； 内存：差不多一个玩家 65Mbytes； CPU：没太大要求","text":"Linux服务器要求 上行带宽：8KBps 一个玩家； 内存：差不多一个玩家 65Mbytes； CPU：没太大要求 服务器端口开放默认情况下，服务器在端口10999上使用UDP流量 因此需要将服务器的10999端口进行开放 内存为了防止内存不足，开启SWAP。 首先确认SWAP设置了多少 free -m 如果觉得不满意其空间大小，则对SWAP进行删除 swapoff -a 新增SWAP分区 dd if=/dev/zero of=/root/swapfile bs=1M count=1024 #1024大小可根据自己情况进行更改 格式化交换分区文件 mkswap /root/swapfile 启用swap分区文件 swapon /root/swapfile 添加开机启动 vi /etc/fstab 这里提一下vi编辑器的基本用法：进入文本后按键盘上的insert按钮开始编辑，按esc退出编辑，输入:wq保存并退出。 添加或修改 /root/swapfile swap swap defaults 0 0 重启下是否生效 reboot 重启后输入指令查看下SWAP是否增加 free -m 依赖安装# Ubuntu $ sudo apt-get install libstdc++6:i386 libgcc1:i386 libcurl4-gnutls-dev:i386 lib32gcc1 # CentOS(仅供参考) $ yum -y install glibc.i686 libstdc++.i686 libcurl4-gnutls-dev.i686 libcurl.i686 安装 SteamCMDSteamCMD，顾名思义，就是 Steam 的命令行版本。虽然饥荒服务器本身并不需要用 Steam 进行验证啊之类的，但我们还是得用它来把服务器更新到最新版本，不然其他人是进不来的。 我们最好新建一个用户来运行 SteamCMD，如果直接用 root 用户运行游戏服务端的话可能会导致严重的安全隐患。在 root 权限下使用以下命令来创建一个新用户： $ useradd -m steam $ su - steam 然后在你喜欢的地方创建一个为 SteamCMD 准备的目录： $ mkdir ~/steamcmd ## 创建目录 $ cd ~/steamcmd ## 进入该目录 下载并解压 Linux 专用的 SteamCMD： $ wget https://steamcdn-a.akamaihd.net/client/installer/steamcmd_linux.tar.gz ## 下载 $ tar -xvzf steamcmd_linux.tar.gz ## 解压 运行 SteamCMD： $ ./steamcmd.sh 登录安装退出操作： # 匿名登录，没必要用用户名密码登录 login anonymous # 这里我们强制要 Steam 把饥荒服务端安装到此目录下 # 最好用绝对路径，否则可能会安装到奇怪的地方去 force_install_dir ../dontstarvetogether_dedicated_server app_update 343050 validate quit 安装完成后，使用 quit 命令退出 steam 程序。 成功安装所出现的标志： Success! App &#39;343050&#39; fully installed. 通过客户端获取配置文件服务器端配置文件位置及相关操作饥荒的配置目录位于: ~/.klei/DoNotStarveTogether 然后手动创建一个存档目录： mkdir -p ~/.klei/DoNotStarveTogether/MyDediServer 利用客户端创建世界 进入游戏 创建自己的世界，设置可自定应。 以 Windows 为例（Linux/Mac 类似），存档位置位于 /Users/username/Documents/Klei/DoNotStarveTogether，也就是文档目录下。 在该目录的下一级目录中，在一个全是数字的文件夹中有一个命名为 Cluster_X 的文件夹（X 为数字编号），提取出刚刚创建的存档。 修改配置文件cluster.ini 修改bind_ip和master_ip内容 [SHARD] shard_enabled = true bind_ip = 0.0.0.0 master_ip = 你的主服务器的 IP Mod进入到服务器的的饥荒安装目录： cd ~/dontstarvetogether_dedicated_server/mods 修改该目录下的 dedicated_server_mods_setup.lua 文件： vim dedicated_server_mods_setup.lua # 在该文件中添加类似这样的内容，这串 ID 是 Mod 文件在 Steam 中的 ID # 可以在提取到的配置文件的 Master/modoverrides.lua 中找到 # 然后添加到本文件中，一行一个 ServerModSetup(&quot;362175979&quot;) 本教程模板： ServerModSetup(&quot;1089344410&quot;) ServerModSetup(&quot;1146082006&quot;) ServerModSetup(&quot;1200745268&quot;) ServerModSetup(&quot;1207269058&quot;) ServerModSetup(&quot;1290228121&quot;) ServerModSetup(&quot;1301033176&quot;) ServerModSetup(&quot;352499675&quot;) ServerModSetup(&quot;362175979&quot;) ServerModSetup(&quot;375850593&quot;) ServerModSetup(&quot;378160973&quot;) ServerModSetup(&quot;380423963&quot;) ServerModSetup(&quot;444235588&quot;) ServerModSetup(&quot;458587300&quot;) ServerModSetup(&quot;462434129&quot;) ServerModSetup(&quot;488009136&quot;) ServerModSetup(&quot;577104313&quot;) ServerModSetup(&quot;622448972&quot;) ServerModSetup(&quot;666155465&quot;) ServerModSetup(&quot;682721879&quot;) ServerModSetup(&quot;785295023&quot;) ServerModSetup(&quot;841471368&quot;) ServerModSetup(&quot;892478248&quot;) ServerModSetup(&quot;934638020&quot;) 上传配置文件将配置文件上传到 ~/.klei/DoNotStarveTogether/MyDediServer下 Linux传输文件可参考链接： Linux scp命令 Linux下如何将一个用户下的文件拷贝到另一个用户里 Linux中zip压缩和unzip解压缩命令详解 配置user_id和自己的token搭建服务器需要相关的管理人员以及相关token文件 获取相关文件进入 https://accounts.klei.com/account/info 该链接 按图中步骤进行操作首先获取用户id,下图中的箭头所指的即是用户id，复制之后作为设置管理员文件的信息。 点击 导航栏 – 游戏 – Don’t Starve Together Server 下图中三个箭头所指的东西任选其一即可，同时最下方也可以支持添加。复制作为token。 编辑相关文件先新建 cluster_token.txt 文件，再将此前获取到的 Token 复制到文件中。 touch cluster_token.txt 再新建 adminlist.txt 文件，再将此前获取到的 UserID 复制到文件中。 touch adminlist.txt 启动游戏启动脚本创建脚本文件: cd ~ &amp;&amp; touch startDST.sh 编辑脚本文件: #!/bin/bash steamcmd_dir=&quot;$HOME/steamcmd&quot; install_dir=&quot;$HOME/dontstarvetogether_dedicated_server&quot; cluster_name=&quot;MyDediServer&quot; dontstarve_dir=&quot;$HOME/.klei/DoNotStarveTogether&quot; cd &quot;$install_dir/bin&quot; run_shared=(./dontstarve_dedicated_server_nullrenderer) run_shared+=(-console) run_shared+=(-cluster &quot;$cluster_name&quot;) run_shared+=(-monitor_parent_process $$) &quot;${run_shared[@]}&quot; -shard Caves | sed &#39;s/^/Caves: /&#39; &amp; &quot;${run_shared[@]}&quot; -shard Master | sed &#39;s/^/Master: /&#39; 给启动脚本添加权限： chmod +x ./startDST.sh 运行： ./startDST.sh 更新游戏版本创建脚本文件： cd ~ &amp;&amp; touch updateDST.sh 编辑脚本文件： #!/bin/bash steamcmd_dir=&quot;$HOME/steamcmd&quot; ## 检查并更新更新游戏版本 cd &quot;$steamcmd_dir&quot; ./steamcmd.sh +@ShutdownOnFailedCommand 1 +@NoPromptForPassword 1 +login anonymous +force_install_dir ../dontstarvetogether_dedicated_server +app_update 343050 validate +quit 给脚本添加权限： chmod +x ./startDST.sh 模板下载下载地址： DST服务器搭建","categories":[{"name":"游戏","slug":"游戏","permalink":"http://yoursite.com/categories/游戏/"},{"name":"饥荒","slug":"游戏/饥荒","permalink":"http://yoursite.com/categories/游戏/饥荒/"}],"tags":[{"name":"游戏","slug":"游戏","permalink":"http://yoursite.com/tags/游戏/"},{"name":"饥荒","slug":"饥荒","permalink":"http://yoursite.com/tags/饥荒/"}]},{"title":"解决git clone速度慢的问题","slug":"解决git clone速度慢的问题","date":"2019-07-16T12:12:59.244Z","updated":"2019-07-17T07:05:14.312Z","comments":true,"path":"2019/07/16/解决git clone速度慢的问题/","link":"","permalink":"http://yoursite.com/2019/07/16/解决git clone速度慢的问题/","excerpt":"解决方案","text":"解决方案 1. 在git内部设置代理 命令行 git config --global http.proxy socks5://127.0.0.1:1080 git config --global https.proxy socks5://127.0.0.1:1080 直接编辑相关文件 C:\\Users\\用户名文件夹下的 .gitconfig,点击打开。将以下内容添加进去。 [http] proxy = socks5://127.0.0.1:1080 [https] proxy = socks5://127.0.0.1:1080 2. 注意下载时是否是https3. 在使用代理下载时，会遇到git push需要每次输入密码。通过以下方式解决该问题。 设置记住密码（默认15分钟）： git config --global credential.helper cache 如果想自己设置时间，可以这样做： git config credential.helper &#39;cache --timeout=3600&#39; 这样就设置一个小时之后失效 长期存储密码： git config --global credential.helper store 参考 提高 git clone 速度 git设置代理、记住密码","categories":[{"name":"git","slug":"git","permalink":"http://yoursite.com/categories/git/"},{"name":"git clone速度慢","slug":"git/git-clone速度慢","permalink":"http://yoursite.com/categories/git/git-clone速度慢/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"git clone速度慢","slug":"git-clone速度慢","permalink":"http://yoursite.com/tags/git-clone速度慢/"}]},{"title":"Java基础","slug":"java基础","date":"2019-07-14T13:17:20.148Z","updated":"2019-08-07T14:16:17.537Z","comments":true,"path":"2019/07/14/java基础/","link":"","permalink":"http://yoursite.com/2019/07/14/java基础/","excerpt":"代码仓库地址欢迎下载：GitHub 运行环境： IntelliJ IDEA 2019.1.3(Ultimate Edition) jdk 1.8.0_211 Java8手册文件名为jdk1.8.CHM即为Java8手册。 打不开参考下面链接： 解决win10中无法打开CHM文件的方法 Java 基础Java简介","text":"代码仓库地址欢迎下载：GitHub 运行环境： IntelliJ IDEA 2019.1.3(Ultimate Edition) jdk 1.8.0_211 Java8手册文件名为jdk1.8.CHM即为Java8手册。 打不开参考下面链接： 解决win10中无法打开CHM文件的方法 Java 基础Java简介 Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程。 Java具有简单性、面向对象、分布式、健壮性、安全性、平台独立与可移植性、多线程、动态性等特点 。Java可以编写桌面应用程序、Web应用程序、分布式系统和嵌入式系统应用程序等。 详情 运行环境搭建下载JDK建议使用1.8及以上的版本。官方下载路径：jdk下载路地址 安装双击下载软件，一路单击下一步即可。 配置环境变量Windows：右击【我的电脑】→【属性】→【高级系统设置】→【环境变量】→【系统变量】→【新建】，接着如下图所示： 在【系统变量】的path中添加 %JAVA_HOME%\\bin。 验证，如下图所示： Hello Worldpublic class helloworld { public static void main(String[] args) { System.out.println(&quot;helloworld&quot;); } } Hello World 运行原理 工具Intellij IDEA下载路径：indea U 激活（针对学生的免费使用计划）参考：Intellij IDEA的下载和使用（针对学生的免费使用计划） 注释、标识符命名规则及Java中的关键字1. Java注释1. 单行注释：// 2. 多行注释：/*。。。。。*/ 3. 文档注释：/**。。。*/ 2. 标识符命名标识符定义：Java语言中，对于变量、常量、函数、语句块也有名字，我们统统称为Java标识符。 标识符作用：标识符是用来给类、对象、方法、常量、接口和自定义数据类型命令的。 标识符命名规则：Java标识符由数字、字母和下划线（_），美元符号（$）组成。在Java中是区分大小写的，而且还要求首位不能是数字。最重要的是，Java关键字不能当作Java标识符。 3. Java关键字 访问控制 private protected public 类，方法和变量修饰符 abstract class extends final implements interface native new static strictfp synchronized transient volatile 程序控制 break continue return do while if else for instanceof switch case default 错误处理 try catch throw throws finally 包相关 import package 基本类型 boolean byte char double float int long short null true false 变量引用 super this void 保留字 goto const 参考：Java 关键字总结 Java基本数据类型1. 数据类型分类 2. 整数类型 序号 数据类型 大小/位 可表示的数据范围 1 byte(位) 8 -27到（26-1） 2 short(整型) 16 -215到（215-1） 3 int(整型) 32 -231到（231-1） 4 long(长整型) 64 -263到（263-1） Byte数据范围表示 符号位 1 1 1 1 1 1 1 1 符号位0表示正 范围 00000000~01111111符号位1表示负 范围 10000000~11111111（减一取反） 代码实例： package com.java.chap03; /** * @author Yan * @date 2019/7/16 13:52 */ public class Demo1 { public static void main(String[] args) { //定义一个int类型的变量 int a; //给变量a赋值 a=1; System.out.println(a); //定义一个int类型的变量a2 int a2=1; System.out.println(&quot;a2=&quot;+a2); //定义一个byte类型的变量b byte b=3; System.out.println(&quot;b=&quot;+b); //定义一个short类型的变量 short s=4; System.out.println(&quot;s=&quot;+s); //定义一个long类型的变量l long l=5; System.out.println(&quot;l=&quot;+l); int a11=1; int a22=2; int a3=a11+a22; System.out.println(&quot;a1+a2=&quot;+a3); } } 3. 浮点类型 序号 数据类型 大小/位 可表示的数据范围 1 float(单精度) 32 -3.4E38(-3.4x1038) 到 3.4E38(3.4x1038)) 2 double(双精度) 64 -1.7E308(-1.7x10308) 到 1.7E308(1.7x10308)) 代码示例： package com.java.chap03; /** * @author Yan * @date 2019/7/16 13:53 */ public class Demo2 { public static void main(String[] args) { //定义一个float类型的变量f //小数默认是double类型，所以必须加一个f,来表示float类型 float f=1.1f; System.out.println(&quot;f=&quot;+f); //定义一个double类型变量d double d=1.2; System.out.println(&quot;d=&quot;+d); //获取float的最大值 float maxF=Float.MAX_VALUE; System.out.println(&quot;float最大值：&quot;+maxF); //获取float的最小值 float minF=Float.MIN_VALUE; System.out.println(&quot;float最小值：&quot;+minF); } } 4. 字符型字符型常量有3种表示形式。char 1. 直接通过单个字符来指定字符型常量，如‘A’，‘b’，‘5’； 2. 通过转义字符表示特殊字符型常量，如‘\\n’,‘\\\\’; 3. 直接使用Unicode值来表示字符型常量，如‘\\u66f9’，‘\\yu950b’； 转义字符 说明 \\b 退格 \\n 换行 \\t 制表符 \\” 双引号 \\’ 单引号 \\ 反斜杠 \\r 回车符 代码示例: package com.java.chap03; /** * @author Yan * @date 2019/7/16 13:53 */ public class Demo3 { public static void main(String[] args) { //定义一个单个字符 char c1=&#39;A&#39;; System.out.println(&quot;c1=&quot;+c1); //定义一个反斜杠字符 char c2=&#39;\\\\&#39;; System.out.println(&quot;c2=&quot;+c2); //用Unicode编码输出自己的名字 char c3=&#39;\\u66f9&#39;; char c4=&#39;\\u950b&#39;; System.out.println(&quot;c3=&quot;+c3); System.out.println(&quot;c4=&quot;+c4); } } 5. 布尔类型布尔类型的变量只有true(真)和false(假)两种。 package com.java.chap03; /** * @author Yan * @date 2019/7/16 13:53 */ public class Demo4 { public static void main(String[] args) { //定义一个布尔类型变量b1 boolean b1=true; System.out.println(&quot;b1=&quot;+b1); //定义一个布尔类型变量b2 boolean b2=false; System.out.println(&quot;b2=&quot;+b2); } } 6. 基本类型的类型转换1. 自动类型转换 条件： 1. 转换前后的数据类型兼容； 2. 转换后的数据类型的表示范围要比转换前的大； 2. 强制类型转换 代码示例： package com.java.chap03; /** * @author Yan * @date 2019/7/16 13:53 */ public class Demo5 { public static void main(String[] args) { //自动类型转换 short s=1; int i; //自动类型转换 short类型转成int类型 i=s; System.out.println(&quot;i=&quot;+i); //强制类型转换 double d=1.333; float f; //把double类型的数据强制转换成float类型 f=(float) d; System.out.println(&quot;f=&quot;+f); } } Java运算符与表达式 1. 赋值运算符符号：=（赋值） package com.java.chap04; /** * @author Yan * @date 2019/7/16 13:01 */ public class Demo1 { public static void main(String[] args) { //定义变量a int a; //给变量a赋值 a=1; System.out.println(&quot;a=&quot;+a); //定义变量a，并且给a赋值 int a2=2; System.out.println(&quot;a2=&quot;+a2); } } 2. 算数运算符符号：+（加），-（减），*（乘），/（除），%（取模） package com.java.chap04; /** * @author Yan * @date 2019/7/16 13:07 */ public class Demo2 { public static void main(String[] args) { int a=10; int b=3; //+运算符 System.out.println(a+&quot;+&quot;+b+&quot;=&quot;+(a+b)); //-运算符 System.out.println(a+&quot;-&quot;+b+&quot;=&quot;+(a-b)); //*运算符 System.out.println(a+&quot;*&quot;+b+&quot;=&quot;+(a*b)); // /运算符 System.out.println(a+&quot;/&quot;+b+&quot;=&quot;+(a/b)); //%运算符 System.out.println(a+&quot;%&quot;+b+&quot;=&quot;+(a%b)); } } 3. 自增与自减运算符符号：++（自增），–（自减）重点：a++和++a的区别 package com.java.chap04; /** * @author Yan * @date 2019/7/16 13:13 */ public class Demo3 { public static void main(String[] args) { int a = 1; //a++表示先做赋值操作，然后自增 /* int b=a++; System.out.println(&quot;b=&quot;+b); System.out.println(&quot;a=&quot;+a); */ //++a表示先自增，然后赋值操作 int b=++a; System.out.println(&quot;b=&quot;+b); System.out.println(&quot;a=&quot;+a); } } 4. 逻辑运算符符号：&amp;&amp;（与），&amp;（不短路与），||（或），|（不短路或），!(非)，^（亦或） package com.java.chap04; /** * @author Yan * @date 2019/7/16 13:53 */ public class Demo4 { public static void main(String[] args) { // &amp;&amp; 与 前后两个操作数必须都是true才返回true，否则返回false boolean b1 = (5 &lt; 3) &amp;&amp; (4 &gt; 5); System.out.println(&quot;b1 = &quot; + b1); //&amp; 不短路与 boolean b2 = (5 &lt; 3) &amp; (4 &gt; 5); System.out.println(&quot;b2 = &quot; + b2); //一般都使用 &amp;&amp; //原因：效率高 // || 或 只要两个操作数中有一个是true，就返回true，否则返回false boolean b3 = (2 &lt; 3) || (4 &gt; 5); System.out.println(&quot;b3 = &quot; + b3); // | 不短路或 boolean b4 = (2 &lt; 3) | (4 &gt; 5); System.out.println(&quot;b4 = &quot; + b4); // ! 非，如果操作数为true，返回false，否则返回true boolean b5 = !(3 &lt; 4); System.out.println(&quot;b5 = &quot; + b5); // ^ 异或 当两个操作数不相同时，返回true，否则返回false boolean b6 = (5 &gt; 4) ^ (4 &gt; 5); System.out.println(&quot;b6 = &quot; + b6); } } 5. 关系运算符符号：&gt;(大于)，&lt;(小于)，&gt;=（大于等于），&lt;=(小于等于)，==（等于），!=(不等于) package com.java.chap04; /** * @author Yan * @date 2019/7/16 14:22 */ public class Demo5 { public static void main(String[] args) { int a = 2; int b = 3; // &gt; 大于 System.out.println(a + &quot;&gt;&quot; + b + &quot;:&quot; + (a &gt; b)); // &lt; 小于 System.out.println(a + &quot;&lt;&quot; + b + &quot;:&quot; + (a &lt; b)); // &gt;= 大于等于 System.out.println(a + &quot;&gt;=&quot; + b + &quot;:&quot; + (a &gt;= b)); // &lt;= 小于等于 System.out.println(a + &quot;&lt;=&quot; + b + &quot;:&quot; + (a &lt;= b)); // == 等于 System.out.println(a + &quot;==&quot; + b + &quot;:&quot; + (a == b)); // != 不等于 System.out.println(a + &quot;!=&quot; + b + &quot;:&quot; + (a != b)); } } 6. 三目运算符格式：（表达式）？表达式为true返回值A：表达式为false返回值B package com.java.chap04; /** * @author Yan * @date 2019/7/16 14:26 */ public class Demo6 { public static void main(String[] args) { //三目运算符 String s=2&gt;3?&quot;表达式为真&quot;:&quot;表达式为假&quot;; System.out.println(&quot;s = &quot; + s); } } Java选择与循环语句1. 程序的选择结构1. if 语句 2. if...else 语句 3. if...else if...else 语句 package com.java.chap05; /** * @author Yan * @date 2019/7/16 15:16 */ public class Demo1 { public static void main(String[] args) { int a=-1; // if语句 if (a&gt;0){ System.out.println(a+&quot;是正数&quot;); } //if...else语句 if (a&gt;0){ System.out.println(a+&quot;是正数&quot;); }else { System.out.println(a+&quot;不是正数&quot;); } //if...else if...else if (a&gt;0){ System.out.println(a+&quot;是正数&quot;); }else if (a&lt;0){ System.out.println(a+&quot;是负数&quot;); }else{ System.out.println(a+&quot;是0&quot;); } } } 4. switch 语句 package com.java.chap05; import java.util.Scanner; /** * @author Yan * @date 2019/7/16 15:22 */ public class Demo2 { public static void main(String[] args) { System.out.println(&quot;请输入一个数字&quot;); //定义一个系统输入对象 Scanner scanner=new Scanner(System.in); int n=scanner.nextInt(); //System.out.println(n); switch (n){ case 1:{ System.out.println(&quot;用户输入的是1&quot;); break; } case 2:{ System.out.println(&quot;用户输入的是2&quot;); break; } default:{ System.out.println(&quot;用户输入的是其他数字&quot;); } } } } 2. 程序的循环结构1. while 循环 2. do...while 循环 3. for 循环 4. for 循环的嵌套 package com.java.chap05; /** * @author Yan * @date 2019/7/16 15:31 */ public class Demo3 { public static void main(String[] args) { //在控制台输出1到10 //while 循环语句 int i = 1; while (i &lt; 11) { System.out.print(i + &quot; &quot;); i++; } System.out.println(&quot;\\n-------------------&quot;); // do...while 循环语句 int j = 1; do { System.out.print(j + &quot; &quot;); j++; } while (j &lt; 11); System.out.println(&quot;\\n-------------------&quot;); //while和do...while的区别 //while是先判断后执行，do...while是先执行后判断 // for 循环 for (int k = 1; k &lt; 11; k++) { System.out.printf(k + &quot; &quot;); } System.out.println(&quot;\\n-------------------&quot;); // for循环的嵌套 for (int m = 0; m &lt; 10; m++) { for (int n = 0; n &lt; 10; n++) { System.out.print(&quot;m=&quot; + m + &quot;n=&quot; + n+&quot; &quot;); } System.out.println(); } } } 5. 求水仙花数 package com.java.chap05; /** * @author Yan * @date 2019/7/16 15:42 */ public class Demo4 { public static void main(String[] args) { for (int i=100;i&lt;=999;i++){ //求出百位数 int b=i/100; //求出十位数 int s=(i-b*100)/10; //求出个位数 int g=(i-b*100-s*10); if (i==g*g*g+s*s*s+b*b*b){ System.out.println(i+&quot; &quot;); } } } } 3. 循环结构的控制1. break 语句 结束循环 package com.java.chap05; /** * @author Yan * @date 2019/7/16 15:52 */ public class Demo5 { public static void main(String[] args) { for (int i=0;i&lt;10;i++){ for (int j=0;j&lt;10;j++){ if (i==1){ break; } System.out.print(&quot;i=&quot;+i+&quot; j=&quot;+j+&quot; &quot;); } System.out.println(); } } } package com.java.chap05; /** * @author Yan * @date 2019/7/16 15:55 */ public class Demo6 { public static void main(String[] args) { outer: for (int i=0;i&lt;10;i++){ for (int j=0;j&lt;10;j++){ if (i==1){ break outer; } System.out.print(&quot;i=&quot;+i+&quot; j=&quot;+j+&quot; &quot;); } System.out.println(); } } } 2. continue 语句 结束本次循环 package com.java.chap05; /** * @author Yan * @date 2019/7/16 15:57 */ public class Demo7 { public static void main(String[] args) { for (int i=0;i&lt;10;i++){ if (i==4){ continue; } System.out.print(&quot;i=&quot;+i+&quot; &quot;); } } } 3. return 语句 结束方法 package com.java.chap05; /** * @author Yan * @date 2019/7/16 15:59 */ public class Demo8 { public static void main(String[] args) { for (int i=0;i&lt;10;i++){ for (int j=0;j&lt;10;j++){ if (i==1){ return; } System.out.print(&quot;i=&quot;+i+&quot; j=&quot;+j+&quot; &quot;); } System.out.println(); } System.out.println(&quot;执行到这里了&quot;); } } Java数组1. 数组简介数组是Java中最常见的一种数据结构，可用于存储多个数据。 2. 数组的定义type[] arrayName;或者type arrayName[]; 实例： int []arr; int arr[]; package com.java.chap06; /** * @author Yan * @date 2019/7/17 14:08 */ public class Demo1 { public static void main(String[] args) { //定义一个数组 int []arr; //定义一个数组 int arr2[]; } } 3. 数组的初始化1. 静态初始化 格式 arrayName=new type[]{element1,element2,element3.....} 实例： int arr1[]=new int[]{1,2,3}; package com.java.chap06; /** * @author Yan * @date 2019/7/17 14:14 */ public class Demo2 { public static void main(String[] args) { //定义一个数组，并且静态初始化 int arr[]=new int[]{1,2,3}; //普通的遍历数组方式 for (int i=0;i&lt;arr.length;i++){ System.out.println(arr[i]); } System.out.println(&quot;------------&quot;); //foreach方法遍历数组 for (int j:arr){ System.out.println(j); } } } 2. 动态初始化 格式 arrayName=new type[length]; 实例： int arr2[]=new int[3]; package com.java.chap06; /** * @author Yan * @date 2019/7/17 14:18 */ public class Demo3 { public static void main(String[] args) { //定义一个数组，然后动态初始化，长度是3 int arr[]=new int[3]; for(int i:arr){ System.out.println(i); } } } 内存分析 4. 二维数组及多维数组二维数组静态化初始化 格式： arrayName=new type[]{{element1,element2},{element1,element2},{element1,element2}}; 实例： int[][]arr=new int[][]{1,2,3},{4,5,6},{7,8,9}}; 二维数组动态初始化 格式： arrayName=new type[length][length]; 实例： int [][]arr2=new int[3][3]; package com.java.chap06; /** * @author Yan * @date 2019/7/17 14:35 */ public class Demo4 { public static void main(String[] args) { //定义一个二维数组,并静态初始化 int [][]arr=new int[][]{{1,2,3},{4,5,6},{7,8,9}}; //输出 for (int i=0;i&lt;arr.length;i++){ for (int j=0;j&lt;arr[0].length;j++){ System.out.print(arr[i][j]+&quot; &quot;); } System.out.println(); } //二维数组的动态初始化 int [][]arr2=new int[3][3]; for (int i=0;i&lt;arr2.length;i++){ for (int j=0;j&lt;arr2[0].length;j++){ System.out.print(arr2[i][j]+&quot; &quot;); } System.out.println(); } } } 5. 起泡法对4，21，0，-12，-3排序。原理：起泡法是从一端开始比较的，第一次循环就是把最大数放到最后一个位置，第二次循环就是把第二最大数放到倒数第二个位置。 4 21 0 -12 -3 第1次 4 0 -12 -3 21 第2次 0 -12 -3 4 21 第3次 -12 -3 0 4 21 第4次 -12 -3 0 4 21 package com.java.chap06; /** * @author Yan * @date 2019/7/17 14:46 */ public class Demo5 { public static void main(String[] args) { int temp; int []arr={4,21,0,-12,-3}; //循环的次数n-1次 for (int i=0;i&lt;arr.length-1;i++){ //比较次数n-1-i for (int j=0;j&lt;arr.length-1-i;j++){ //假如前面一个数大于后面一个数，则交换数据 if (arr[j]&gt;arr[j+1]){ temp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; } } } for (int i:arr){ System.out.print(i+&quot; &quot;); } } } Java面向对象1. 面向对象的基本概念定义：以基于对象的思维去分析和解决问题，万物皆对象；三大特性：封装，继承，多态； 2. 类与对象1. 类与对象的关系2. 类的定义3. 类的创建及使用package com.java.chap07.sec01; /** * @author Yan * @date 2019/7/18 13:39 * Person类 */ public class Person { String name; //在类中，定义一个姓名name字符串属性 int age; //在类中，定义一个年龄age属性 public void speak(){ System.out.println(&quot;我叫&quot;+name+&quot;我今年&quot;+age+&quot;岁了&quot;); } public static void main(String[] args) { //定义一个Person类的对象zhangsan Person zhangsan; //实例化对象 zhangsan=new Person(); //给对象的name属性赋值 zhangsan.name=&quot;张三&quot;; zhangsan.age=23; zhangsan.speak(); } } 内存分析 3. 方法1. 方法的定义及简单使用package com.java.chap07.sec02; /** * @author Yan * @date 2019/7/18 13:54 */ public class People { /** * 最简单的一个方法定义 */ void speak(){ System.out.println(&quot;我叫张三&quot;); } public static void main(String[] args) { People zhangsan=new People(); zhangsan.speak(); } } package com.java.chap07.sec02; /** * @author Yan * @date 2019/7/18 13:57 */ public class People2 { //形参，入参 void speak(String name){ System.out.println(&quot;我叫&quot;+name); } public static void main(String[] args) { People2 zhangsan=new People2(); zhangsan.speak(&quot;张三&quot;); } } package com.java.chap07.sec02; /** * @author Yan * @date 2019/7/18 13:57 */ public class People3 { //形参，入参 void speak(String name, int age) { System.out.println(&quot;我叫&quot; + name+&quot;我今年&quot;+age+&quot;岁了&quot;); } public static void main(String[] args) { People3 zhangsan = new People3(); zhangsan.speak(&quot;张三&quot;, 23); } } package com.java.chap07.sec02; /** * @author Yan * @date 2019/7/18 13:57 */ public class People4 { //形参，入参,不固定参数 void speak(String name, int age,String ...hobbies) { System.out.println(&quot;我叫&quot; + name + &quot;我今年&quot; + age + &quot;岁了&quot;); System.out.println(&quot;我的爱好： &quot;); for (String hobby:hobbies){ System.out.print(hobby+&quot; &quot;); } } public static void main(String[] args) { People4 zhangsan = new People4(); zhangsan.speak(&quot;张三&quot;, 23,&quot;游泳&quot;,&quot;唱歌&quot;); } } package com.java.chap07.sec02; /** * @author Yan * @date 2019/7/18 13:57 */ public class People5 { //返回类型 int speak(String name, int age,String ...hobbies) { System.out.println(&quot;我叫&quot; + name + &quot;我今年&quot; + age + &quot;岁了&quot;); System.out.println(&quot;我的爱好： &quot;); for (String hobby:hobbies){ System.out.print(hobby+&quot; &quot;); } //获取爱好的长度 int totalHobbies=hobbies.length; return totalHobbies; } public static void main(String[] args) { People5 zhangsan = new People5(); int n=zhangsan.speak(&quot;张三&quot;, 23,&quot;游泳&quot;,&quot;唱歌&quot;); System.out.println(&quot;\\n有&quot;+n+&quot;个爱好&quot;); } } 2. 方法的值传递和引用传递(重点)package com.java.chap07.sec02; /** * 三围类 * @author Yan * @date 2019/7/18 14:08 */ class Sanwei{ int b; //胸围 int w; //腰围 int h; //臀围 } public class People6 { /** * 报三围 * @param age 年龄 * @param sanwei 三围 */ void speak(int age,Sanwei sanwei){ System.out.println(&quot;我今年&quot;+age+&quot;岁了,我的三围是&quot;+sanwei.b+&quot;,&quot;+sanwei.w+&quot;,&quot;+sanwei.h); age=24; sanwei.b=80; } public static void main(String[] args) { People6 xiaoli=new People6(); int age=23; Sanwei sanwei=new Sanwei(); sanwei.b=90; sanwei.w=60; sanwei.h=90; //age传递的是值，sanwei传递的是引用（地址）,c里叫指针 xiaoli.speak(age,sanwei); System.out.println(age); System.out.println(sanwei.b); } } 3. 方法的重载方法重载定义：方法名称相同，但是参数的类型或者参数的个数不同。 package com.java.chap07.sec03; /** * @author Yan * @date 2019/7/18 14:22 */ public class Demo { int add(int a,int b){ System.out.print(&quot;方法一:&quot;); return a+b; } /** * 方法的重载，参数个数不一样 * @param a * @param b * @param c * @return */ int add(int a,int b,int c){ System.out.print(&quot;方法二：&quot;); return a+b+c; } /** * 方法的重载，参数的类型不一样 * @param a * @param b * @return */ int add(int a,String b){ System.out.print(&quot;方法三：&quot;); return a+Integer.parseInt(b); } public static void main(String[] args) { Demo demo=new Demo(); System.out.println(demo.add(1,2)); System.out.println(demo.add(1,2,3)); System.out.println(demo.add(1,&quot;3&quot;)); } } 4. static静态方法与普通方法static方法：方法属于类本身；调用方式：1. 类名.方法;2. 对象.方法 普通方法：方法属于类的对象；调用方式：1. 对象.方法 package com.java.chap07.sec03; /** * @author Yan * @date 2019/7/18 15:33 */ public class Demo2 { void fun1(){ System.out.println(&quot;这是一个普通方法&quot;); } static void fun2(){ System.out.println(&quot;这是一个静态方法&quot;); } public static void main(String[] args) { Demo2 demo2=new Demo2(); //调用普通方法，对象.方法 demo2.fun1(); //调用静态方法，类名.方法名 Demo2.fun2(); //调用静态方法，对象.方法 demo2.fun2(); } } 5. 递归方法求阶乘 1 2 3… (n-1) n原理： N=5 F(n-1) * 5 N=4 F(n-1) * 4 N=3 F(n-1) * 3 N=2 F(n-1) * 2 N=1 1 package com.java.chap07.sec03; /** * @author Yan * @date 2019/7/18 15:38 */ public class Demo3 { /** * 非递归 * @param n * @return */ static long notDiGui(int n){ long result=1; for (int i=1;i&lt;=n;i++){ result=result*i; } return result; } /** * 递归 * @param n * @return */ static long DiGUi(int n){ if (n==1){ return 1; } return DiGUi(n-1)*n; } public static void main(String[] args) { System.out.println(&quot;非递归：&quot;+Demo3.notDiGui(5)); System.out.println(&quot;递归:&quot;+Demo3.DiGUi(5)); } } 4. 构造方法，this关键字1. 构造方法构造器是一个特殊的方法，这个特殊方法用于创建实例时可执行初始化；假如没有构造方法，系统会自动生成一个默认的无参构造方法；假如有构造方法，系统不会自动生成构造方法； package com.java.chap07.sec04; /** * @author Yan * @date 2019/7/18 15:56 */ public class People { // String 类属性默认值是null private String name; //int 类属性默认值是0 private int age; /** * 默认构造方法 */ People(){ System.out.println(&quot;默认构造方法&quot;); } /** * 有参数的构造方法 构造方法的重载 */ People(String name2,int age2){ name=name2; age=age2; System.out.println(&quot;有参数的构造方法&quot;); } public void say(){ System.out.println(&quot;我叫：&quot;+name+&quot;，我今年：&quot;+age+&quot;岁了&quot;); } public static void main(String[] args) { //People people=new People(); People people2=new People(&quot;张三&quot;,23); people2.say(); } } 2. this关键字this表示当前对象 使用this调用本类中的属性； 使用this调用构造方法； package com.java.chap07.sec04; /** * @author Yan * @date 2019/7/18 15:56 */ public class People2 { // String 类属性默认值是null private String name; //int 类属性默认值是0 private int age; /** * 默认构造方法 */ People2(){ System.out.println(&quot;默认构造方法&quot;); } /** * 有参数的构造方法 构造方法的重载 */ People2(String name2, int age2){ this(); this.name=name2; this.age=age2; System.out.println(&quot;有参数的构造方法&quot;); } public void say(){ System.out.println(&quot;我叫：&quot;+name+&quot;，我今年：&quot;+age+&quot;岁了&quot;); } public static void main(String[] args) { //People people=new People(); People2 people2=new People2(&quot;张三&quot;,23); people2.say(); } } 5. 访问控制权限及package import关键字1. 访问控制权限private(私有) get,set方法package（包访问权限）protected(子类访问权限)public（公共访问权限） private package protected public 同一个类中 √ √ √ √ 同一个包中 √ √ √ 子类中 √ √ 全局范围 √ Demo1.java package com.java.chap07.sec05; /** * @author Yan * @date 2019/7/18 16:16 */ public class Demo1 { /** * 定义一个私有的属性a */ private int a; public int getA() { return a; } public void setA(int a) { this.a = a; } } TestDemo1.java package com.java.chap07.sec05; /** * @author Yan * @date 2019/7/18 16:17 */ public class TestDemo1 { public static void main(String[] args) { Demo1 demo1=new Demo1(); demo1.setA(2); int a=demo1.getA(); System.out.println(a); } } 2. package import 关键字package 包定义import 导入相关类 package com.java.chap07.sec05; import com.java.chap07.sec02.People; /** * @author Yan * @date 2019/7/18 16:19 */ public class Demo2 { public static void main(String[] args) { //不同包，则需要导入相关类 People people=new People(); //在同一个包中，则不需要导入相关类 Demo1 demo1=new Demo1(); } } 6. 内部类内部类定义：在类的内部定义类；内部类优点：可以方便的使用外部类的属性；内部类缺点：破环类的基本结构； Demo1.java package com.java.chap07.sec06; /** * @author Yan * @date 2019/7/18 16:38 */ public class Outer { private int a=1; /** * 定义内部类 */ class Inner{ public void show(){ System.out.println(a); } } public void show(){ Inner inner=new Inner(); inner.show(); } public static void main(String[] args) { Outer outer=new Outer(); outer.show(); } } Demo2.java package com.java.chap07.sec06; /** * @author Yan * @date 2019/7/18 16:38 */ public class Outer2 { private int a = 1; /** * 定义内部类 */ class Inner { public void show() { System.out.println(a); } } public static void main(String[] args) { Outer2 outer2 = new Outer2(); //实例化外部类对象 Outer2.Inner inner = outer2.new Inner(); //实例化内部类对象 inner.show(); } } 7. 代码块 普通代码块 package com.java.chap07.sec07; /** * @author Yan * @date 2019/7/18 16:49 */ public class Demo1 { public static void main(String[] args) { int a=1; /** * 普通代码块 */ { a=2; System.out.println(&quot;普通代码块&quot;); } System.out.println(&quot;a=&quot;+a); } } 构造块 package com.java.chap07.sec07; /** * @author Yan * @date 2019/7/18 16:52 */ public class Demo2 { /** * 构造块 * @param args */ { System.out.println(&quot;通用构造块&quot;); } /** * 构造方法一 */ public Demo2(){ System.out.println(&quot;构造方法一&quot;); } /** * 构造方法二 */ public Demo2(int i){ System.out.println(&quot;构造方法二&quot;); } /** * 构造方法三 */ public Demo2(int i,int j){ System.out.println(&quot;构造方法三&quot;); } public static void main(String[] args) { new Demo2(); //实例化一个对象 匿名类 new Demo2(1); new Demo2(1,2); } } 静态代码块 package com.java.chap07.sec07; /** * @author Yan * @date 2019/7/18 16:55 */ public class Demo3 { /** * 构造块 */ { System.out.println(&quot;通用构造块&quot;); } /** * 静态代码块 */ static { System.out.println(&quot;静态代码块&quot;); } /** * 构造方法一 */ public Demo3(){ System.out.println(&quot;构造方法一&quot;); } /** * 构造方法二 */ public Demo3(int i){ System.out.println(&quot;构造方法二&quot;); } /** * 构造方法三 */ public Demo3(int i,int j){ System.out.println(&quot;构造方法三&quot;); } public static void main(String[] args) { new Demo3(); new Demo3(1); new Demo3(1,2); } } 8. String 类1. 实例化String对象方法一： String name1=&quot;张三&quot;; 方法二： String name2=new String(&quot;李四&quot;); package com.java.chap07.sec08; /** * @author Yan * @date 2019/7/18 21:32 */ public class Demo1 { public static void main(String[] args) { //实例化String的方式一 String name1=&quot;张三&quot;; System.out.println(&quot;name1:&quot;+name1); //实例化String的方式二 String name2=new String(&quot;李四&quot;); System.out.println(&quot;name2:&quot;+name2); } } 2. “==” VS “equals方法” “==”，比较的是引用，“equals方法”比较的是具体内容 package com.java.chap07.sec08; /** * @author Yan * @date 2019/7/18 21:39 */ public class Demo2 { public static void main(String[] args) { String name1=&quot;张三&quot;; //直接赋值方式 String name2=new String(&quot;张三&quot;); //new 的方式 String name3=name2; // 传递引用 //==比较的是引用 System.out.println(&quot;name1==name2:&quot;+(name1==name2)); System.out.println(&quot;name1==name3:&quot;+(name1==name3)); System.out.println(&quot;name2==name3:&quot;+(name2==name3)); System.out.println(&quot;-------------&quot;); //equals比较的是内容 System.out.println(&quot;name1.equals(name2):&quot;+(name1.equals(name2))); System.out.println(&quot;name1.equals(name3):&quot;+(name1.equals(name3))); System.out.println(&quot;name2.equals(name3):&quot;+(name2.equals(name3))); } } 3. String 两种实例化方式的区别 直接赋值方式，创建的对象存放到字符串对象池里，假如存在的，就不会创建； new对象方式，每次都创建一个新的对象； package com.java.chap07.sec08; /** * @author Yan * @date 2019/7/18 21:46 */ public class Demo3 { public static void main(String[] args) { String name1=&quot;张三&quot;; String name2=&quot;张三&quot;; String name3=new String(&quot;张三&quot;); String name4=new String(&quot;张三&quot;); System.out.println(&quot;name1==name2:&quot;+(name1==name2)); System.out.println(&quot;name1==name3:&quot;+(name1==name3)); System.out.println(&quot;name3==name4:&quot;+(name3==name4)); } } 4. 字符串的内容不可变性字符串的特性：不能改变字符串的内容；只能通过指向一个新的内存地址； package com.java.chap07.sec08; /** * @author Yan * @date 2019/7/18 21:51 */ public class Demo4 { public static void main(String[] args) { String name=&quot;张&quot;; name+=&quot;三&quot;; System.out.println(name); } } 5. String类常用方法及基本使用 char charAt(int index)返回指定索引处的char值。`javapackage com.java.chap07.sec08; /** @author Yan @date 2019/7/18 22:00*/public class Demo5 { public static void main(String[] args) { String name=&quot;张三&quot;; char ming=name.charAt(1); System.out.println(ming); String srt=&quot;我是中国人&quot;; //遍历字符串 for (int i=0;i&lt;srt.length();i++){ System.out.println(srt.charAt(i)); } }} 2. int length()返回此字符串的长度。 3. int indexOf() 返回指定字符在此字符中第一次出现处的索引。 ```java package com.java.chap07.sec08; /** * @author Yan * @date 2019/7/18 22:03 */ public class Demo6 { public static void main(String[] args) { //indexOf方法使用示例 String str=&quot;abcdefghdijklmnopqrstuvwxyz&quot;; System.out.println(&quot;d在字符串str中第一次出现的索引位置：&quot;+str.indexOf(&quot;d&quot;)); System.out.println(&quot;d在字符串str中第一次出现的索引位置,从索引4开始：&quot;+str.indexOf(&quot;d&quot;,4)); } } String substring(int beginIndex)返回一个新的字符串，它是此字符串的一个子字符串。该子字符串从指定索引处的字符开始，直到此字符串末尾。 package com.java.chap07.sec08; /** * @author Yan * @date 2019/7/18 22:08 */ public class Demo7 { public static void main(String[] args) { //subString方法使用 String str=&quot;不开心每一天,不可能&quot;; String newStr=str.substring(1); String newStr2=str.substring(1,6); System.out.println(str); System.out.println(newStr); System.out.println(newStr2); } } String toUpperCase() 使用默认语言环境的规则将此String中的所有字符都转换为大写。 package com.java.chap07.sec08; /** * @author Yan * @date 2019/7/18 22:12 */ public class Demo8 { public static void main(String[] args) { String str=&quot;I&#39;m a boy!&quot;; String upStr=str.toUpperCase(); //转换成大写 System.out.println(&quot;str:&quot;+str); System.out.println(&quot;upStr:&quot;+upStr); String lowerStr=upStr.toLowerCase(); //转换成小写 System.out.println(&quot;lowerStr:&quot;+lowerStr); } } 综合实例编程输入一个字符串，要求去掉前后的空格，然后分别统计其中英文字母，空格，数字和其他字符的个数。 package com.java.chap07.sec08; /** * @author Yan * @date 2019/7/18 22:18 */ public class Demo9 { public static void main(String[] args) { String str=&quot; aB23 2&amp;* &amp;* s2 &quot;; //去掉前面和后面的空白 String newStr=str.trim(); System.out.println(&quot;str:&quot;+str); System.out.println(&quot;newStr:&quot;+newStr); int yingWen=0; int kongGe=0; int shuZi=0; int qiTa=0; for (int i=0;i&lt;newStr.length();i++){ char c=newStr.charAt(i); if (c&gt;=&#39;a&#39;&amp;&amp;c&lt;=&#39;z&#39;||(c&gt;=&#39;A&#39;&amp;&amp;c&lt;=&#39;Z&#39;)){ //判断英文字符 yingWen++; System.out.println(&quot;英文字符：&quot;+c); }else if (c&gt;=&#39;0&#39;&amp;&amp;c&lt;=&#39;9&#39;){ //判断数字 shuZi++; System.out.println(&quot;数字：&quot;+c); }else if (c==&#39; &#39;){ //判断空格 kongGe++; System.out.println(&quot;空格：&quot;+c); }else { //判断其他 qiTa++; System.out.println(&quot;其他：&quot;+c); } } System.out.println(); System.out.println(&quot;英文总数：&quot;+yingWen); System.out.println(&quot;数字总数：&quot;+shuZi); System.out.println(&quot;空格总数：&quot;+kongGe); System.out.println(&quot;其他总数：&quot;+qiTa); } } 9. Java类的继承 继承定义以及基本使用定义：子类能够继承父类的属性和方法；注意点：Java中只支持单继承；私有方法不能继承。 Animal.java package com.java.chap07.sec09; /** * 动物类 * * @author Yan * @date 2019/7/19 15:32 */ public class Animal { //属性姓名 private String name; //属性年龄 private int age; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } //方法say public void say() { System.out.println(&quot;我是一个动物，我叫：&quot; + this.getName() + &quot;我的年龄是：&quot; + this.getAge()); } } Dog.java package com.java.chap07.sec09; /** * * 定义Dog类，继承自Animal类 * @author Yan * @date 2019/7/19 17:25 */ public class Dog extends Animal{ public static void main(String[] args) { Dog dog=new Dog(); dog.setName(&quot;Pick&quot;); dog.setAge(1); dog.say(); } } 方法重写 Animal.java package com.java.chap07.sec09; /** * 动物类 * * @author Yan * @date 2019/7/19 15:32 */ public class Animal { //属性姓名 private String name; //属性年龄 private int age; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } //方法say public void say() { System.out.println(&quot;我是一个动物，我叫：&quot; + this.getName() + &quot;我的年龄是：&quot; + this.getAge()); } } Cat.java package com.java.chap07.sec09; /** * @author Yan * @date 2019/7/19 17:32 */ public class Cat extends Animal { /** * 重写父类的say方法 */ //方法say public void say() { System.out.println(&quot;我是一只猫，我叫：&quot; + this.getName() + &quot;我的年龄是：&quot; + this.getAge()); } public static void main(String[] args) { Cat cat=new Cat(); cat.setName(&quot;Mini&quot;); cat.setAge(2); cat.say(); } } 对象实例化过程以及super关键字 Animal.java package com.java.chap07.sec09; /** * 动物类 * * @author Yan * @date 2019/7/19 15:32 */ public class Animal { //属性姓名 private String name; //属性年龄 private int age; /** * 无参构造方法 */ public Animal(){ System.out.println(&quot;无参构造方法&quot;); } /** * 有参父类构造方法 * @param name 名字 * @param age 年龄 */ public Animal(String name,int age){ System.out.println(&quot;有参父类构造方法&quot;); this.name=name; this.age=age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } //方法say public void say() { System.out.println(&quot;我是一个动物，我叫：&quot; + this.getName() + &quot;我的年龄是：&quot; + this.getAge()); } } Cat.java package com.java.chap07.sec09; /** * @author Yan * @date 2019/7/19 17:32 */ public class Cat extends Animal { private String address; public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } public Cat() { super(); System.out.println(&quot;子类无参构造方法&quot;); } public Cat(String name, int age,String address) { super(name, age); this.address=address; System.out.println(&quot;子类有参构造方法&quot;); } /** * 重写父类的say方法 */ //方法say public void say() { //调用父类的say方法 super.say(); System.out.println(&quot;我是一只猫，我叫：&quot; + this.getName() + &quot;我的年龄是：&quot; + this.getAge()+&quot;我来自：&quot;+this.address); } public static void main(String[] args) { Cat cat=new Cat(&quot;Mini&quot;,1,&quot;火星&quot;); //cat.setName(&quot;Mini&quot;); //cat.setAge(2); cat.say(); } } 10. final关键字 使用final声明的类不能被继承使用final声明的方法不能被子类覆盖使用final声明的变量不能被修改，即为常量 final 修饰类 代码示例：JiangShi.java package com.java.chap07.sec10; /** * @author Yan * @date 2019/7/19 21:04 */ public final class JiangShi { } test.java package com.java.chap07.sec10; /** * @author Yan * @date 2019/7/19 21:05 */ public class Test extends JiangShi{ } final 修饰方法 People.java package com.java.chap07.sec10; /** * @author Yan * @date 2019/7/19 21:55 */ public class People { public final void action(){ System.out.println(&quot;做一个良好公民！&quot;); } } Test.java package com.java.chap07.sec10; /** * @author Yan * @date 2019/7/19 21:05 */ public class Test extends People{ public void action(){ System.out.println(&quot;做一个坏蛋&quot;); } } final 修饰的变量 People.java package com.java.chap07.sec10; /** * @author Yan * @date 2019/7/19 21:55 */ public class People { private final int a=1; public void action(){ a=2; System.out.println(&quot;做一个良好公民！&quot;); } } Common.java package com.java.chap07.sec10; /** * @author Yan * @date 2019/7/19 22:25 */ public class Common { /** * 静态常量 */ public static final String SOMETILE=&quot;中国的首都是北京&quot;; } Test.java package com.java.chap07.sec10; /** * @author Yan * @date 2019/7/19 21:05 */ public class Test extends People{ public void action(){ System.out.println(&quot;做一个坏蛋&quot;); } public static void main(String[] args) { System.out.println(Common.SOMETILE); } } 11. 抽象类定义：在Java中，含有抽象方法的类称为抽象类，同样不能生成对象。注意点： 包含一个抽象方法的类是抽象类 抽象类和抽象方法都要用abstract 关键字声明 抽象方法只需要声明而不需要实现 抽象类必须被子类（假如不是抽象类）必须重写抽象类中的全部抽象方法 抽象类不能被实例化 People.java package com.java.chap07.sec11; /** * 定义一个抽象类People * @author Yan * @date 2019/7/20 15:25 */ public abstract class People { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } public void say(){ System.out.println(&quot;我的姓名是：&quot;+this.getName()); } /** * * 定义一个抽象方法职业 */ public abstract void profession(); } Student.java package com.java.chap07.sec11; /** * @author Yan * @date 2019/7/20 15:29 */ public class Student extends People{ @Override public void profession() { System.out.println(&quot;职业是：学生&quot;); } } Teacher.java package com.java.chap07.sec11; /** * @author Yan * @date 2019/7/20 15:30 */ public class Teacher extends People{ @Override public void profession() { System.out.println(&quot;职业是：老师&quot;); } } Test.java package com.java.chap07.sec11; /** * @author Yan * @date 2019/7/20 15:28 */ public class Test { public static void main(String[] args) { //抽象类不能被实例化 //People p=new People(); Student student=new Student(); student.profession(); Teacher teacher=new Teacher(); teacher.profession(); } } 12. 接口定义：一种特殊的“抽象类”，没有普通方法，有全局常量和公共的抽象方法所组成。 接口的定义 A.java package com.java.chap07.sec12; /** * 定义一个接口A * @author Yan * @date 2019/7/20 15:40 */ public interface A { /** * 全局常量 */ public static final String TITLE=&quot;www.baidu.com&quot;; /** * 定义一个抽象方法 abstract可以省略 */ public void a(); } 实现接口可以实现一个或者多个接口 实现一个接口A.java package com.java.chap07.sec12; /** * 定义一个接口A * @author Yan * @date 2019/7/20 15:40 */ public interface A { /** * 全局常量 */ public static final String TITLE=&quot;www.baidu.com&quot;; /** * 定义一个抽象方法 abstract可以省略 */ public void a(); } Test.java package com.java.chap07.sec12; /** * @author Yan * @date 2019/7/20 16:04 */ public class Test implements A{ @Override public void a() { System.out.println(&quot;a方法&quot;); } public static void main(String[] args) { Test test=new Test(); test.a(); System.out.println(Test.TITLE); } } 实现多个接口 A.java package com.java.chap07.sec12; /** * 定义一个接口A * @author Yan * @date 2019/7/20 15:40 */ public interface A { /** * 全局常量 */ public static final String TITLEA=&quot;www.baidu.com&quot;; /** * 定义一个抽象方法 abstract可以省略 */ public void a(); } B.java package com.java.chap07.sec12; /** * 定义一个接口A * @author Yan * @date 2019/7/20 15:40 */ public interface B { /** * 全局常量 */ public static final String TITLEB=&quot;www.google.com&quot;; /** * 定义一个抽象方法 abstract可以省略 */ public void b(); } Test.java package com.java.chap07.sec12; /** * @author Yan * @date 2019/7/20 16:04 */ public class Test implements A, B { @Override public void a() { System.out.println(&quot;a方法&quot;); } @Override public void b() { System.out.println(&quot;b方法&quot;); } public static void main(String[] args) { Test test = new Test(); test.a(); test.b(); System.out.println(Test.TITLEA); System.out.println(Test.TITLEB); } } 继承类和实现接口先继承，后实现接口 C.java package com.java.chap07.sec12; /** * @author Yan * @date 2019/7/20 16:12 */ public class C { public void c(){ System.out.println(&quot;c方法&quot;); } } Test.java package com.java.chap07.sec12; /** * @author Yan * @date 2019/7/20 16:04 */ public class Test extends C implements A, B { @Override public void a() { System.out.println(&quot;a方法&quot;); } @Override public void b() { System.out.println(&quot;b方法&quot;); } public static void main(String[] args) { Test test = new Test(); test.a(); test.b(); test.c(); System.out.println(Test.TITLEA); System.out.println(Test.TITLEB); } } 接口的继承接口可以多继承 D.java package com.java.chap07.sec12; /** * 定义接口D,继承A，B接口 * @author Yan * @date 2019/7/20 16:15 */ public interface D extends A,B{ /** * 定义一个抽象方法 abstract可以省略 */ public void d(); } Test2.java package com.java.chap07.sec12; /** * @author Yan * @date 2019/7/20 16:04 */ public class Test2 extends C implements D { @Override public void a() { System.out.println(&quot;a方法&quot;); } @Override public void b() { System.out.println(&quot;b方法&quot;); } @Override public void d() { System.out.println(&quot;d方法&quot;); } public static void main(String[] args) { Test2 test = new Test2(); test.a(); test.b(); test.c(); test.d(); System.out.println(Test2.TITLEA); System.out.println(Test2.TITLEB); } } 13. 对象多态性Java中多态性体现： 方法的重载和重写； 可以用父类的引用指向子类的具体实现，而且可以随时更换为其他子类的具体实现； Animal.java package com.java.chap07.sec13; /** * @author Yan * @date 2019/7/20 16:23 */ public class Animal { public void say(){ System.out.println(&quot;我是一个动物&quot;); } } Cat.java package com.java.chap07.sec13; /** * @author Yan * @date 2019/7/20 16:24 */ public class Cat extends Animal{ public void say(){ System.out.println(&quot;我是一个猫&quot;); } } Dog.java package com.java.chap07.sec13; /** * @author Yan * @date 2019/7/20 16:24 */ public class Dog extends Animal{ public void say(){ System.out.println(&quot;我是一个狗&quot;); } } Test.java package com.java.chap07.sec13; /** * @author Yan * @date 2019/7/20 16:25 */ public class Test { public static void main(String[] args) { /* Dog dog=new Dog(); dog.say(); Cat cat=new Cat(); cat.say(); */ //父类引用指向Dog类的具体实现 Animal animal = new Dog(); animal.say(); animal=new Cat(); animal.say(); } } 对象的转型：向上转型：子类对象-&gt;父类对象 安全向下转型：父类对象-&gt;子类对象 不安全 向下转型 package com.java.chap07.sec13; /** * @author Yan * @date 2019/7/20 16:25 */ public class Test { public static void main(String[] args) { /* Dog dog=new Dog(); dog.say(); Cat cat=new Cat(); cat.say(); */ //父类引用指向Dog类的具体实现 Animal animal = new Dog(); animal.say(); //向下转型 Dog dog= (Dog) animal; dog.say(); //向下转型2 不安全 Cat cat= (Cat) animal; cat.say(); /*animal=new Cat(); animal.say(); */ } } 接口方式 Animal.java package com.java.chap07.sec13; /** * @author Yan * @date 2019/7/20 16:23 */ public interface Animal2 { public void say2(); } Dog2.java package com.java.chap07.sec13; /** * @author Yan * @date 2019/7/20 16:34 */ public class Dog2 implements Animal2{ @Override public void say2() { System.out.println(&quot;我是一只狗&quot;); } } Cat2.java package com.java.chap07.sec13; /** * @author Yan * @date 2019/7/20 16:24 */ public class Cat2 implements Animal2 { public void say2() { System.out.println(&quot;我是一个猫&quot;); } } Test2.java package com.java.chap07.sec13; /** * @author Yan * @date 2019/7/20 16:25 */ public class Test2 { public static void main(String[] args) { //父类引用指向Dog类的具体实现 向上转型 Animal2 animal2 = new Dog2(); animal2.say2(); animal2=new Cat2(); animal2.say2(); //向下转型 Dog2 dog2= (Dog2) animal2; dog2.say2(); //向下转型2 不安全 Cat2 cat2= (Cat2) animal2; cat2.say2(); } } 14. Object类 Object类是所有类的父类； package com.java.chap07.sec14; /** * @author Yan * @date 2019/7/20 21:02 */ public class A extends Object{ /** * Object 类是所有类的父类 */ public A(){ super(); } } 1. Object类的常用方法 public String toString(); //返回该对象的字符串表示 代码示例： package com.java.chap07.sec14; /** * @author Yan * @date 2019/7/20 21:04 */ public class People { private String name; public People(String name) { this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return this.getName(); } public static void main(String[] args) { People people=new People(&quot;张三&quot;); System.out.println(people); System.out.println(people.toString()); } } public boolean equals(Object obj); //指示其他某个对象是否与此对象“相等” 代码示例： package com.java.chap07.sec14; /** * @author Yan * @date 2019/7/20 21:04 */ public class People { private String name; public People(String name) { this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return this.getName(); } @Override public boolean equals(Object obj) { String name=((People)obj).getName(); System.out.println(name); return this.name==name; } public static void main(String[] args) { People people=new People(&quot;张三&quot;); People people1=new People(&quot;张三&quot;); People people3=new People(&quot;李四&quot;); System.out.println(&quot;people.equals(people1)&quot;+people.equals(people1)); System.out.println(&quot;people1.equals(people3)&quot;+people1.equals(people3)); System.out.println(people); System.out.println(people.toString()); } } 15. instanceof关键字作用：判断一个对象是否属于一个类格式： 对象 instanceof类 返回布尔类型向下转型作判断； 代码示例： Animal.java package com.java.chap07.sec15; /** * @author Yan * @date 2019/7/20 21:17 */ public class Animal { public void say(){ System.out.println(&quot;我是一个动物&quot;); } } Cat.java package com.java.chap07.sec15; /** * @author Yan * @date 2019/7/20 21:17 */ public class Cat extends Animal { public void say(){ System.out.println(&quot;我是一只猫&quot;); } /** * 子类方法 */ public void f2(){ System.out.println(&quot;我喜欢吃鱼&quot;); } } Dog.java package com.java.chap07.sec15; /** * @author Yan * @date 2019/7/20 21:17 */ public class Dog extends Animal { public void say(){ System.out.println(&quot;我是一只狗&quot;); } /** * 子类方法 */ public void f2(){ System.out.println(&quot;我的名字是jack&quot;); } } Test.java package com.java.chap07.sec15; /** * @author Yan * @date 2019/7/20 21:18 */ public class Test { public static void doSomeThing(Animal animal){ animal.say(); if (animal instanceof Dog){ ((Dog)animal).f2(); } if (animal instanceof Cat){ ((Cat)animal).f2(); } } public static void main(String[] args) { Animal dog=new Dog(); System.out.println(&quot;dog对象是否属于Animal类：&quot;+(dog instanceof Animal)); System.out.println(&quot;dog对象是否属于Dog类：&quot;+(dog instanceof Dog)); System.out.println(&quot;dog对象是否属于Cat类：&quot;+(dog instanceof Cat)); doSomeThing(new Dog()); doSomeThing(new Cat()); } } 16. 匿名内部类作用：假如某个类只使用一次，则可以使用匿名内部类。 代码示例： A.java package com.java.chap07.sec16; /** * @author Yan * @date 2019/7/20 21:34 */ public interface A { public void a(); } B.java package com.java.chap07.sec16; /** * @author Yan * @date 2019/7/20 21:35 */ public class B implements A{ @Override public void a() { System.out.println(&quot;只使用一次&quot;); } } Test.java package com.java.chap07.sec16; /** * @author Yan * @date 2019/7/20 21:35 */ public class Test { public void test(A a){ a.a(); } public static void main(String[] args) { Test test=new Test(); test.test(new B()); //匿名内部类 test.test(new A() { @Override public void a() { System.out.println(&quot;匿名内部类，一次性使用&quot;); } }); } } 17. 包装类每个基本类型都有一个对应的类； 序号 基本类型 包装类 1 int Integer 2 char Character 3 short Short 4 long Long 5 float Float 6 double Double 7 boolean Boolean 8 byte Byte 装箱和拆箱 package com.java.chap07.sec17; /** * @author Yan * @date 2019/7/20 22:02 */ public class Demo1 { public static void main(String[] args) { int a=1; Integer i=new Integer(a); //装箱 把基本变量变成对象变量 int b=i.intValue(); //拆箱 把对象变量变成基本变量 System.out.println(&quot;a=&quot;+a+&quot;,i=&quot;+i+&quot;,b=&quot;+b); } } 自动装箱和拆箱 package com.java.chap07.sec17; /** * @author Yan * @date 2019/7/20 22:05 */ public class Demo2 { public static void main(String[] args) { Integer i=1; //自动装箱的过程 自动把基本数据转换成对象 int i2=i; //自动拆箱 自动把对象转换成基本数据 System.out.println(&quot;i=&quot;+i+&quot;,i2=&quot;+i2); } } 包装类的作用 package com.java.chap07.sec17; /** * @author Yan * @date 2019/7/20 22:07 */ public class Demo3 { public static void main(String[] args) { String a=&quot;1&quot;; String b=&quot;2&quot;; int m=Integer.parseInt(a); int n=Integer.parseInt(b); System.out.println(&quot;a+b=&quot;+(m+n)); } } 18. 设计模式 单例模式在Java应用中，单例对象能保证在一个JVM中，该对象只有一个实例存在。 饿汉式 Singleton1.java package com.java.chap07.sec18; /** * @author Yan * @date 2019/7/21 14:05 */ public class Singleton1 { /** * 构造方法私有 */ private Singleton1(){ } /** * 饿汉式单例实现 */ private static final Singleton1 single1=new Singleton1(); /** * 静态工厂方式 */ public static Singleton1 getInstance(){ return single1; } } TestSingleton.java package com.java.chap07.sec18; /** * @author Yan * @date 2019/7/21 14:06 */ public class TestSingleton { public static void main(String[] args) { //Singleton1 singleton1=new Singleton1(); Singleton1 singleton1=Singleton1.getInstance(); Singleton1 singleton2=Singleton1.getInstance(); System.out.println(&quot;饿汉式：&quot;+(singleton1==singleton2)); TestSingleton testSingleton=new TestSingleton(); TestSingleton testSingleton2=new TestSingleton(); System.out.println(testSingleton==testSingleton2); } } 懒汉式 Singleton2.java package com.java.chap07.sec18; /** * @author Yan * @date 2019/7/21 14:05 */ public class Singleton2 { /** * 构造方法私有 */ private Singleton2(){ } /** * 懒汉式单例实现 在第一次调用的时候实例化 */ private static Singleton2 single; /** * 工厂 */ public synchronized static Singleton2 getInstance(){ if (single==null){ //第一次调用的时候实例化 System.out.println(&quot;第一次调用的时候实例化&quot;); single=new Singleton2(); } return single; } } TestSingleton.java package com.java.chap07.sec18; /** * @author Yan * @date 2019/7/21 14:06 */ public class TestSingleton { public static void main(String[] args) { Singleton2 singleton3=Singleton2.getInstance(); Singleton2 singleton4=Singleton2.getInstance(); System.out.println(&quot;懒汉式：&quot;+(singleton3==singleton4)); } } Java异常处理异常的概念代码示例： package com.java.chap08.sec01; /** * @author Yan * @date 2019/7/21 14:30 */ public class ExceptionDemo { public static void main(String[] args) { String str=&quot;123a&quot;; int a=Integer.parseInt(str); System.out.println(a); } } 捕获和处理异常在Java中，我们用try…catch…来捕获异常； try...catch...finally 代码示例： package com.java.chap08.sec02; /** * @author Yan * @date 2019/7/21 14:32 */ public class Demo1 { public static void main(String[] args) { String str=&quot;123a&quot;; try { int a=Integer.parseInt(str); }catch (NumberFormatException e){ e.printStackTrace(); } System.out.println(&quot;aaaa&quot;); } } package com.java.chap08.sec02; /** * @author Yan * @date 2019/7/21 15:59 */ public class Demo2 { public static void testFinally(){ String str=&quot;123a&quot;; try{ int a=Integer.parseInt(str); System.out.println(a); }catch (Exception e){ e.printStackTrace(); System.out.println(&quot;exception&quot;); return; }finally { System.out.println(&quot;final end&quot;); } System.out.println(&quot;end&quot;); } public static void main(String[] args) { testFinally(); } } throws和throw关键字throws表示当前方法不处理异常，而是交给方法的调用处去处理。throw表示直接抛出一个异常 代码示例： throws package com.java.chap08.sec03; /** * @author Yan * @date 2019/7/21 16:03 */ public class Demo1 { /** * 把异常向外抛 * @throws NumberFormatException */ public static void testThrows() throws NumberFormatException { String str = &quot;123a&quot;; int a = Integer.parseInt(str); System.out.println(a); } public static void main(String[] args) { try { testThrows(); }catch (Exception e){ System.out.println(&quot;在这里处理异常&quot;); e.printStackTrace(); } System.out.println(&quot;I&#39;m here&quot;); } } throw package com.java.chap08.sec03; /** * @author Yan * @date 2019/7/21 16:07 */ public class Demo2 { public static void testThrow(int a) throws Exception{ if (a==1){ //直接抛出一个异常类 throw new Exception(&quot;有异常&quot;); } System.out.println(a); } public static void main(String[] args) { try { testThrow(1); } catch (Exception e) { e.printStackTrace(); } try { testThrow(0); } catch (Exception e) { e.printStackTrace(); } } } Exception和RuntimeException区别Exception 是检查型异常，例如Exception在程序中必须使用try…catch进行处理； RuntimeException 是非检查型异常，例如NumberFormatException，可以不使用try…catch进行处理，但是如果产生异常，则异常将由JVM进行处理； RuntimeException 最好也用try…catch捕获。 代码示例： package com.java.chap08.sec04; /** * @author Yan * @date 2019/7/21 16:12 */ public class Demo1 { /** * 运行时异常，编译时不检查，可以不适用try...catch捕获 * @throws RuntimeException */ public static void testRuntimeException() throws RuntimeException { throw new RuntimeException(&quot;运行时异常&quot;); } /** * Exception异常，编译时异常，必须使用try...catch捕获 * @throws Exception */ public static void testException() throws Exception{ throw new Exception(&quot;Exception异常&quot;); } public static void main(String[] args) { try{ testRuntimeException(); }catch (Exception e){ e.printStackTrace(); } try { testException(); } catch (Exception e) { e.printStackTrace(); } } } 自定义异常类代码示例： CustomerException.java package com.java.chap08.sec05; /** * 自定义异常，继承自Exception * @author Yan * @date 2019/7/21 16:18 */ public class CustomerException extends Exception{ public CustomerException(String message){ super(message); } } TestCustomerException.java package com.java.chap08.sec05; /** * @author Yan * @date 2019/7/21 16:19 */ public class TestCustomerException { public static void test() throws CustomerException{ throw new CustomerException(&quot;自定义异常&quot;); } public static void main(String[] args) { try { test(); } catch (CustomerException e) { e.printStackTrace(); } } } Java常用类Java日期处理类 Date类 package com.java.chap09.sec01; import java.util.Date; /** * 日期类Date * @author Yan * @date 2019/7/21 20:56 */ public class TestDate { public static void main(String[] args) { Date date=new Date(); System.out.println(&quot;当前日期：&quot;+date); } } Calendar类 package com.java.chap09.sec01; import java.util.Calendar; /** * @author Yan * @date 2019/7/21 20:58 */ public class TestCalendar { public static void main(String[] args) { Calendar calendar = Calendar.getInstance(); System.out.println(calendar.get(Calendar.YEAR)); System.out.println(calendar.get(Calendar.MONTH) + 1); System.out.println(&quot;现在是&quot; + calendar.get(Calendar.YEAR) + &quot;年&quot; + (calendar.get(Calendar.MONTH) + 1) + &quot;月&quot; + calendar.get(Calendar.DAY_OF_MONTH) + &quot;日&quot; + calendar.get(Calendar.HOUR_OF_DAY) + &quot;时&quot; + calendar.get(Calendar.MINUTE) + &quot;分&quot; + calendar.get(Calendar.SECOND) + &quot;秒&quot;); } } SimpleDateFormat package com.java.chap09.sec01; import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Date; /** * @author Yan * @date 2019/7/21 21:05 */ public class TestSimpleDateFormat { /** * 将日期对象格式为指定格式的日期字符串 * @param date 传入的日期对象 * @param format 格式 * @return */ public static String formatDate(Date date,String format){ String result=&quot;&quot;; SimpleDateFormat sdf=new SimpleDateFormat(format); if (date!=null){ result=sdf.format(date); } return result; } /** * 将日期字符串转换成一个日期对象 * @param dataStr 日期字符串 * @param format 格式 * @return */ public static Date formatDate(String dataStr,String format) throws ParseException { SimpleDateFormat sdf=new SimpleDateFormat(format); return sdf.parse(dataStr); } public static void main(String[] args) throws ParseException { Date date=new Date(); //SimpleDateFormat sdf=new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); //System.out.println(sdf.format(date)); String dataStr=&quot;2010-07-21 21:12:26&quot;; Date date1=formatDate(dataStr,&quot;yyyy-MM-dd HH:mm:ss&quot;); System.out.println(formatDate(date,&quot;yyyy-MM-dd HH:mm:ss&quot;)); System.out.println(formatDate(date1,&quot;yyyy-MM-dd HH:mm:ss&quot;)); } } String VS StringBufferString：对String类型的对象操作，等同于重新生成一个对象，然后将引用指向它； StringBuffer：对StringBuffer类型的对象操作，操作的始终是用一个对象。 String 代码示例： package com.java.chap09.sec02; /** * @author Yan * @date 2019/7/22 14:00 */ public class TestString { public static void main(String[] args) { String str=&quot;123&quot;; str+=&quot;abc&quot;; System.out.println(str); } } StringBuffer 代码示例： package com.java.chap09.sec02; /** * @author Yan * @date 2019/7/22 14:01 */ public class TestStringBuffer { public static void main(String[] args) { StringBuffer sb=new StringBuffer(&quot;123&quot;); sb.append(&quot;abc&quot;); System.out.println(sb); } } Math类 max方法：求最大值 min方法：求最小值 round方法：四舍五入 pow方法：求次幂 代码示例： package com.java.chap09.sec03; /** * @author Yan * @date 2019/7/22 14:10 */ public class TestMath { public static void main(String[] args) { System.out.println(&quot;最大值：&quot;+Math.max(1,2)); System.out.println(&quot;最小值：&quot;+Math.min(1,2)); System.out.println(&quot;四舍五入：&quot;+Math.round(12.4)); System.out.println(&quot;次幂：&quot;+Math.pow(3,4)); } } Arrays类 toString()方法：返回指定数组内容的字符串表示形式 sort()方法：对指定的类型数组按数字升序进行排序 binarySearch()方法：使用二分搜索法来搜索指定类型数组，以获得指定的值 fill()方法：将指定类型值分配给指定类型数组的每个元素 代码示例： package com.java.chap09.sec04; import java.util.Arrays; /** * @author Yan * @date 2019/7/22 14:36 */ public class TestArrays { public static void main(String[] args) { int arr[]={1,7,3,8,2}; System.out.println(&quot;以字符串形式输出数组：&quot;+Arrays.toString(arr)); Arrays.sort(arr); //给数组排序 System.out.println(&quot;排序后的数组&quot;+Arrays.toString(arr)); System.out.println(Arrays.binarySearch(arr,7)); Arrays.fill(arr,0); //将指定内容填充到数组中 System.out.println(&quot;填充数组后的字符串：&quot;+Arrays.toString(arr)); } } Java泛型泛型引入定义：使用泛型可以指代任意对象类型 代码示例： C1.java package com.java.chap10.sec01; /** * @author Yan * @date 2019/7/22 16:00 */ public class C1 { private Integer a; public C1(Integer a) { super(); this.a = a; } public Integer getA() { return a; } public void setA(Integer a) { this.a = a; } /** * 打印a的类型 */ public void print(){ System.out.println(&quot;a的类型是：&quot;+a.getClass().getName()); } } C2.java package com.java.chap10.sec01; /** * @author Yan * @date 2019/7/22 16:02 */ public class C2 { private String a; public C2(String a) { super(); this.a = a; } public String getA() { return a; } public void setA(String a) { this.a = a; } /** * 打印a的类型 */ public void print(){ System.out.println(&quot;a的类型是：&quot;+a.getClass().getName()); } } C12.java package com.java.chap10.sec01; /** * @author Yan * @date 2019/7/22 16:09 */ public class C12 { private Object object; public C12(Object object) { super(); this.object = object; } public Object getObject() { return object; } public void setObject(Object object) { this.object = object; } /** * 打印object的类型 */ public void print(){ System.out.println(&quot;a的类型是：&quot;+object.getClass().getName()); } } CC.java package com.java.chap10.sec01; /** * 定义泛型类 * @author Yan * @date 2019/7/24 15:56 */ public class CC&lt;T&gt; { private T ob; public CC(T ob) { super(); this.ob = ob; } public T getOb() { return ob; } public void setOb(T ob) { this.ob = ob; } /** * 打印T的类型 */ public void print(){ System.out.println(&quot;T的实际类型&quot;+ob.getClass().getName());; } } Test.java package com.java.chap10.sec01; /** * @author Yan * @date 2019/7/22 16:03 */ public class Test1 { public static void main(String[] args) { //begin test c1 C1 c1=new C1(1); c1.print(); int i=c1.getA(); System.out.println(&quot;i=&quot;+i); //end test c1 //begin test c2 C2 c2=new C2(&quot;Hi&quot;); c2.print(); String s1=c2.getA(); System.out.println(&quot;s1=&quot;+s1); //end test c2 //begin test c12 C12 c12=new C12(1); //向上转型 c12.print(); int i12= (Integer) c12.getObject(); //向下转型 System.out.println(&quot;i12=&quot;+i12); C12 c121=new C12(&quot;你好&quot;); //向上转型 c121.print(); String i121=(String) c121.getObject(); //向下转型 System.out.println(&quot;i121=&quot;+i121); //end test c12 //begin test CC CC&lt;Integer&gt; cc=new CC&lt;Integer&gt;(1); cc.print(); int icc=cc.getOb(); System.out.println(&quot;icc=&quot;+icc); //end test CC //begin test CC CC&lt;String&gt; cc1=new CC&lt;String&gt;(&quot;你好&quot;); cc1.print(); String icc1=cc1.getOb(); System.out.println(&quot;icc1=&quot;+icc1); //end test CC } } 限制泛型代码示例： Animal.java package com.java.chap10.sec02; /** * @author Yan * @date 2019/7/24 16:07 */ public class Animal { public void print(){ System.out.println(&quot;动物&quot;); } } Cat.java package com.java.chap10.sec02; /** * @author Yan * @date 2019/7/24 16:07 */ public class Cat extends Animal{ public void print(){ System.out.println(&quot;Cat&quot;); } } Dog.java package com.java.chap10.sec02; /** * @author Yan * @date 2019/7/24 16:07 */ public class Dog extends Animal{ public void print(){ System.out.println(&quot;Dog&quot;); } } Demo.java package com.java.chap10.sec02; /** * @author Yan * @date 2019/7/24 16:08 */ public class Demo &lt;T extends Animal&gt;{ private T ob; public Demo(T ob) { super(); this.ob = ob; } public T getOb() { return ob; } public void setOb(T ob) { this.ob = ob; } public void print(){ System.out.println(&quot;T的类型是： &quot;+ob.getClass().getName()); } } Test.java package com.java.chap10.sec02; /** * @author Yan * @date 2019/7/24 16:11 */ public class Test { public static void main(String[] args) { Demo&lt;Dog&gt; demo=new Demo&lt;Dog&gt;(new Dog()); Dog dog=demo.getOb(); dog.print(); Demo&lt;Cat&gt; demo2=new Demo&lt;Cat&gt;(new Cat()); Cat cat=demo2.getOb(); cat.print(); //Demo&lt;Integer&gt; demo3=new Demo&lt;Integer&gt;(2); Demo&lt;Animal&gt; demo3=new Demo&lt;Animal&gt;(new Animal()); } } 通配符泛型代码示例： Test.java package com.java.chap10.sec03; import com.java.chap10.sec02.Animal; import com.java.chap10.sec02.Cat; import com.java.chap10.sec02.Demo; import com.java.chap10.sec02.Dog; /** * @author Yan * @date 2019/7/24 16:23 */ public class Test { /** * 通配符泛型 * @param animal */ private static void take(Demo&lt;?&gt; animal){ animal.print(); } public static void main(String[] args) { Demo&lt;Dog&gt; dog=new Demo&lt;Dog&gt;(new Dog()); take(dog); Demo&lt;Cat&gt; cat=new Demo&lt;Cat&gt;(new Cat()); take(cat); Demo&lt;Animal&gt; animalDemo=new Demo&lt;Animal&gt;(new Animal()); take(animalDemo); } } 泛型方法代码示例： package com.java.chap10.sec04; /** * @author Yan * @date 2019/7/24 19:39 */ public class Test { /** * 泛型方法 * @param t * @param &lt;T&gt; */ public static &lt;T&gt; void f(T t){ System.out.println(&quot;T的类型是：&quot;+t.getClass().getName()); } public static void main(String[] args) { f(&quot;&quot;); f(1); f(1.0); f(new Object()); } } Java集合Java集合的引入代码示例： Student.java package com.java.chap11.sec01; /** * @author Yan * @date 2019/7/25 14:40 */ public class Student { private String name; private int age; public Student(String name, int age) { super(); this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } } Demo.java package com.java.chap11.sec01; import java.util.LinkedList; /** * @author Yan * @date 2019/7/25 14:41 */ public class Demo { public static void main(String[] args) { Student student[]=new Student[3]; Student student1=new Student(&quot;张三&quot;,1); Student student2=new Student(&quot;李四&quot;,3); Student student3=new Student(&quot;王五&quot;,4); LinkedList&lt;Student&gt; list=new LinkedList&lt;Student&gt;(); list.add(student1); list.add(student2); list.add(student3); /** * 遍历集合 */ for (int i=0;i&lt;list.size();i++){ Student student4=list.get(i); System.out.println(student4.getName()+&quot;:&quot;+student4.getAge()); } } } List集合是Collection接口的子接口，也是最常用的接口。此接口对Collection接口进行了大量的扩展，List集合里的元素是允许重复的。 ArrayList实现类 代码实现： package com.java.chap11.sec02; import java.util.ArrayList; /** * @author Yan * @date 2019/7/25 15:09 */ public class TestArrayList { public static void printArrayList(ArrayList&lt;String&gt; arrayList){ System.out.println(&quot;当前的集合元素&quot;); for (int i=0;i&lt;arrayList.size();i++){ System.out.print(arrayList.get(i)+&quot; &quot;); } System.out.println(); } public static void main(String[] args) { ArrayList&lt;String&gt; arrayList=new ArrayList&lt;String&gt;(); //添加元素 arrayList.add(&quot;张三&quot;); arrayList.add(&quot;李四&quot;); printArrayList(arrayList); //将指定的元素插入此列表中的指定位置 arrayList.add(1,&quot;小张三&quot;); printArrayList(arrayList); //用指定的元素替代此列表指定位置上的元素 arrayList.set(2,&quot;小李四&quot;); printArrayList(arrayList); //移除此列表中指定位上的元素 arrayList.remove(0); printArrayList(arrayList); } } LinkedList实现类 代码示例： package com.java.chap11.sec02; import java.util.LinkedList; /** * @author Yan * @date 2019/7/25 15:36 */ public class TestLinkedList { public static void printLinkedList(LinkedList&lt;String&gt; linkedList){ System.out.println(&quot;当前元素集合：&quot;); for (int i=0;i&lt;linkedList.size();i++){ System.out.print(linkedList.get(i)+&quot; &quot;); } System.out.println(); } public static void main(String[] args) { LinkedList&lt;String&gt; linkedList=new LinkedList&lt;String&gt;(); linkedList.add(&quot;张三&quot;); linkedList.add(&quot;李四&quot;); linkedList.add(&quot;王五&quot;); linkedList.add(&quot;李四&quot;); linkedList.add(&quot;赵六&quot;); printLinkedList(linkedList); //返回此列表中首次出现的指定元素的索引，如果此列表中不包括该元素，则返回-1； System.out.println(linkedList.indexOf(&quot;李四&quot;)); //获取但不移除此列表的第一个元素；如果此列表为空，则返回null System.out.println(linkedList.peekFirst()); printLinkedList(linkedList); //获取但不移除此列表的最后一个元素；如果此列表为空，则返回null System.out.println(linkedList.peekLast()); printLinkedList(linkedList); //获取并移除此列表的第一个元素；如果此列表为空，则返回null System.out.println(linkedList.pollFirst()); printLinkedList(linkedList); //获取并移除此列表的最后一个元素；如果此列表为空，则返回null System.out.println(linkedList.pollLast()); printLinkedList(linkedList); } } 集合的遍历 Iterator 代码示例： package com.java.chap11.sec03; import com.java.chap11.sec01.Student; import java.util.Iterator; import java.util.LinkedList; /** * @author Yan * @date 2019/7/25 15:51 */ public class TestIterator { public static void main(String[] args) { LinkedList&lt;Student&gt; list=new LinkedList&lt;Student&gt;(); list.add(new Student(&quot;张三&quot;,10)); list.add(new Student(&quot;李四&quot;,20)); list.add(new Student(&quot;王五&quot;,30)); /** * 用Iterator遍历集合 */ Iterator&lt;Student&gt; iterator=list.iterator(); //返回一个迭代器 while(iterator.hasNext()){ Student s=iterator.next(); //返回迭代的下一个元素 System.out.println(&quot;姓名：&quot;+s.getName()+&quot; 年龄：&quot;+s.getAge()); } } } foreach 代码示例： package com.java.chap11.sec03; import com.java.chap11.sec01.Student; import java.util.Iterator; import java.util.LinkedList; /** * @author Yan * @date 2019/7/25 15:57 */ public class TestForeach { public static void main(String[] args) { LinkedList&lt;Student&gt; list=new LinkedList&lt;Student&gt;(); list.add(new Student(&quot;张三&quot;,10)); list.add(new Student(&quot;李四&quot;,20)); list.add(new Student(&quot;王五&quot;,30)); /** * 用Foreach遍历集合 */ for (Student s:list){ System.out.println(&quot;姓名：&quot;+s.getName()+&quot; 年龄：&quot;+s.getAge()); } } } Set集合是Collertion接口的子接口，没有对Collection接口进行扩展，里面不允许存重复的内容。 HashSet类 代码示例： package com.java.chap11.sec04; import java.util.HashSet; import java.util.Iterator; /** * @author Yan * @date 2019/7/25 16:02 */ public class TestHashSet { public static void main(String[] args) { /** * 1. HashSet是无序的 * 2. 不允许有重复值 */ HashSet&lt;String&gt; hashSet=new HashSet&lt;String&gt;(); hashSet.add(&quot;1&quot;); hashSet.add(&quot;2&quot;); hashSet.add(&quot;5&quot;); hashSet.add(&quot;4&quot;); hashSet.add(&quot;2&quot;); /** * 用Iterator遍历集合 */ Iterator&lt;String&gt; iterator=hashSet.iterator(); while (iterator.hasNext()){ String s=iterator.next(); System.out.println(s+&quot; &quot;); } } } Map集合是存放一对值的最大接口，即接口中的每一个元素都是一对，以key-&gt;value键值对的形式保存。 HashMap类 代码示例： package com.java.chap11.sec05; import com.java.chap11.sec01.Student; import java.util.HashMap; import java.util.Iterator; /** * @author Yan * @date 2019/7/25 16:08 */ public class TestHashMap { public static void main(String[] args) { HashMap&lt;String, Student&gt; hashMap=new HashMap&lt;String,Student&gt;(); hashMap.put(&quot;1号&quot;,new Student(&quot;张三&quot;,10)); hashMap.put(&quot;2号&quot;,new Student(&quot;李四&quot;,20)); hashMap.put(&quot;3号&quot;,new Student(&quot;王五&quot;,30)); // 通过key获取value Student student=hashMap.get(&quot;1号&quot;); System.out.println(student.getName()+&quot;:&quot;+student.getAge()); Iterator&lt;String&gt; iterator=hashMap.keySet().iterator(); //获取key的集合，再获取迭代器 while (iterator.hasNext()){ String key=iterator.next(); //获取key Student student1=hashMap.get(key); //通过key获取value System.out.println(&quot;key=&quot;+key+&quot;value=[&quot;+student1.getName()+&quot;,&quot;+student1.getAge()+&quot;]&quot;); } } } Java多线程多线程的引入定义：同时对多项任务加以控制 代码示例： Demo.java package com.java.chap12.sec01; /** * @author Yan * @date 2019/7/27 13:15 */ public class Demo1 { /** * 听音乐 */ private static void music(){ for (int i=0;i&lt;1000;i++){ System.out.println(&quot;听音乐&quot;); } } /** * 吃饭 * */ private static void eat(){ for (int i=0;i&lt;1000;i++){ System.out.println(&quot;吃饭&quot;); } } public static void main(String[] args) { //music(); //eat(); /** * 利用多线程实现一边吃饭一边听歌 */ Music musicThread=new Music(); Eat eatThread=new Eat(); musicThread.start(); eatThread.start(); } } Eat.java package com.java.chap12.sec01; /** * @author Yan * @date 2019/7/27 13:18 */ public class Eat extends Thread { @Override public void run() { for (int i=0;i&lt;1000;i++){ try { Thread.sleep(100); System.out.println(&quot;吃饭&quot;); } catch (InterruptedException e) { e.printStackTrace(); } } } } Music.java package com.java.chap12.sec01; /** * @author Yan * @date 2019/7/27 13:19 */ public class Music extends Thread { @Override public void run() { for (int i=0;i&lt;1000;i++){ try { Thread.sleep(100); System.out.println(&quot;听音乐&quot;); } catch (InterruptedException e) { e.printStackTrace(); } } } } Java多线程实现 继承Thread类 代码示例： package com.java.chap12.sec02; /** * @author Yan * @date 2019/7/27 13:24 */ public class Thread1 extends Thread { private int baoZi=1; private String threadName; public Thread1(String threadName) { super(); this.threadName = threadName; } @Override public synchronized void run() { while (baoZi&lt;=10){ System.out.println(threadName+&quot;吃第&quot;+baoZi+&quot;包子&quot;); baoZi++; } } public static void main(String[] args) { System.out.println(&quot;张三，李四一起吃包子，每人吃了10个&quot;); Thread1 t1=new Thread1(&quot;张三线程&quot;); Thread1 t2=new Thread1(&quot;李四线程&quot;); t1.start(); t2.start(); } } 实现Runnable接口 代码示例： package com.java.chap12.sec02; /** * @author Yan * @date 2019/7/27 13:29 */ public class Thread2 implements Runnable { private int baoZi=1; private String threadName; public Thread2(String threadName) { super(); this.threadName = threadName; } @Override public synchronized void run() { while (baoZi&lt;=10){ System.out.println(threadName+&quot;吃第&quot;+baoZi+&quot;包子&quot;); baoZi++; } } public static void main(String[] args) { //System.out.println(&quot;张三，李四一起吃包子，每人吃了10个&quot;); //Thread2 t1=new Thread2(&quot;张三线程&quot;); //Thread2 t2=new Thread2(&quot;李四线程&quot;); //Thread t11=new Thread(t1); //Thread t12=new Thread(t2); //t11.start(); //t12.start(); Thread2 t1=new Thread2(&quot;超级张三线程&quot;); Thread t11=new Thread(t1); Thread t12=new Thread(t1); Thread t13=new Thread(t1); Thread t14=new Thread(t1); //实现资源共享 t11.start(); t12.start(); t13.start(); t14.start(); } } 线程状态 创建状态在程序中用构造方法创建了一个线程对象后，新的线程对象便处于新建状态，此时，它已经有了相应的内存空间和其他资源，但还处于不可运行状态。新建一个线程对象可采用Thread类的构造方法来实现，例如，“Thread thread=new Thread();”。 就绪状态新建线程对象后，调用该线程的start()方法就可以启动线程。当线程启动时，线程进入就绪状态。此时，线程将进入线程队列排队，等待CPU服务，这表明它已经具备了运行条件。 运行状态当就绪状态的线程被调用并获得处理器资源时，线程就进入了运行状态。此时，自动调用该线程对象的run()方法。run()方法定义了该线程的操作和功能。 堵塞状态一个正在运行的线程在某些特殊情况下，如被人为挂起或需要执行耗时的输入/输出操作时，将让出CPU并暂时中止自己的执行，进入堵塞状态，堵塞时，线程不能进入排队队列，只有当引起堵塞的原因被消除后，线程才可以转入就绪状态。 死亡状态线程调用stop()方法时或run()方法执行结束后，即处于死亡状态。处于死亡状态的线程不具有继续运行的能力。 线程常用方法 getName(); 返回该线程的名称。 currentThread(); 返回对当前正在执行的线程对象的引用。 isAlive(); 测试线程是否处于活动状态。 sleep(); 线程休眠。 setPriority(int newPriority); 更改线程的优先级。 yield(); 暂停当前正在执行的线程对象，并执行其他线程。 代码示例： getName()、currentThread() package com.java.chap12.sec04; import javax.swing.plaf.TableHeaderUI; /** * @author Yan * @date 2019/7/27 14:23 */ public class Demo1 implements Runnable{ @Override public void run() { for (int i=0;i&lt;10;i++){ //获取当前线程 Thread t=Thread.currentThread(); System.out.println(t.getName()+&quot;:&quot;+i); //返回线程的名称 } } public static void main(String[] args) { Demo1 demo1=new Demo1(); new Thread(demo1).start(); new Thread(demo1).start(); new Thread(demo1,&quot;线程3&quot;).start(); } } isAlive() package com.java.chap12.sec04; /** * @author Yan * @date 2019/7/27 14:35 */ public class Demo2 implements Runnable{ @Override public void run() { for (int i=0;i&lt;10;i++){ //获取当前线程 Thread t=Thread.currentThread(); System.out.println(t.getName()+&quot;:&quot;+i); //返回线程的名称 } } public static void main(String[] args) { Demo2 demo2=new Demo2(); Thread t1=new Thread(demo2); System.out.println(&quot;t1是否活动：&quot;+t1.isAlive()); t1.start(); System.out.println(&quot;t1是否活动：&quot;+t1.isAlive()); } } sleep() package com.java.chap12.sec04; /** * @author Yan * @date 2019/7/27 14:35 */ public class Demo3 implements Runnable{ @Override public void run() { for (int i=0;i&lt;10;i++){ try { Thread.sleep(1000); //获取当前线程 Thread t=Thread.currentThread(); System.out.println(t.getName()+&quot;:&quot;+i); //返回线程的名称 } catch (InterruptedException e) { e.printStackTrace(); } } } public static void main(String[] args) { Demo3 demo2=new Demo3(); Thread t1=new Thread(demo2); t1.start(); } } setPriority(int newPriority) package com.java.chap12.sec04; /** * @author Yan * @date 2019/7/27 14:35 */ public class Demo4 implements Runnable{ @Override public void run() { for (int i=0;i&lt;10;i++){ try { Thread.sleep(1000); //获取当前线程 Thread t=Thread.currentThread(); System.out.println(t.getName()+&quot;:&quot;+i); //返回线程的名称 } catch (InterruptedException e) { e.printStackTrace(); } } } public static void main(String[] args) { Demo4 demo4=new Demo4(); Thread t1=new Thread(demo4,&quot;线程A&quot;); Thread t2=new Thread(demo4,&quot;线程B&quot;); Thread t3=new Thread(demo4,&quot;线程C&quot;); t1.setPriority(Thread.MAX_PRIORITY); t2.setPriority(Thread.MIN_PRIORITY); t3.setPriority(Thread.NORM_PRIORITY); t1.start(); t2.start(); t3.start(); } } yield() package com.java.chap12.sec04; /** * @author Yan * @date 2019/7/27 14:35 */ public class Demo5 implements Runnable { @Override public void run() { for (int i = 0; i &lt; 10; i++) { try { Thread.sleep(1000); //获取当前线程 Thread t = Thread.currentThread(); System.out.println(t.getName() + &quot;:&quot; + i); //返回线程的名称 if (i==5){ System.out.println(&quot;线程礼让&quot;); Thread.currentThread().yield(); } } catch (InterruptedException e) { e.printStackTrace(); } } } public static void main(String[] args) { Demo5 demo5 = new Demo5(); new Thread(demo5, &quot;线程A&quot;).start(); new Thread(demo5, &quot;线程B&quot;).start(); } } 线程同步 同步方法 同步锁 代码示例： Demo2.java package com.java.chap12.sec05; /** * @author Yan * @date 2019/7/27 14:54 */ public class Demo2 implements Runnable { private int baoZi=10; /** * 同步方法 */ @Override public synchronized void run() { while (baoZi&gt;0){ System.out.println(Thread.currentThread().getName()+&quot;吃了第&quot;+baoZi+&quot;包子&quot;); baoZi--; } } public static void main(String[] args) { Demo2 demo1=new Demo2(); new Thread(demo1,&quot;张三&quot;).start(); new Thread(demo1,&quot;李四&quot;).start(); new Thread(demo1,&quot;王五&quot;).start(); } } Demo3.java package com.java.chap12.sec05; /** * @author Yan * @date 2019/7/27 14:54 */ public class Demo3 implements Runnable { private int baoZi = 10; @Override public void run() { /** * 同步块 */ synchronized (this) { while (baoZi &gt; 0) { System.out.println(Thread.currentThread().getName() + &quot;吃了第&quot; + baoZi + &quot;包子&quot;); baoZi--; } } } public static void main(String[] args) { Demo3 demo1 = new Demo3(); new Thread(demo1, &quot;张三&quot;).start(); new Thread(demo1, &quot;李四&quot;).start(); new Thread(demo1, &quot;王五&quot;).start(); } } Java图形界面Swing框架Swing简介 Swing是Java的一个图形框架，继承自AWT； Swing主要涉及到容器，组件，还有布局管理器； Swing与用户交互的时候还涉及到事件概念 JFrame容器 public void setVisible(boolean b):根据参数b的值显示或隐藏此窗体 public void setSize(int width,int height):调整组件的大小，使其宽度为width，高度为height public void setLocation(int x,.int y):将组件移到新位置。通过此组件父级坐标空间中的x和y参数来指定新位置的左上角 public Container getContentPane():返回此窗体的contentPane对象 public void setBackground(Color c):设置组件的背景色 代码示例： package com.java.chap13.sec02; import javax.swing.*; import java.awt.*; /** * @author Yan * @date 2019/7/27 15:38 */ public class JFrameTest { public static void main(String[] args) { JFrame jFrame=new JFrame(&quot;JFrame窗体&quot;); /*Container c=jFrame.getContentPane(); c.setBackground(Color.blue);*/ jFrame.getContentPane().setBackground(Color.red); //设置容器的背景颜色 jFrame.setLocation(300,200); //设置容器的位置 jFrame.setSize(500,500); //设置容器大小 jFrame.setVisible(true); //让容器显示 } } JButton组件代码示例： package com.java.chap13.sec03; import javax.swing.*; import java.awt.*; /** * @author Yan * @date 2019/7/27 16:18 */ public class JButtonTest { public static void main(String[] args) { JFrame jFrame=new JFrame(&quot;JButton测试&quot;); JButton jButton=new JButton(&quot;这是一个按钮&quot;); jFrame.add(jButton); jFrame.getContentPane().setBackground(Color.red); //设置容器的背景颜色 jFrame.setLocation(300,200); //设置容器的位置 jFrame.setSize(500,500); //设置容器大小 jFrame.setVisible(true); //让容器显示 jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } } Swing布局管理器 FlowLayout流式布局使用此种布局方式会使所有的组件像流水一样依次进行排列 代码示例： package com.java.chap13.sec04; import javax.swing.*; import java.awt.*; /** * FlowLayout流式布局 * @author Yan * @date 2019/7/27 16:26 */ public class FlowLayout { public static void main(String[] args) { JFrame jFrame=new JFrame(&quot;FlowLayout测试&quot;); //jFrame.setLayout(new java.awt.FlowLayout()); //jFrame.setLayout(new java.awt.FlowLayout(java.awt.FlowLayout.LEFT)); jFrame.setLayout(new java.awt.FlowLayout(java.awt.FlowLayout.LEFT,15,15)); JButton jButton=null; for(int i=0;i&lt;9;i++){ jButton=new JButton(&quot;JButton&quot;+i); jFrame.add(jButton); } jFrame.getContentPane().setBackground(Color.red); //设置容器的背景颜色 jFrame.setLocation(300,200); //设置容器的位置 jFrame.setSize(500,500); //设置容器大小 jFrame.setVisible(true); //让容器显示 jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } } BorderLayout使用此种布局方式将一个窗体的版面划分成东、西、南、北、中5个区域，可以直接将需要的组件放到这5个区域中 代码示例： package com.java.chap13.sec04; import javax.swing.*; import java.awt.*; /** * * @author Yan * @date 2019/7/28 15:35 */ public class BorderLayoutTest { public static void main(String[] args) { JFrame jFrame=new JFrame(&quot;BorderLayout测试&quot;); //jFrame.setLayout(new BorderLayout()); jFrame.setLayout(new BorderLayout(5,5)); jFrame.add(new JButton(&quot;东&quot;),BorderLayout.EAST); jFrame.add(new JButton(&quot;西&quot;),BorderLayout.WEST); jFrame.add(new JButton(&quot;南&quot;),BorderLayout.SOUTH); jFrame.add(new JButton(&quot;北&quot;),BorderLayout.NORTH); jFrame.add(new JButton(&quot;中&quot;),BorderLayout.CENTER); jFrame.getContentPane().setBackground(Color.red); //设置容器的背景颜色 jFrame.setLocation(300,200); //设置容器的位置 jFrame.setSize(500,500); //设置容器大小 jFrame.setVisible(true); //让容器显示 jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } } GridLayout表格布局使用此种布局是以表格的形式进行布局管理的，在使用此布局管理器时必须设置显示的行数和列数 代码示例： package com.java.chap13.sec04; import javax.swing.*; import java.awt.*; /** * @author Yan * @date 2019/7/28 15:39 */ public class GridLayoutTest { public static void main(String[] args) { JFrame jFrame=new JFrame(&quot;GridLayout测试&quot;); jFrame.setLayout(new GridLayout(4,5,5,5)); JButton jButton=null; for (int i=0;i&lt;19;i++){ jButton=new JButton(&quot;JButton&quot;+i); jFrame.add(jButton); } jFrame.getContentPane().setBackground(Color.red); //设置容器的背景颜色 jFrame.setLocation(300,200); //设置容器的位置 jFrame.setSize(500,500); //设置容器大小 jFrame.setVisible(true); //让容器显示 jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } } 绝对布局 代码示例： package com.java.chap13.sec04; import javax.swing.*; import java.awt.*; /** * @author Yan * @date 2019/7/28 15:44 */ public class AbsoluteLayoutTest { public static void main(String[] args) { JFrame jFrame=new JFrame(&quot;绝对布局测试&quot;); jFrame.setLayout(null); JButton jButton1=new JButton(&quot;按钮1&quot;); JButton jButton2=new JButton(&quot;按钮2&quot;); jFrame.add(jButton1); jFrame.add(jButton2); jButton1.setBounds(50,10,100,20); jButton2.setBounds(70,40,200,30); jFrame.getContentPane().setBackground(Color.red); //设置容器的背景颜色 jFrame.setLocation(300,200); //设置容器的位置 jFrame.setSize(500,500); //设置容器大小 jFrame.setVisible(true); //让容器显示 jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } } JLable 组件代码示例： package com.java.chap13.sec05; import javax.swing.*; import java.awt.*; /** * @author Yan * @date 2019/7/28 16:02 */ public class JLableTest { public static void main(String[] args) { JFrame jFrame=new JFrame(&quot;JLable测试&quot;); JLabel jLabel=new JLabel(&quot;JLable组件&quot;,JLabel.CENTER); jFrame.add(jLabel); jFrame.getContentPane().setBackground(Color.red); //设置容器的背景颜色 jFrame.setLocation(300,200); //设置容器的位置 jFrame.setSize(500,500); //设置容器大小 jFrame.setVisible(true); //让容器显示 jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } } 文本框组件 JTextField 文本框 代码示例： package com.java.chap13.sec06; import javax.swing.*; import java.awt.*; /** * @author Yan * @date 2019/7/28 16:17 */ public class JTextFiledTest { public static void main(String[] args) { JFrame jFrame=new JFrame(&quot;JTextFiled单行文本框测试&quot;); jFrame.setLayout(new GridLayout(1,2,10,10)); JLabel jLabel=new JLabel(&quot;用户名：&quot;); JTextField jTextField=new JTextField(); jFrame.add(jLabel); jFrame.add(jTextField); jFrame.getContentPane().setBackground(Color.red); //设置容器的背景颜色 jFrame.setLocation(300,200); //设置容器的位置 jFrame.setSize(500,500); //设置容器大小 jFrame.setVisible(true); //让容器显示 jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } } JPasswordField 密码框 代码示例： package com.java.chap13.sec06; import javax.swing.*; import java.awt.*; /** * @author Yan * @date 2019/7/28 16:42 */ public class JPasswordFiledTest { public static void main(String[] args) { JFrame jFrame = new JFrame(&quot;JPasswordFiled密码框测试&quot;); jFrame.setLayout(new GridLayout(2, 2, 10, 10)); JLabel jLabel = new JLabel(&quot;用户名：&quot;); JTextField jTextField = new JTextField(); JLabel jLabe2 = new JLabel(&quot;密码：&quot;); JPasswordField jPasswordField=new JPasswordField(); jFrame.add(jLabel); jFrame.add(jTextField); jFrame.add(jLabe2); jFrame.add(jPasswordField); jFrame.getContentPane().setBackground(Color.red); //设置容器的背景颜色 jFrame.setLocation(300, 200); //设置容器的位置 jFrame.setSize(500, 500); //设置容器大小 jFrame.setVisible(true); //让容器显示 jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } } JTextArea 文本域 代码示例： package com.java.chap13.sec06; import javax.swing.*; import java.awt.*; /** * @author Yan * @date 2019/7/28 16:17 */ public class JTextAreaTest { public static void main(String[] args) { JFrame jFrame = new JFrame(&quot;JTextArea文本域测试&quot;); jFrame.setLayout(new GridLayout(1, 2, 10, 10)); JLabel jLabel = new JLabel(&quot;描述：&quot;); JTextArea jTextArea = new JTextArea(); jFrame.add(jLabel); jFrame.add(jTextArea); jFrame.getContentPane().setBackground(Color.red); //设置容器的背景颜色 jFrame.setLocation(300, 200); //设置容器的位置 jFrame.setSize(500, 500); //设置容器大小 jFrame.setVisible(true); //让容器显示 jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } } JPanel 轻量级容器代码示例： package com.java.chap13.sec07; import javax.swing.*; import javax.swing.border.EmptyBorder; import java.awt.*; /** * @author Yan * @date 2019/7/28 16:50 */ public class JPanelTest { public static void main(String[] args) { JFrame jFrame = new JFrame(&quot;JPanel面板测试&quot;); JPanel jPanel=new JPanel(); jPanel.setLayout(new GridLayout(3,2,10,10)); jFrame.add(jPanel); jPanel.setBorder(new EmptyBorder(10,10,10,10)); //设置边距 JLabel jLabel = new JLabel(&quot;用户名：&quot;); JTextField jTextField = new JTextField(); JLabel jLabe2 = new JLabel(&quot;密码：&quot;); JPasswordField jPasswordField = new JPasswordField(); JButton jButton=new JButton(&quot;登录&quot;); JButton jButton2=new JButton(&quot;重置&quot;); jPanel.add(jLabel); jPanel.add(jTextField); jPanel.add(jLabe2); jPanel.add(jPasswordField); jPanel.add(jButton); jPanel.add(jButton2); jFrame.getContentPane().setBackground(Color.red); //设置容器的背景颜色 jFrame.setLocation(300, 200); //设置容器的位置 jFrame.setSize(500, 500); //设置容器大小 jFrame.setVisible(true); //让容器显示 jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } } Swing事件处理代码示例： demo1 package com.java.chap13.sec08; import javax.swing.*; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; /** * @author Yan * @date 2019/7/28 22:11 */ class JButtonListener implements ActionListener{ @Override public void actionPerformed(ActionEvent e) { System.out.println(e.getActionCommand()); JOptionPane.showMessageDialog(null,&quot;我被点击了&quot;); } } public class EventTest1 { public static void main(String[] args) { JFrame jFrame = new JFrame(&quot;Swing事件&quot;); JButton jButton=new JButton(&quot;我是一个按钮&quot;); JButtonListener jButtonListener=new JButtonListener(); jButton.addActionListener(jButtonListener); //添加/注册事件监听 jFrame.add(jButton); jFrame.getContentPane().setBackground(Color.red); //设置容器的背景颜色 jFrame.setLocation(300, 200); //设置容器的位置 jFrame.setSize(500, 500); //设置容器大小 jFrame.setVisible(true); //让容器显示 jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } } demo2 package com.java.chap13.sec08; import javax.swing.*; import java.awt.*; import java.awt.event.WindowEvent; import java.awt.event.WindowListener; /** * @author Yan * @date 2019/7/28 22:17 */ //class MyWindowListener implements WindowListener { // // @Override // public void windowOpened(WindowEvent e) { // System.out.println(&quot;窗口被打开&quot;); // } // // @Override // public void windowClosing(WindowEvent e) { // System.out.println(&quot;窗口关闭&quot;); // } // // @Override // public void windowClosed(WindowEvent e) { // System.out.println(&quot;窗口被关闭&quot;); // } // // @Override // public void windowIconified(WindowEvent e) { // System.out.println(&quot;窗口最小化&quot;); // } // // @Override // public void windowDeiconified(WindowEvent e) { // System.out.println(&quot;窗口从最小化恢复&quot;); // } // // @Override // public void windowActivated(WindowEvent e) { // System.out.println(&quot;窗口被选中&quot;); // } // // @Override // public void windowDeactivated(WindowEvent e) { // System.out.println(&quot;窗口选中被取消&quot;); // } //} public class EventTest2 { public static void main(String[] args) { JFrame jFrame = new JFrame(&quot;Swing事件&quot;); //MyWindowListener myWindowListener=new MyWindowListener(); //jFrame.addWindowListener(myWindowListener); jFrame.addWindowListener(new WindowListener() { @Override public void windowOpened(WindowEvent e) { System.out.println(&quot;窗口被打开&quot;); } @Override public void windowClosing(WindowEvent e) { System.out.println(&quot;窗口关闭&quot;); } @Override public void windowClosed(WindowEvent e) { System.out.println(&quot;窗口被关闭&quot;); } @Override public void windowIconified(WindowEvent e) { System.out.println(&quot;窗口最小化&quot;); } @Override public void windowDeiconified(WindowEvent e) { System.out.println(&quot;窗口从最小化恢复&quot;); } @Override public void windowActivated(WindowEvent e) { System.out.println(&quot;窗口被选中&quot;); } @Override public void windowDeactivated(WindowEvent e) { System.out.println(&quot;窗口选中被取消&quot;); } }); jFrame.getContentPane().setBackground(Color.red); //设置容器的背景颜色 jFrame.setLocation(300, 200); //设置容器的位置 jFrame.setSize(500, 500); //设置容器大小 jFrame.setVisible(true); //让容器显示 jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } } demo3 package com.java.chap13.sec08; import javax.swing.*; import java.awt.*; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; /** * @author Yan * @date 2019/7/28 22:24 */ //class MyWindowAdapter extends WindowAdapter{ // @Override // public void windowClosing(WindowEvent e) { // super.windowClosing(e); // System.out.println(&quot;窗口关闭。。。。。。。&quot;); // } //} public class EventTest3 { public static void main(String[] args) { JFrame jFrame = new JFrame(&quot;Swing事件&quot;); //MyWindowAdapter myWindowAdapter=new MyWindowAdapter(); //jFrame.addWindowListener(myWindowAdapter); jFrame.addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { super.windowClosing(e); System.out.println(&quot;窗口关闭。。。。&quot;); } }); jFrame.getContentPane().setBackground(Color.red); //设置容器的背景颜色 jFrame.setLocation(300, 200); //设置容器的位置 jFrame.setSize(500, 500); //设置容器大小 jFrame.setVisible(true); //让容器显示 jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } } Java IO流IO流简介流是一组有顺序的，有起点和终点的字节集合，是对数据传输的总称或抽象。即数据再两设备间的传输称为流，流的本质是数据传输，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。 IO 流的分类根据处理数据类型的不同分类：字符流和字节流根据数据流向不同分为：输入流和输出流 文件操作File类 public boolean mkdir()：创建此抽象路径名指定的目录 public boolean createNewFile():创建一个文件 public boolean delete():删除此抽象路径名表示的文件或目录。如果此路径名表示一个目录，则该目录必须为空才能删除 public boolean exists():测试此抽象路径名表示的文件或目录是否存在 public File[] listFiles():返回一个抽象路径名数组，这些路径名表示此抽象路径名表示的目录中的文件 public boolean idDirectory():测试此抽象路径名表示的文件是否是一个目录 代码示例： Demo1.java package com.java.chap14.sec02; import java.io.File; import java.io.IOException; /** * @author Yan * @date 2019/7/30 15:43 */ public class Demo1 { public static void main(String[] args) throws IOException { File file=new File(&quot;D://java创建的目录&quot;); boolean b=file.mkdir(); //创建虚拟目录 if (b){ System.out.println(&quot;目录创建成功&quot;); file=new File(&quot;D://java创建的目录//java创建的文件.txt&quot;); boolean b2=file.createNewFile(); //创建文件 if (b2){ System.out.println(&quot;文件创建成功&quot;); }else { System.out.println(&quot;文件创建失败&quot;); } }else { System.out.println(&quot;目录创建失败&quot;); } } } Demo2.java package com.java.chap14.sec02; import java.io.File; import java.io.IOException; /** * @author Yan * @date 2019/7/30 15:43 */ public class Demo2 { public static void main(String[] args) throws IOException { File file=new File(&quot;D://java创建的目录//Java创建的文件.txt&quot;); if (file.exists()){ //假如目录存在 boolean b=file.delete(); //删除文件 if (b){ System.out.println(&quot;删除文件成功&quot;); }else { System.out.println(&quot;删除文件失败&quot;); } } file=new File(&quot;D://java创建的目录&quot;); if (file.exists()){ boolean b2=file.delete(); //删除目录 if (b2){ System.out.println(&quot;删除目录成功&quot;); }else { System.out.println(&quot;删除目录失败&quot;); } } } } Demo3.java package com.java.chap14.sec02; import java.io.File; /** * @author Yan * @date 2019/7/30 17:21 */ public class Demo3 { public static void main(String[] args) { File file=new File(&quot;D://图书&quot;); File files[]=file.listFiles(); //遍历目录 for (int i=0;i&lt;files.length;i++){ System.out.println(files[i]); } } } Demo4.java package com.java.chap14.sec02; import java.io.File; /** * @author Yan * @date 2019/7/30 17:45 */ public class Demo4 { /** * 打印文件 * @param file */ public static void listFile(File file) { if (file != null) { if (file.isDirectory()) { //是目录 File files[]=file.listFiles(); //遍历目录 if (files!=null){ for (int i=0;i&lt;files.length;i++){ listFile(files[i]); //递归调用 } } } else { //是文件 System.out.println(file); //是文件，直接打印文件的路径 } } } public static void main(String[] args) { File file=new File(&quot;D://实验报告&quot;); listFile(file); } } 字节输入，输出流 InputStream 读取文件 代码示例： Demo1.java package com.java.chap14.sec03; import java.io.File; import java.io.FileInputStream; import java.io.InputStream; /** * @author Yan * @date 2019/7/31 14:36 */ public class Demo1 { public static void main(String[] args) throws Exception { File file=new File(&quot;D://测试文件.txt&quot;); InputStream inputStream=new FileInputStream(file); //实例化FileInputStream byte b[]=new byte[1024]; int len=inputStream.read(b); inputStream.read(b); inputStream.close(); //关闭输出流 System.out.println(&quot;读取的内容：&quot;+new String(b,0,len)); } } Demo2.java package com.java.chap14.sec03; import java.io.File; import java.io.FileInputStream; import java.io.InputStream; /** * @author Yan * @date 2019/7/31 14:36 */ public class Demo2 { public static void main(String[] args) throws Exception { File file=new File(&quot;D://测试文件.txt&quot;); InputStream inputStream=new FileInputStream(file); //实例化FileInputStream int fileLength= (int) file.length(); byte b[]=new byte[fileLength]; int len=inputStream.read(b); inputStream.read(b); inputStream.close(); //关闭输出流 System.out.println(&quot;读取的内容：&quot;+new String(b)); } } Demo3.java package com.java.chap14.sec03; import java.io.File; import java.io.FileInputStream; import java.io.InputStream; /** * @author Yan * @date 2019/7/31 14:36 */ public class Demo3 { public static void main(String[] args) throws Exception { File file=new File(&quot;D://测试文件.txt&quot;); InputStream inputStream=new FileInputStream(file); //实例化FileInputStream int fileLength= (int) file.length(); byte b[]=new byte[fileLength]; int temp=0; int len=0; while ((temp=inputStream.read())!=-1){ //一个字节一个字节读取，放到b字节数组里 b[len++]= (byte) temp; } inputStream.close(); //关闭输出流 System.out.println(&quot;读取的内容：&quot;+new String(b)); } } OutputStream 写入文件 代码示例： Demo4.java package com.java.chap14.sec03; import java.io.File; import java.io.FileOutputStream; import java.io.OutputStream; /** * @author Yan * @date 2019/7/31 15:38 */ public class Demo4 { public static void main(String[] args) throws Exception { File file=new File(&quot;D://测试文件.txt&quot;); OutputStream outputStream=new FileOutputStream(file); String str=&quot;你好，我好，大家好&quot;; byte b[]=str.getBytes(); outputStream.write(b); //将b字节数组写入到输出流中 outputStream.close(); //关闭输出流 } } Demo5.java package com.java.chap14.sec03; import java.io.File; import java.io.FileOutputStream; import java.io.OutputStream; /** * @author Yan * @date 2019/7/31 15:38 */ public class Demo5 { public static void main(String[] args) throws Exception { File file=new File(&quot;D://测试文件.txt&quot;); OutputStream outputStream=new FileOutputStream(file,true); //true追加 String str=&quot;你好，我好，大家好&quot;; byte b[]=str.getBytes(); outputStream.write(b); //将b字节数组写入到输出流中 outputStream.close(); //关闭输出流 } } BufferedInputStream和BufferedOutputStream 代码示例： package com.java.chap14.sec03; import java.io.*; /** * @author Yan * @date 2019/7/31 22:31 */ public class Demo6 { /** * 缓冲 * * @throws Exception */ public static void bufferStream() throws Exception { //定义一个带缓冲的字节输入流 BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(&quot;D://实验报告//android//Android应用开发实验指导书.doc&quot;)); //定义一个带缓冲的字节输出流 BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(new FileOutputStream(&quot;D://复制的文件2.doc&quot;)); int b = 0; Long startTime = System.currentTimeMillis(); //开始时间 while ((b = bufferedInputStream.read()) != -1) { bufferedOutputStream.write(b); } bufferedInputStream.close(); bufferedOutputStream.close(); Long endTime = System.currentTimeMillis(); //结束时间 System.out.println(&quot;缓冲花费的时间：&quot; + (endTime - startTime)); } /** * 非缓冲 * * @throws Exception */ public static void stream() throws Exception { InputStream inputStream = new FileInputStream(&quot;D://实验报告//android//Android应用开发实验指导书.doc&quot;); //定义一个输入流 OutputStream outputStream = new FileOutputStream(&quot;D://复制的文件.doc&quot;); int b = 0; Long startTime = System.currentTimeMillis(); //开始时间 while ((b = inputStream.read()) != -1) { outputStream.write(b); } inputStream.close(); outputStream.close(); Long endTime = System.currentTimeMillis(); //结束时间 System.out.println(&quot;非缓冲花费的时间：&quot; + (endTime - startTime)); } public static void main(String[] args) throws Exception { stream(); bufferStream(); } } 缓冲和非缓冲的区别及性能对比 字符输入、输出流 Reader读取文件 代码示例： Demo1.java package com.java.chap14.sec04; import java.io.File; import java.io.FileReader; import java.io.Reader; /** * @author Yan * @date 2019/7/31 23:00 */ public class Demo1 { public static void main(String[] args) throws Exception { File file = new File(&quot;D://测试文件.txt&quot;); Reader reader=new FileReader(file); char c[]=new char[1024]; //字符数组 int len=reader.read(c); reader.close(); //关闭输入流 System.out.println(&quot;读取的内容是：&quot;+new String(c,0,len)); } } Demo2.java package com.java.chap14.sec04; import java.io.File; import java.io.FileReader; import java.io.Reader; /** * @author Yan * @date 2019/7/31 23:04 */ public class Demo2 { public static void main(String[] args) throws Exception { File file = new File(&quot;D://测试文件.txt&quot;); Reader reader=new FileReader(file); char c[]=new char[1024]; //字符数组 int temp=0; int len=0; while ((temp=reader.read())!=-1){ c[len++]= (char) temp; } reader.close(); //关闭输入流 System.out.println(&quot;读取的内容是：&quot;+new String(c,0,len)); } } Writer写入文件 代码示例： Demo3.java package com.java.chap14.sec04; import java.io.*; /** * @author Yan * @date 2019/7/31 23:06 */ public class Demo3 { public static void main(String[] args) throws Exception { File file = new File(&quot;D://测试文件.txt&quot;); Writer out = new FileWriter(file); String str = &quot;我爱中华&quot;; out.write(str); //将字符串写入输出流 out.close(); //关闭输出流 } } Demo4.java package com.java.chap14.sec04; import java.io.File; import java.io.FileWriter; import java.io.Writer; /** * @author Yan * @date 2019/7/31 23:06 */ public class Demo4 { public static void main(String[] args) throws Exception { File file = new File(&quot;D://测试文件.txt&quot;); Writer out = new FileWriter(file,true); String str = &quot;我爱中华&quot;; out.write(str); //将字符串写入输出流 out.close(); //关闭输出流 } } 待续参考 Java知识分享网 Java入门到精通-基础篇op=>operation: Hello World.java(Javac 编译) op1=>operation: Hello World.class(Java 运行) op2=>operation: 执行并运行结果 e=>end op->op1->op2{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-0\", options);","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"},{"name":"基础","slug":"Java/基础","permalink":"http://yoursite.com/categories/Java/基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"基础","slug":"基础","permalink":"http://yoursite.com/tags/基础/"}]},{"title":"整合Swagger","slug":"Spring Boot 整合Swagger","date":"2019-07-13T12:40:56.543Z","updated":"2019-07-13T12:48:58.192Z","comments":true,"path":"2019/07/13/Spring Boot 整合Swagger/","link":"","permalink":"http://yoursite.com/2019/07/13/Spring Boot 整合Swagger/","excerpt":"Swagger 是一款RESTFUL接口的文档在线自动生成+功能测试功能软件。本文简单介绍了在项目中集成swagger的方法和一些常见问题。 如果想深入分析项目源码，了解更多内容，见参考资料。Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。总体目标是使客户端和文件系统作为服务器以同样的速度来更新。文件的方法，参数和模型紧密集成到服务器端的代码，允许API来始终保持同步。Swagger 让部署管理和使用功能强大的API从未如此简单。","text":"Swagger 是一款RESTFUL接口的文档在线自动生成+功能测试功能软件。本文简单介绍了在项目中集成swagger的方法和一些常见问题。 如果想深入分析项目源码，了解更多内容，见参考资料。Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。总体目标是使客户端和文件系统作为服务器以同样的速度来更新。文件的方法，参数和模型紧密集成到服务器端的代码，允许API来始终保持同步。Swagger 让部署管理和使用功能强大的API从未如此简单。 整合pom.xml &lt;!-- swagger api文档 --&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.6.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.6.1&lt;/version&gt; &lt;/dependency&gt; SwaggerConfig.javapackage com.cleanhome.service.config; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import springfox.documentation.builders.ApiInfoBuilder; import springfox.documentation.builders.PathSelectors; import springfox.documentation.builders.RequestHandlerSelectors; import springfox.documentation.service.ApiInfo; import springfox.documentation.spi.DocumentationType; import springfox.documentation.spring.web.plugins.Docket; import springfox.documentation.swagger2.annotations.EnableSwagger2; /** * @author Yan * @date 2019/6/10 13:58 * * swaggerui配置文件 */ @Configuration @EnableSwagger2 public class SwaggerConfig { /** * 创建API应用 * apiInfo() 增加API相关信息 * 通过select()函数返回一个ApiSelectorBuilder实例,用来控制哪些接口暴露给Swagger来展现， * 本例采用指定扫描的包路径来定义指定要建立API的目录。 * * @return */ @Bean public Docket createRestApi() { return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage(&quot;com.cleanhome.service.controller&quot;)) .paths(PathSelectors.any()) .build(); } /** * 创建该API的基本信息（这些基本信息会展现在文档页面中） * 访问地址：http://项目实际地址/swagger-ui.html * @return */ private ApiInfo apiInfo() { return new ApiInfoBuilder() .title(&quot;XXXX&quot;) .description(&quot;XXXX&quot;) .termsOfServiceUrl(&quot;https://yanxin152133.github.io/&quot;) .contact(&quot;yan&quot;) .version(&quot;1.0&quot;) .build(); } } 使用package com.cleanhome.service.controller; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import com.cleanhome.service.bean.EjCustomer; import com.cleanhome.service.service.impl.IEjCustomerServiceImpl; import com.cleanhome.service.utils.Message; import com.cleanhome.service.utils.MessageUtil; import io.swagger.annotations.Api; import io.swagger.annotations.ApiImplicitParam; import io.swagger.annotations.ApiImplicitParams; import io.swagger.annotations.ApiOperation; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.propertyeditors.CustomDateEditor; import org.springframework.web.bind.WebDataBinder; import org.springframework.web.bind.annotation.*; import org.springframework.web.context.request.WebRequest; import java.text.DateFormat; import java.text.SimpleDateFormat; import java.util.Date; import java.util.List; import java.util.Map; /** * @author Yan、ysq * @date 2019/6/11 8:40 * 顾客 * 主要功能： * 1.查询顾客的所有信息 * 2.查询顾客数量 * 3.添加顾客信息 * 4.根据编号进行删除顾客信息 * 5.根据编号进行更新操作 */ @RestController @RequestMapping(&quot;/customer&quot;) @Api(value = &quot;/customer&quot;, description = &quot;顾客信息管理&quot;) public class EjCustomerController { Logger logger = LoggerFactory.getLogger(EjCustomerController.class); @Autowired private IEjCustomerServiceImpl ejCustomerService; @InitBinder public void initBinder(WebDataBinder binder, WebRequest request) { //转换日期 DateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, true));// CustomDateEditor为自定义日期编辑器 } //查询顾客的所有信息 @ApiOperation(value = &quot;查询顾客的所有信息&quot;) @GetMapping(&quot;findAll&quot;) public Message findAll() { List&lt;EjCustomer&gt; list = ejCustomerService.findAll(); logger.info(&quot;查询顾客所有信息成功&quot;); return MessageUtil.success(&quot;查询顾客所有信息成功&quot;, list); } //查询顾客数量 @ApiOperation(value = &quot;查询顾客数量&quot;) @GetMapping(&quot;findCustomer_Num&quot;) public Message findCustomer_Num() { int num = ejCustomerService.findCustomer_Num(); logger.info(&quot;查询顾客数量成功&quot;); return MessageUtil.success(&quot;查询顾客数量成功&quot;, num); } //查询当天新增顾客量 @ApiOperation(value = &quot;查询当天新增顾客量&quot;) @GetMapping(&quot;TodayCustomerNum&quot;) public Message TodayCustomerNum() { int num = ejCustomerService.TodayCustomerNum(); logger.info(&quot;查询当天新增顾客量成功&quot;); return MessageUtil.success(&quot;查询当天新增顾客量成功&quot;, num); } //添加顾客信息 @ApiOperation(value = &quot;添加顾客信息&quot;) @PostMapping(&quot;insert&quot;) @ApiImplicitParams({ @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;id&quot;, value = &quot;顾客编号&quot;, required = false, dataType = &quot;Integer&quot;), @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;account&quot;, value = &quot;顾客账号&quot;, required = true, dataType = &quot;Long&quot;), @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;password&quot;, value = &quot;顾客账号密码&quot;, required = true, dataType = &quot;String&quot;), @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;realname&quot;, value = &quot;顾客真实姓名&quot;, required = true, dataType = &quot;String&quot;), @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;status&quot;, value = &quot;状态&quot;, required = true, dataType = &quot;String&quot;), @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;photo&quot;, value = &quot;顾客头像&quot;, required = true, dataType = &quot;String&quot;), @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;telephone&quot;, value = &quot;顾客联系方式&quot;, required = true, dataType = &quot;String&quot;), @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;register_time&quot;, value = &quot;顾客注册时间&quot;, required = true, dataType = &quot;java.util.Date&quot;) }) public Message insert(EjCustomer ejCustomer) throws Exception { boolean isValid = ejCustomerService.isExits(ejCustomer.getAccount()); if (isValid) { try { ejCustomerService.insert(ejCustomer); logger.info(&quot;添加顾客信息成功&quot;); return MessageUtil.success(&quot;添加顾客信息成功&quot;); } catch (Exception e) { e.printStackTrace(); return MessageUtil.error(e.getMessage()); } } else { logger.warn(&quot;添加顾客信息失败&quot;); return MessageUtil.error(&quot;error&quot;); } } //根据顾客id删除用户信息 @ApiOperation(value = &quot;根据顾客id删除顾客信息&quot;) @GetMapping(&quot;deleteById&quot;) @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;id&quot;, value = &quot;顾客编号&quot;, required = true, dataType = &quot;Integer&quot;) public Message deleteById(Integer id) throws Exception { try { ejCustomerService.deleteById(id); logger.info(&quot;顾客编号为&quot; + id + &quot;删除成功&quot;); return MessageUtil.success(&quot;删除顾客信息成功&quot;); } catch (Exception e) { e.printStackTrace(); logger.warn(&quot;顾客信息删除失败&quot;); return MessageUtil.error(e.getMessage()); } } //根据顾客id进行更新操作 @ApiOperation(value = &quot;根据顾客id进行更新&quot;) @PostMapping(&quot;updateById&quot;) @ApiImplicitParams({ @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;id&quot;, value = &quot;顾客编号&quot;, required = true, dataType = &quot;Integer&quot;), @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;account&quot;, value = &quot;顾客账号&quot;, required = false, dataType = &quot;Long&quot;), @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;password&quot;, value = &quot;顾客账号密码&quot;, required = false, dataType = &quot;String&quot;), @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;realname&quot;, value = &quot;顾客真实姓名&quot;, required = false, dataType = &quot;String&quot;), @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;status&quot;, value = &quot;状态&quot;, required = false, dataType = &quot;String&quot;), @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;photo&quot;, value = &quot;顾客头像&quot;, required = false, dataType = &quot;String&quot;), @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;telephone&quot;, value = &quot;顾客联系方式&quot;, required = false, dataType = &quot;String&quot;), }) public Message updateById(EjCustomer ejCustomer) throws Exception{ try { ejCustomerService.updateById(ejCustomer); logger.info(&quot;顾客编号&quot;+ejCustomer.getId()+&quot;更新成功&quot;); return MessageUtil.success(&quot;更新顾客信息成功&quot;); }catch (Exception e){ e.printStackTrace(); logger.warn(&quot;顾客信息更新失败&quot;); return MessageUtil.error(e.getMessage()); } } }","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/categories/Spring-Boot/"},{"name":"Swagger","slug":"Spring-Boot/Swagger","permalink":"http://yoursite.com/categories/Spring-Boot/Swagger/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"},{"name":"Swagger","slug":"Swagger","permalink":"http://yoursite.com/tags/Swagger/"}]},{"title":"缺陷跟踪","slug":"缺陷跟踪","date":"2019-07-10T03:41:31.838Z","updated":"2019-07-18T14:53:43.348Z","comments":true,"path":"2019/07/10/缺陷跟踪/","link":"","permalink":"http://yoursite.com/2019/07/10/缺陷跟踪/","excerpt":"简答题开发各阶段缺陷放大图","text":"简答题开发各阶段缺陷放大图 同行评审 同行评审的种类 正式评审 技术审查 走查 同行评审方式的选择 工作产品刚勾画，起草时—走查 完成了某一个单独的章节时—技术审查 整个产品完成时—正式评审 软件缺陷发现 同行评审 软件测试 管理评审 PPQA发现 项目组内部发现 客户反馈 软件缺陷生命周期软件缺陷生命周期主要由四个阶段组成： 识别 调查 改正 总结 缺陷度量 缺陷度量：CMMI第四级（量化管理级）的软件组织会根据已收集的缺陷数据，采用统计过程控制（Statistical Process Control,SPC)的方法建立软件过程能力基线（Process Capability Baseline，PCB），定量地刻划出软件或过程的特点，进行量化管理。 SPC:利用统计方法对过程中的各个阶段进行控制，从而达到改进与保证质量的目的；强调以全过程的预防为主；方法是建立控制图 PCB：用基线形式量化地表示过程能力；PCB是个不断随着数据累积校正的过程，本身数据收集必须遵循客观、准确、事实，确保组织基线可以持续为各项目研发作为参考标准；运用PCB有助于对过程的分析和改进； PCB是一组能力指标，是过程实际能力的具体体现。通常包括期望值（Mean）、控制上限（Upper Control Limit，UCL）、控制下限（Low Control Limit，LCL）。以缺陷密度为例， Mean描述了未来项目的缺陷密度的预期值，UCL和LCL描述了未来项目的缺陷密度的合理变化范围。 这样的过程能力基线可用来：(1)帮助未来的项目设立量化的项目质量目标；(2)理解和控制未来项目的实际结果。 软件缺陷跟踪管理流程 总体流程 提交流程 修复流程 验证流程 拒绝流程 争议处理流程 缺陷挂起流程 缺陷状态常用软件缺陷状态 编号 缺陷状态 描述 1 提交（Submitted或New） 已提交的缺陷 2 打开（Open或Active） 经审查后确认的缺陷，等待处理 3 拒绝（Rejected、Refuse或Not a bug） 经审查确认不是缺陷、不需要修复或不需要提交 4 修复（Resolved或Fixed） 或为Fixed。缺陷已被修复 5 关闭（Closed或Inactive） 经审查确认已被修复的缺陷，可将其关闭 6 推迟（Later、Pending或Deferred） 当前无法修复，以后条件具备时再解决，但要确定修复的日期 7 重新打开（Reopen) 经过修复的缺陷未通过验证测试，或已关闭的缺陷重新出现 软件缺陷报告“5C”原则： 内容正确(Correct)：每个组成部分的描述正确，不会引起误解。 内容清晰(Clear)：每个组成部分的描述清晰，易于理解。 步骤简洁(Concise)：只包含必不可少的信息，不包括任何多余的内容。 结构完整(Complete)：包含复现该缺陷的完整步骤和其他本质信息。 风格一致（Consistent）：按照一致的格式书写全部缺陷报告。 优秀的缺陷报告 重现步骤 (1) 打开编辑文字的软件 （2）创建一个新文档（这个文档可以录入文字） （3）在这个文档里随意录入一两行文字（任意） （4）选中录入的一两行文字，选择Font菜单，然后选择Arial字体格式 （5）一两行文字变成了无意义的乱字符 期望结果 当用户选择已录入的文字并改变文字格式时，文本应该正确显示选中的文字格式，不会显示成乱字符 实际结果 这是字体格式的问题，如果把文字格式改变成Arial前保存文件，缺陷不会出现。缺陷仅发生在Win98，且改变文字格式成其他字体格式时正常。 缺陷工具： Bugzilla是一款免费、跨平台的开源缺陷跟踪系统，最初是专门为Unix定制开发的，目前也可在windows、Mac OS平台安装使用，在wins操作系统下的安装和配置略为复杂。bugzilla历史悠久、功能强大、受到很多企业用户的欢迎。 Mantis是一款开源的基于PHP的轻量级跟踪系统，简洁灵活，安装容易，扩展性强，其实用性足以满足中小型项目的缺陷管理和跟踪需要。 禅道：集产品管理、项目管理、质量管理、文档管理、组织管理和事务管理于一体，避免了一个团队使用多个工具，较bugfree功能更全面。 TestCenter是一款集测试需求、测试用例、测试过程、测试结果、以及测试报告管理的测试管理工具。 BugFree基于浏览器，简单、方便、易用的免费、开源的缺陷管理工具。 大题注入-发现矩阵实例 缺陷注入阶段/缺陷发现阶段 需求阶段 概要设计阶段 详细设计阶段 编码阶段 单元测试阶段 集成测试阶段 系统测试阶段 现场阶段 注入合计 需求评审 概要设计审查 49 681 730 详细设计审查 6 42 681 729 代码审查 12 28 114 941 1095 单元测试 21 43 43 223 2 332 集成测试 20 41 61 261 —— 4 387 系统测试 6 8 24 72 —— —— 1 111 现场 8 16 16 40 —— —— —— 1 81 发现合计 122 859 939 1537 2 4 1 1 3465 本阶段缺陷移除率 —— 74% 61% 55% 36% 67% 58% 思路：单元测试：332/（122+859+939+1537+2-730-729-1095）x100%=36% 故障树参考：故障树PPT 故障树分析逻辑门 例题 使用MOCUS算法确定最小割集。首先画出一个足够大的矩阵表格，然后按下面的步骤填充矩阵： 将故障事件门的字符放在左上角（0，0）单元格 将每个门的字符用其下方较低级别的门或基本事件的字符或数字替换，重复此过程。 对于或门：将字符写成一竖排（也就是竖着写）；对于与门：将字符写成一横排。","categories":[{"name":"期末复习","slug":"期末复习","permalink":"http://yoursite.com/categories/期末复习/"},{"name":"缺陷跟踪","slug":"期末复习/缺陷跟踪","permalink":"http://yoursite.com/categories/期末复习/缺陷跟踪/"}],"tags":[{"name":"期末复习","slug":"期末复习","permalink":"http://yoursite.com/tags/期末复习/"},{"name":"缺陷跟踪","slug":"缺陷跟踪","permalink":"http://yoursite.com/tags/缺陷跟踪/"}]},{"title":"软件测试","slug":"软件测试","date":"2019-07-06T05:24:49.898Z","updated":"2019-07-18T14:52:36.149Z","comments":true,"path":"2019/07/06/软件测试/","link":"","permalink":"http://yoursite.com/2019/07/06/软件测试/","excerpt":"思考题1. 你怎样组建一支新的测试团队，包含一些什么岗位，如果要去招聘，开出什么条件？","text":"思考题1. 你怎样组建一支新的测试团队，包含一些什么岗位，如果要去招聘，开出什么条件？参考：首先，测试团队包含的成员（即工作岗位） 测试经理测试部门的负责人。主要职责： 对外： 公司内团队之间的沟通 向上沟通、汇报、日常作业 人才招募 外部影响力（公司内外） 对内 团队管理与建设 项目管理 人才培养 目标拆解、执行、调整、跟进 测试架构师测试技术的负责人，主要承担教练职责，是测试部门的技术核心，涵盖产品测试技术、自动化测试技术、专项测试技术、交付测试技术等方向。主要负责：测试技术管理、测试技术调研、测试技术应用、测试人员的技术培养等。 核心测试人员测试任务的主要执行者，主要负责核心测试任务的落地执行、重要测试技术的落地实践、测试管理要求的有效实施。中等职级、业务专家或擅长某一方向技术。 一般测试人员测试任务的主要辅助执行者，主要负责一般测试任务的落地执行、一般测试技术的落地实践、测试管理要求的有效实施。中低等职级。 测试项目负责人类似于项目经理。工作重点在于沟通和协调。 外包测试人员视为人力，作为一些特殊项目的补充。 测试实习生除了做一些特殊时期的补充外，是选择和提前培养优秀应届生的途径之一。 其次，招聘条件（仅供参考）任职要求： 计算机相关专业，本科及以上学历，3年及以上测试经验，有互联网、SaaS平台产品测试经验者优先； 具备一定的编程能力，熟练掌握Java/C/C++或各类脚本语言中一种，熟悉MySQL等数据库； 熟悉Linux操作系统，有自动化测试经验，能独立设计用例并编写代码实现自动化测试； 熟练测试理论与方法，对互联网质量保证领域有强烈的兴趣； 具有较强的业务分析能力，较好的沟通表达和综合协调能力，对质量保证有深刻理解； 具备撰写自动化测试工具以及搭建自动化测试平台的实战经验者优先。 参考链接： 如何搭建测试团队（研发同理) 2. 如果你作为测试项目负责人，你为什么要对软件测试过程进行管理？测试过程管理的原则，测试过程管理的目标参考：对软件测试过程进行管理的原因： 能够使规定时间内完成所需完成的测试任务。 测试过程管理原则：①有关测试需求；②测试计划先行；③建立任务优先级；④建立客观的评估标准；⑤尽早测试；⑥全面测试；⑦全过程测试；⑧独立的、迭代的测试。 测试过程管理目标：尽可能早地找出软件缺陷，并保证其得以修复。 参考链接： 测试过程管理 测试过程管理 3. 白盒测试策略定义：白盒测试也称结构测试或逻辑驱动测试，是一种测试用例设计方法，它从程序的控制结构导出测试用例。（测试用例由测试输入数据以及与之对应的输出结果组成。） 白盒测试使用被测单元内部如何工作的信息，允许测试人员对程序内部逻辑结构及有关信息来设计和选择测试用例，对程序的逻辑路径进行测试。基于一个应用代码的内部逻辑知识，测试是基于覆盖全部代码、分支、路径、条件。 策略： 桌前检查 模块测试 代码评审 同行评审 代码走查 静态分析 其他参考： 白盒测试：理论基础 4. 掌握功能测试需求分析确定测试优先级参考： 快速划分测试用例优先级 5. 掌握性能测试需求分析会用80-20原理计算负载量书本例题： 测试强度估算80-20原理：每个工作日中80%的业务在20%的时间内完成。举例：每年业务量集中在8个月，每个月20个工作日，每个工作日8个小时即每天80%的业务在1.6小时完成去年全年处理业务约100万笔，其中15%的业务处理中每笔业务需对应用服务器提交7次请求；其中70%的业务处理中每笔业务需对应用服务器提交5次请求；其余15%的业务处理中每笔业务需对应用服务器提交3次请求。根据以往统计结果，每年的业务增量为15%，考虑到今后3年业务发展的需要，测试需按现有业务量的两倍进行。 每年总的请求数：（100x15%x7+100x70%x5+100x15%x3）x2=1000万次/年 每天请求数：1000/160=6.25万次/天 每秒请求数：（62500x80%）/(8x20%x3600)=8.68次/秒即服务器处理请求的能力应达到9次/秒。 6. 设计功能测试用例测试用例模板（仅供参考） 项目/软件 XXX 程序版本 XXX 功能模块名 Login 编制人 XXXX 用例编号 XXXX 编制时间 XXXX 相关的用例 无 功能特性 用户身份验证 测试目的 验证是否输入合法的信息，允许合法登录，阻止非法登录 预置条件 无 特殊规格说明 如数据库访问权限 参考信息 需求说明中关于“登录”的说明 测试数据 用户名=yiii密码=1 操作步骤 操作描述 数据 期望结果 预期结果 实际结果 测试状态 1 输入用户名称按“登录”按钮 用户名=yiyh密码为空 显示警告信息，请输入用户名和密码 2 输入密码，按“登录”按钮 用户名为空密码=1 显示警告信息请输入用户名和密码 测试人员 开发人员 项目负责人 操作步骤需要写出所有情况 7. I/O接口测试，局部数据结构测试检查模块接口是否正确CheckList: 输入的实际参数与形式参数是否一致 个数、属性、量纲 调用其他模块的实际参数与被调模块的形参是否一致 个数、属性、量纲 全程变量的定义在各模块是否一致 外部输入、输出 文件、缓冲区、错误处理 其他 当一个模块执行外部I/O操作时，必须进行附加的接口测试 文件属性是否正确 OPEN/CLOSE语句是否正确？ 格式规约是否和I/O语句匹配？ 缓冲区大小是否和记录大小匹配？ 文件是否在打开之前被使用？ 是否处理了文件结束条件？ 是否处理了I/O错误？ 在输出信息里时候有文本错误？ 模块的局部数据结构是经常出现的错误源。应当设计测试用例以发现下列类型的错误 不正确或不一致的类型描述 错误的初始化或缺省值 不正确的（拼写错误的或被截断的）变量名字 不一致的数据类型 下溢、上溢和地址错误除了局部数据结构，全局数据对模块的影响在单元测试过程中应当进行审查。 检查局部数据结构完整性Checklist: 不适合或不相容的类型说明 变量无初值 变量初始化或默认值有错 不正确的变量名或从来未被使用过 出现上溢或下溢和地址异常 其他 8. 怎样对一段Java代码进行测试，找出代码错误参考：单元测试的步骤： 理解需求和设计 概览源代码 精读源代码 设计测试用例 搭建单元测试环境 执行测试 补充和完善测试用例 分析结果，给出评价 参考链接： 单元测试的步骤 9. 进行项目测试计划时间安排的时候，怎样才算是合理的时间安排？参考：测试计划时间安排上遵守：趋势收敛的原则，越到后面，周期越短，问题应该越少。那么测试执行的原则就是：尽可能的把问题都暴露在前面，这样才能保证测试时间上呈收敛趋势。 做测试计划时，测试轮次的安排，一般根据不同的项目来定，小项目2+1或者1+1，大项目3+1或者2+1。举例说明：假如现有一项目，测试总时间为10天，需要分3轮进行测试。那么测试时间的安排我们采取4、3、2的原则。第一轮（4天）：全面覆盖所有用例；第二轮（3天）：基本上是基本功能全覆盖（故要刷筛选好一级用例），回归问题单，缺陷比较多的模块功能全覆盖；第三轮（2天）：基本上是回归问题单+基本功能全覆盖（执行一级用例）。还有1天留着备用，若第3轮测试有未关闭的bug，需要再加一轮，用于回归问题。 以上就是常见测试计划安排模式：3+1模式。 参考链接： 如何合理安排测试时间 软件测试的测试计划是如何计算测试时间 10. 如果时间紧迫了，测试范围怎样裁剪？参考： 网上资料 部分不重要的需求可以裁剪，不进行测试 对测试范围按照重要性和风险进行优先级评定，优先测试重要的和风险大的 课本 优先级最高的需求功能（优先级如何确定） 新功能和编码改动较大（提高性能表现）的旧功能 经常容易出现问题部分的功能 一些经常被用户使用的功能和配置 11. QTP自动化测试的时候，怎样提高测试脚本执行效率？参考： 使用VBS文件来启动QTP 把变量和函数定义放到外部VBS文件，而不要放在Action中 通过AOM控制QTP重启来解决QTP内存泄露问题 尽量不要使用wait，而使用.sync或exist语句 使用with语句可以让代码更清晰，而且效率更好 使用OR要比DP快点 不要保存image和movie到测试结果中 把运行模式设置为fast 通过AOM控制QTP 在调用Action时使用相对路径 参考链接： QTP：如何优化测试脚本 提高测试效率 以及脚本结构化 如何让你的QTP脚本执行效率更高？ 12. 理解性能测试的指标和性能测试给出的结果曲线参考：性能测试的指标 bs结构程序一般会关注的通用指标如下： Web服务器指标指标： Avg Rps: 平均每秒钟响应次数=总请求时间 / 秒数； Avg time to last byte per terstion （mstes）：平均每秒业务脚本的迭代次数，有人会把这两者混淆； Successful Rounds：成功的请求； Failed Rounds ：失败的请求； Successful Hits ：成功的点击次数； Failed Hits ：失败的点击次数； Hits Per Second ：每秒点击次数； Successful Hits Per Second ：每秒成功的点击次数； Failed Hits Per Second ：每秒失败的点击次数； Attempted Connections ：尝试链接数； cs结构程序，由于一般软件后台通常为数据库，所以我们更注重数据库的测试指标： User 0 Connections ：用户连接数，也就是数据库的连接数量； Number of deadlocks：数据库死锁； Buffer Cache hit ：数据库Cache的命中情况 性能测试给出的结果曲线参考LoadRunner性能测试工具—（三）测试结果样例分析 13. 如果让你负责性能测试，你会按照什么思路开展工作？参考：性能测试的方法是通过模拟生产运行的业务压力量和使用场最组合,测试系统的性能是否满足生产的性能要求。即在特定的运行条件下验证系统的能力状况。主要强调在特定的软硬件环境、特定的测试业务场景下,获得系统的各个性能指标。而身为一个软件测试工程师应根据以下步骤开展工作： 制定目标和分析系统 选择测试度量的方法 学习的相关技术和工具 制定评估标准 设计测试用例 运行测试用例 分析测试结果 课本补充有关软件测试的作用 产品质量的保证 控制成本的关键 软件可靠性确认 让企业具备国际竞争的实力 QA、QC、QM QA 质量保证 QC 质量控制 QM 质量管理 软件测试人才需求快速增长的体现 中国软件产业正在快速增长，需要大量软件相关人才。 软件企业的发展要求测试人才达到一个合适的比例 软件企业开始认识到软件测试对于提高软件质量的重要性，开始重视软件测试。 软件测试技术的内容软件测试包括： 测试计划、测试流程、测试策略、设计测试用例、执行测试、撰写测试报告 单元测试、集成测试、系统测试、确认测试 手工测试、自动化测试 测试工具、缺陷管理和维护工具 编写操作手册、功能手册、系统管理手册、培训手册 维护文档、维护测试环境、分析问题、归纳推理能力 测试用例的组成 用例标识 用例名称 被测功能 用例目的 数据准备 测试步骤 预期结果 实际结果 测试人员 测试日期 编写测试用例的注意事项要解决4W问题 why when who what 测试用例说明包含的要素 标识符 测试项 输入说明 输出说明 环境要求 特殊要求 用例依赖性 测试的三大原则1. 尽早测试2. 连续测试3. 自动化测试 软件测试职业素质 软件测试员的目标：——发现潜在的软件缺陷 软件测试员应具备的素质： 具有探索精神 具有创造性 坚持不懈的精神 故障排除专家 判断准确 追求完美 沟通能力 软件危机内在的原因 在软件开发过程中，软件缺陷的积累和放大效应是导致软件危机的主要原因 人员和其他资源的投入导致开发成本急剧增加，带有缺陷的开发成果导致开发质量大幅下降，反复无常的修改导致开发效率严重底下 因此，迫切地需要规范化地过程来制约软件开发的无序性，便产生了软件工程。 怎样写测试计划 确定内容 总的测试计划 分阶段的测试计划 参考测试模板 考虑以下问题 测试问题 测试策略 测试技术 测试组织 测试准备 测试计划的用途 为测试中的管理工作和技术工作提供指导 确定达到测试目标和测试目的的必要的测试类型和范围 概述有效使用资源的时间和活动的时间顺序安排 通过建立需求跟踪矩阵，为可能的、最高水平的测试覆盖提供保证 概述测试程序脚本的详细内容，描述如何执行测试程序脚本 概述测试所需的人员、财力、设备和工具资源 测试计划的作用 避免测试的“事件驱动” 使测试工作和整个开发工作融合起来 资源和变更事先作为一个可控制的风险 测试需求分析 什么时候进行测试需求分析在开始测试设计之前确定测试需求 测试需求分析做什么？清晰地定义测试需求并形成文档，使所有工作人员理解测试工作的基础 测试需求分析的目的是什么？识别验证系统所需的不同类型的测试，在哪个测试阶段完成。 白盒测试能做什么？ 保证模块内的所有独立路径至少执行一次 执行所有逻辑判定为真和为假的情况 在循环可操作范围内，执行所有边界循环 运用内部数据结构以保证其有效性 单元测试方法在对每个模块进行单元测试时，需要考虑它和周围模块之间的相互联系。为模拟这一联系，在进行单元测试时，必须设置若干个辅助测试模块，这些辅助模块分为两种： 驱动模块。相当于被测模块的主程序，用以模拟被测模块的上级模块，用于接收测试数据，并把这些数据传送给被测模块，启动被测模块，最后输出实测结果。 桩模块。相当于被测模块调用的子模块，用以模拟被测模块的下级模块。 测试评估 软件测试的主要评测方法包括覆盖评测和质量评测。 覆盖评测是对测试完全程度的评测，它建立在测试覆盖基础上测试覆盖是由 测试需求和 测试用例的覆盖或 已执行代码的覆盖表示的 质量评测是对测试对象（系统或测试的应用程序）的可靠性、稳定性以及性能的评测。质量建立在对测试结果的评估和对测试过程中确定的缺陷及缺陷修复的分析的基础上。 功能测试一般什么时候执行 白盒测试可以在编码的早期进行 功能测试主要在后期执行 功能测试的两种策略 顺序测试每个程序特性的功能 一个模块一个模块的测试，即每个功能在其最先调用的地方测试 功能测试的特点 优点 对于较大的代码单元来说（子系统甚至系统级），黑盒测试效率高 测试人员不需要了解实现的细节，包括特定的编程语言 测试人员和编码人员是彼此独立的 从用户的视角进行测试，很容易被理解和接受 有助于暴露任何规格不一致或有歧义的问题 测试用例设计可以在规格完成之后马上进行 缺点 覆盖率较低，大概只能达到总代码量的30% 自动化测试的复用性较低 没有清晰的和简明的规格，测试用例是很难设计的 测试需求和用户需求的区别 测试范围变化 实现方式变化 用测试策略去过滤用户需求 标准手工功能测试和实用手工功能测试的比较 标准软件开发生命周期 实际软件开发生命周期 标准手工功能测试的过程 实用手工功能测试的过程 实用手工功能测试的关注重点 良好的测试用例的特征 可以最大程度地找出软件隐藏的缺陷 可以最高效率地找出软件缺陷 可以最大程度地满足测试覆盖要求 既不过分复杂，也不能过分简单 使软件缺陷的表现可以清楚的判定 不包含重复的测试用例 测试用例的内容清晰、格式一致、分类组织管理 为什么设计良好的（最佳）的测试用例 输入量太大 输出结果太多 软件实现途径太多 软件缺陷的标准不同 完全测试是不可能的 性能测试的类型 并发（竞争）测试 负载测试 压力测试 大数据量测试 疲劳测试 可靠性测试 基准测试 配置测试 性能测试的目标（问题：为了实现目标怎么选择性能测试类型） 评价系统当前性能 寻找瓶颈，优化性能 预测系统未来性能，可扩展性 系统的参数配置 发现一些软件算法方面的缺陷 产品评估/选型 性能测试关注的内容 是否满足需求 并发用户数/吞吐量 平均响应时间 服务器资源占用情况 故障恢复时间 负载量分析的步骤 识别性能测试的目标 与最终客户一起定义 文档化以确保一致 定义负载量 识别关键业务功能 定义场景如何被执行 近似的数据访问模式 识别用户类型和特性 选择测量点 编写负载量分析文档 用来创建有效的测试场景 与最终客户一起复审（获得负载量模型的认可） 软件安全性测试的方法 功能测试（专门设计的安全功能） 漏洞扫描 模拟攻击实验 侦听技术","categories":[{"name":"期末复习","slug":"期末复习","permalink":"http://yoursite.com/categories/期末复习/"},{"name":"软件测试","slug":"期末复习/软件测试","permalink":"http://yoursite.com/categories/期末复习/软件测试/"}],"tags":[{"name":"软件测试","slug":"软件测试","permalink":"http://yoursite.com/tags/软件测试/"},{"name":"期末复习","slug":"期末复习","permalink":"http://yoursite.com/tags/期末复习/"}]},{"title":"软件工程","slug":"软件工程","date":"2019-07-04T07:09:11.097Z","updated":"2019-07-18T14:52:20.246Z","comments":true,"path":"2019/07/04/软件工程/","link":"","permalink":"http://yoursite.com/2019/07/04/软件工程/","excerpt":"软件工程简答题1. 社会、健康、安全、法律、文化、环境对软件工程有什么影响？（举例子说明）","text":"软件工程简答题1. 社会、健康、安全、法律、文化、环境对软件工程有什么影响？（举例子说明） 答： 卓越工程师教育培养计划 金融危机会导致软件业风险的不确定增加。等等。。。 软件工程监理体系建设及其对软件产业影响研究 知识产权 软件工程环境 996ICU 隐私保护等等。 2. 以下是否是软件需求项？什么类别的需求项？ 目标软件必须用Java语言实现。约束性需求 目标软件必须有一个主控模块和分别移动、照相和岩石采集控制的三个子模块组成。否 目标软件必须在0.5秒内响应外部事件。非功能需求-性能需求 当目标软件与用户交互时，必须使用特定的菜单和对话框。否 3. 比较黑盒测试和白盒测试的优缺点。答： 黑盒测试的优点 比较简单，不需要了解程序内部的代码及实现。 与软件的内部实现无关。 从用户角度出发，能很容易的知道用户会用到哪些功能，会遇到哪些问题。 基于软件开发文档，所以也能知道软件实现了文档中的哪些功能。 在做软件自动化测试时较为方便。 黑盒测试的缺点 不可能覆盖所有的代码，覆盖率较低，大概只能达到总代码量的30%。 自动化测试的复用性较低。 白盒测试的优点 帮助软件测试人员增大代码的覆盖，提高代码的质量，发现代码中隐藏的问题。 白盒测试的缺点 程序运行会有很多不同的路径，不可能测试所有的运行路径。 测试基于代码，只能测试开发人员做的对不对，而不能知道设计的正确与否，可能会漏掉一些功能需求。 系统庞大时，测试开销会非常大。 4. 软件生存期模型各个模型的适用范围答： 瀑布模型适用范围：需求明确，小规模软件开发。 快速原型模型适用范围：用户需求不明确，需要通过构建原型来清楚地了解用户的真实需求。 增量模型适用范围：软件开发周期较长的软件，有持续的合作。 螺旋模型适用范围：内部软件开发的大规模软件项目。 喷泉模型适用模型：面向对象的软件开发过程。 5. 为什么要进行软件项目管理参考：任何项目都需要管理，只有认真地管理才能使项目成功地达到预期的目标。预期的目标应该包括以下方面： 达到项目预期的软件产品功能和性能要求，使用户认为这样的软件产品正是自己所期待的，也就是说软件产品达到了用户已认可的需求规格说明的要求。 时限要求。 项目开销限制在预算之内。 同时软件项目管理涉及的几个主要方面是人员、产品、过程和项目，即所谓的4P(People、Produce、Process、Project). 开发人员项目管理是对软件工作的管理，但归根结底是对人员行为的管理，就是对人员的管理。人的因素是软件工程的核心因素，对于这一核心因素的把握决定着项目的成败。在项目的人员管理上需要考虑的几个问题是：1). 利益相关方2). 团队负责人3). 团队集体 产品软件工程是软件项目的成果和预期的目标，然而，软件这种无形的产品在开发出来以前，要想准确地描述它的规模、工作量，甚至他的功能和性能是困难的。除此以外，软件需求的稳定性问题更增加了项目工作的难度。 产品的工作环境 产品的功能和性能 产品工作处理的是什么数据，经他处理后得到什么数据。 过程过程在软件工程项目中是重要的因素，它决定着项目中开展哪些活动以及对活动的要求和开展活动的顺序。 项目项目管理的任务是如何利用已有的资源，组织实施既定的项目，提交给用户适用的产品。在此我们将项目管理要开展的主要工作分为3类：1). 计划与计划管理，其中包括：项目策划及计划制定；项目估算；风险分析及风险管理；进度管理；计划跟踪与监督。2). 资源管理，包括：人员管理；成本管理。3). 成果要求管理，包括：需求管理；配置管理；质量管理。 从开发人员、产品、过程、项目四个方面进行论述 6. 为什么软件维护的费用一直那么高参考：软件维护不仅针对程序代码，而且还针对软件定义、开发的各个阶段生成的文档。而软件在设计阶段很难预料到这个软件交给谁，在什么时候进行什么样的维护工作。软件维护的依据只能靠软件文档和有关的设计信息。这样，软件维护人员不得不花费大量的劳动，用于软件系统的再分析和对软件信息的理解。因此软件的维护费用也就一直高居不下。 7. 软件生命周期，各个过程主要工作答： 可行性分析（研究）与计划阶段要确定该软件的开发目标和总的要求，要进行可行性分析、投资收益分析、制定开发计划，并完成可行性分析报告、开发文档等文档（输出）。 需求分析阶段由系统分析人员对被设计的系统进行系统分析，确定对该软件的各项功能、性能需求和设计约束，确定对文档编制的要求，作为本阶段工作的结果，输出有：软件需求规格说明(也称为：软件需求说明、软件规格说明)、数据要求说明和初步的用户手册应该编写出来。 设计阶段系统设计人员和程序设计人员应该在反复理解软件需求的基础上，提出多个设计，分析每个设计能履行的功能并进行相互比较，最后确定一个设计，包括该软件的结构、模块(或CSCI)的划分、功能的分配，以及处理流程。系统比较复杂的情况下，设计阶段应分解成概要设计阶段和详细设计阶段两个步骤。在一般情况下，完成的文档包括：结构设计说明、详细设计说明和测试计划初稿。 实现阶段要完成源程序的编码、编译(或汇编)和排错调试得到无语法错的程序清单，要开始编写进度日报、周报和月报(是否要有日报或周报，取决于项目的重要性和规模)，并且要完成用户手册、操作手册等面向用户的文档的编写工作，还要完成测试计划的编制。 测试阶段该程序将被全面地测试，已编制的文档将被检查审阅。一般要完成测试分析报告。作为开发工作的结束，所生产的程序、文档以及开发工作本身将逐项被评价，最后写出项目开发总结报告。 运行与维护阶段软件将在运行使用中不断地被维护，根据新提出的需求进行必要而且可能的扩充和删改、更新和升级。软件维护分为改正性维护、适应性维护和预防性维护，分别对应于前面的三个问题。改正性维护就是修改原有的缺陷、适应性维护就是使软件适应新的软硬件环境，预防性维护就是把今天的技术用在昨天的软件上，以期软件在明天还能使用。 8. 为什么程序员在进行单元测试时多以白盒测试为主，而软件测试工程师在进行系统集成测试多以黑盒测试为主？参考：白盒测试方法按照程序内部的结构测试程序，检验程序中的每条通路是否都能按预定要求正确工作，而不顾它的功能。 黑盒测试并不涉及程序的内部结构和内容特性，主要根据规格说明，只依靠被测试程序的输入和输出之间关系或程序的功能来设计测试用例。 论述题1. 用户最终要执行的使用的最终产品写出来的代码，只要在开发阶段做的好，产品就是一定成功的？ 2. 软件在交付的时候，如果软件在运行的时候没有问题就是高质量的软件 3. 从用户得到的原始需求不用分析就可以作为软件设计阶段的依据。","categories":[{"name":"期末复习","slug":"期末复习","permalink":"http://yoursite.com/categories/期末复习/"},{"name":"软件工程","slug":"期末复习/软件工程","permalink":"http://yoursite.com/categories/期末复习/软件工程/"}],"tags":[{"name":"期末复习","slug":"期末复习","permalink":"http://yoursite.com/tags/期末复习/"},{"name":"软件工程","slug":"软件工程","permalink":"http://yoursite.com/tags/软件工程/"}]},{"title":"操作系统","slug":"操作系统","date":"2019-07-01T05:28:14.873Z","updated":"2019-07-18T14:53:58.674Z","comments":true,"path":"2019/07/01/操作系统/","link":"","permalink":"http://yoursite.com/2019/07/01/操作系统/","excerpt":"操作系统信号量解决进程同步问题例题：桌子上有一只盘子，最多可容纳两个水果，每次只能放入或取出一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，两个儿子专等吃盘子中的橘子，两个女儿专等吃盘子中的苹果。请用信号量操作来实现爸爸、妈妈、儿子、女儿之间的同步与互斥关系。","text":"操作系统信号量解决进程同步问题例题：桌子上有一只盘子，最多可容纳两个水果，每次只能放入或取出一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，两个儿子专等吃盘子中的橘子，两个女儿专等吃盘子中的苹果。请用信号量操作来实现爸爸、妈妈、儿子、女儿之间的同步与互斥关系。 semaphore s=2,so=0,sa=0;//s表示盘空，so表示橘子，sa表示苹果。 Cobegin Void father(void) { while(1){ p(s); put apple(); v(sa); } } Void mother(void) { while(1){ p(s); put orange(); v (so); } } Void son(void) { while(1){ p(so); eat orange(); v(s); } } Void daughter(void) { while(1){ p(sa); eat apple(); v(s); } } Coend PV操作参考进程同步之信号量机制（pv操作）及三个经典同步问题 作业调度算法（先来先服务算法、短作业优先算法），计算周转时间、带权周转时间、平均周转时间、平均带权周转时间 周转时间=完成时间-提交时间带权周转时间=周转时间/执行时间平均周转时间=每个周转时间之和/作业总数平均带权周转时间=每个带权周转时间之和/作业总数 例题：求解下表中4个作业在FCFS（先来先服务算法）和SJF（短作业优先算法）调度算法下的调度次序、周转时间、带权周转时间、平均周转时间、平均带权周转时间。 作业 提交时间 执行时间 开始时间 完成时间 周转时间 带权周转时间 1 8.00 2.00 2 8.50 0.50 3 9.00 0.10 4 9.50 0.20 先来先服务调度算法 作业 提交时间 运行时间 开始时间 完成时间 周转时间 带权周转时间 执行顺序 1 8.00 2.00 8.00 10.00 2.00 1 1 2 8.50 0.50 10.00 10.50 2.00 4 2 3 9.00 0.10 10.50 10.60 1.60 16 3 4 9.50 0.20 10.60 10.80 1.30 6.5 4 平均周转时间=1.725平均带权周转时间=6.875 短作业优先调度算法 作业 提交时间 运行时间 开始时间 完成时间 周转时间 带权周转时间 执行顺序 1 8.00 2.00 8.00 10.00 2.00 1 1 2 8.50 0.50 10.30 10.80 2.30 4.6 4 3 9.00 0.10 10.00 10.10 1.10 11 2 4 9.50 0.20 10.10 10.30 0.80 4 3 平均周转时间=1.55平均带权周转时间=5.15 先来先服务算法先来先服务根据作业的提交时间来执行作业，提交的时间早则首先被执行。 短作业优先算法根据执行时间来作为执行顺序，同时第一个到达的作业要首先被执行，之后再根据运行时间的长短来执行，短的则优先执行。 资源分配图的简化资源分配图 在资源分配图中，通常使用圆圈来表示每个进程，用方框表示每种资源类型。由于同一资源类型可能有多个实例，所以在矩形中用圆点数表示实例数。 实例 说明 进程P1申请一个R1类资源 系统分配一个R1类资源给进程P1，此时系统还剩下2个R1类资源 进程P1申请2个R类资源 系统分配2个R1类资源给进程P1，此时系统还剩下1个R1类资源 系统分配一个R1类资源给进程P2，然后分配一个R1类资源给进程P1，最后进程P1收到一个R1类资源又继续申请一个R1类资源，此时系统还剩下一个R1类资源可以分配给进程P1，但是还没有分配给P1 系统分配一个R1类资源给进程P2，然后又分配一个R1类资源给进程P1，最后进程P1收到一个R1类资源又继续申请一个R1类资源，此时系统已经没有R1类资源可以分配给进程P1，于是进程P1收到阻塞 例题： 第一步：先看R1资源，它有三个箭头是向外的，因此它一共给进程分配了3个资源，此时，R1没有空闲的资源剩余。 第二步：再看R2资源，它有一个箭头是向外的，因此它一共给进程分配了1个资源，此时，R2还剩余一个空闲的资源没分配。 第三步：看完资源，再来看进程，先看进程P2，它只申请一个R1资源，但此时R1资源已经用光了，所以，进程P2进入阻塞状态，因此，进程P2暂时不能化成孤立的点。 第四步：再看进程P1，它只申请一个R2资源，此时，系统还剩余一个R2资源没分配，因此，可以满足P1的申请。这样，进程P1便得到了它的全部所需资源，所以它不会进入阻塞状态，可以一直运行，等它运行完后，我们再把它的所有的资源释放。相当于：可以把P1的所有的边去掉，变成一个孤立的点，如下图所示： 第五步：进程P1运行完后，释放其所占有的资源（2个R1资源和1个R2资源），系统回收这些资源后，空闲的资源便变成2个R1资源和1个R2资源，由于进程P2一直在申请一个R1资源，所以此时，系统能满足它的申请。这样，进程P2便得到了它的全部所需资源，所以它不会进入阻塞状态，可以一直运行，等它运行完后，我们再把它的所有的资源释放。相当于：可以把P2的所有的边都去掉，化成一个孤立的点，变成下图： 由于这个资源分配图可完全简化，因此，不会产生死锁。而如果资源分配图中的点，最终不能够化成孤立的点，则进程资源图不能够完全简化，从而会发生死锁。 分页地址变换 地址变换处理 得到页号：自动将逻辑地址分为页号和页内地址 用页号查页表，得到块号 将块号与页内地址拼接，即得物理地址 分页存储逻辑地址转物理地址例题：已知某个分页系统，页面大小为1K(即1024字节)，某一个作业有4个页面，分别装入到主存的第3、4、6、8块中，求逻辑地址2100对应的物理地址。 第一步：求逻辑地址的页号 = 2100/1024=2 （整除） 第二步：求页内偏移量 = 2100 % 1024 =52 （取余） 第三步：产生页表： 页号 块号 0 3 1 4 2 6 3 8 第四步：根据逻辑地址的页号查出物理地址的页框号/帧号：如上图，逻辑地址的第2页对应物理地址的第6页。 第五步：求出物理地址 = 6*1024 + 52 = 6196 设有8页的逻辑地址空间，每页有1024个字节，它们被映射到32块的物理存储区，那么逻辑地址的有效位是多少，物理地址至少多少位？ 逻辑地址：8x1024=2^3x2^10=2^13物理地址：32x1024=2^5x2^10=2^15逻辑地址的有效位是13，物理地址的有效位是15. 十六进制逻辑地址转物理地址一分页存储管理系统中逻辑地址长度为16位，页面大小为4KB字节，现有一逻辑地址为2F6AH，且第0、1、2页依次存放在物理块5、10、11中。求逻辑地址2F6AH对应的物理地址 解： 第一步：将逻辑地址2F6AH转换为二进制为：0010 1111 0110 1010 第二步：由于页面大小为4KB字节，（4KB=2的12次方）。所以逻辑地址的后12位为“页内地址”(也叫做页内偏移量) 第三步：由于逻辑地址的后12位为页内地址，所以剩下的前4位为页号：即0010为页号 第四步：根据页表可知，0010(十进制为2)对于的页框号为11(二进制为1011)所以最终的物理地址为：1011 1111 0110 1010即BF6AH 页面置换算法 定义：选择换出页面的算法评价依据：页面更换频率（缺页率）。 缺页率=缺页次数/页面总访问次数 最佳置换算法（OPT）最佳置换算法所选择淘汰的页面是最长（未来）时间内不再被访问的页面。 例如：系统为某进程分配3个物理块，进程访问页面的顺序是0，7，6，5，7，4，7，3，5，4，7，4，5，6，5，7，6，0，7，6。 访问页面 0 7 6 物理块 0 0 0 7 7 6 接下来下一个进入的数字是5，然后需要淘汰最久不被访问的页面。 首先，需要看0，7，6的哪个是最久不被访问的页面。0在第18次再次访问。7在第5次再次被访问。6在第14次再次被访问。因此需要淘汰0。 按照如上的规律，可以得到以下的结果。 访问页面 0 7 6 5 7 4 7 3 5 4 7 4 5 6 5 7 6 0 7 6 物理块 0 0 0 5 5 5 5 5 5 5 5 5 5 5 5 5 5 0 0 0 7 7 7 7 7 7 3 3 3 7 7 7 7 7 7 7 7 7 7 6 6 6 4 4 4 4 4 4 4 4 6 6 6 6 6 6 6 缺页中断 x x x x x x x x x 缺页率：9/20*100%=36% 缺页中断：在请求分页系统中，可以通过查询页表中的状态位来确定所要访问的页面是否存在于内存中。每当所要访问的页面不在内存时，会产生一次缺页中断，此时操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存。 通俗的讲也就是每次往物理块中添加数据就会产生一次缺页中断。 先进先出页面置换算法（FIFO）先进先出页面置换算法淘汰的页面是淘汰最先进入内存的页面。 访问页面 6 0 1 2 0 3 0 4 2 3 物理块 6 6 6 2 2 2 2 4 4 4 0 0 0 0 3 3 3 2 2 1 1 1 1 0 0 0 3 缺页中断 x x x x x x x x x 缺页率：9/10*100%=90% 最近最久未使用置换算法（LRU）最近最久未使用置换算法淘汰的页面是淘汰最近最久未使用的页面。 访问页面 2 3 2 1 5 2 4 5 3 2 5 2 物理块 2 3 2 1 5 2 4 5 3 2 5 2 2 3 2 1 5 2 4 5 3 2 5 3 2 1 5 2 4 5 3 3 缺页中断 x x x x x x x 缺页率：7/12*100%=58.3% 堆栈实现LRU：系统使用特殊的堆栈来存放内存中每一个页面的页号。每当访问一页时就调整一次，即把被访问页面的页号从栈中移出再压入栈顶。因此，栈顶始终是最新被访问页面的页号。当发生缺页中断时，总是淘汰栈底页号所对应的页面。 磁盘的调度算法先来先服务（FCFS）先来先服务算法是根据进程请求访问磁盘的先后顺序进行调度。例题：某一磁盘请求序列（磁盘号）：98，183，37，122，14，124，65，61.按照先来先服务磁盘调度对磁盘进行请求服务，假设当前磁头在53道上，则磁臂总移动倒数为多少？ 下一个磁道 移动磁道数 98 45 183 85 37 146 122 85 14 108 124 110 65 59 61 4 总移动磁道数=45+85+146+85+108+110+59+4=642. 最短寻道时间优先磁盘调度算法（SSTF）最短寻道时间优先磁盘调度算法是每次都优先满足当前磁头位置最近的磁道访问请求。 例题：若干个等待访问磁盘者依次要访问的磁道为19，43，40，4，79，11，76，当前磁头位于42号柱面，若用最短寻道时间优先磁盘调度算法，则访问序列是什么？思路：将要访问的磁道与当前磁头所在柱面相减并取绝对值，绝对值越小的优先访问。 访问序列为40，43，19，11，4，76，79. 扫描算法（SCAN） 考虑当前移动方向，一直移动到最外/内层磁道时，折返，进行反方向移动。就好比电梯。 寻道方向：…，里-&gt;外，外-&gt;里，….; 若干个等待访问磁盘者依次要访问的磁道为86,147,91,177,94,150,102,175,130，当前磁头位于143号柱面，刚刚处理完125号柱面，使用SCAN算法则访问序列是什么？ 答： 当前方向：从143向磁道号增加的方向 依次访问：147，150，175，177 反方向：130，102，94，91，86（电梯原理） 循环扫描（CSCAN） 循环扫描 寻道方向：…..,里-&gt;外，里-&gt;外，….。或者相反。 若干个等待访问磁盘者依次要访问的磁道为86,147,91,177,94,150,102,175,130，当前磁头位于143号柱面，刚刚处理完125号柱面，使用CSCAN算法则访问序列是什么？ 答： 当前方向：从143向磁道号增加的方向 依次访问：147，150，175，177 再从0开始增加方向：86，91，94，102，130 磁盘空间分配多级索引分配例题：设一个盘块大小为1k,每个盘块号占4Byte,若系统采用2级索引，求文件的最大长度。 答:每个索引块最多可存放1k/4=256个盘块号；采用2级索引是，一个文件最多可拥有的数据块数为256x256=2^6x2^10=64k文件的最长长度为64kx1k=64m. 混合索引分配存放在某磁盘上的文件系统采用混合索引分配方式，其中FCB由6个地址项构成，前四个地址项是直接寻址方式，第五个地址项是一次间接寻址方式，第六个地址项是二次间接寻址。若每个盘块的大小为1KB，盘块号用4个字节描述。那么： （1）源文件系统允许文件的最大长度是多少？（2）将文件的字节偏移量800、8193和819300 转换为物理块号和块内偏移。答：（1）每个盘块能存放的盘块号的个数：1024/4=256文件系统允许的文件最大长度：（4+256+256x256）x1K=65796KB （2） 800/1024商0余800，因为0&lt;4，所以，第一个地址项中存放的块号即为其所在物理块号，块内偏移800。 8193/1024商8余1，4&lt;=8&lt;4+256，所以一次间接寻址，8-4=4，读第五个地址项中存放的块号物理块的内容，其内容中的第五个块号即为其所在物理块号，块内偏移1。 819300/1024商800余100，4+256&lt;=800&lt;4+256+256x256，所以二次间接寻址，800-(4+256)=540，540/256商2余28，读第六个地址项中存放的块号的物理块的内容，再读其内容中的第三个块号所在物理块的内容，其内容的第29个块号即为其所在物理块号，块内偏移为100。 磁盘空间的管理位置分配位示图位示图：用二进制的一位表示磁盘中一个盘块的使用情况。 “0”，对应块是空闲块； “1”，对应块已被分配出去。 盘块分配(1) 顺序扫描位示图，从中找出一个或一组其值为“0”的二进制位(“0”表示空闲)。(2) 将所找到的一个或一组二进制位， 转换成与之相应的盘块号。假定找到的其值为“0”的二进制位，位于位示的第i行、第j列，则其相应的盘块号应按下式计算：b=n(i-1)+j式中， n代表每行的位数。(3) 修改位示图， 令map［i,j］=1。 盘块的回收(1) 将回收盘块的盘块号转换成位示图中的行号和列号。 转换公式为： i=(b-1)DIV n+1 j=(b-1)MOD n+1(2) 修改位示图。 令map ［i,j］=0。 例题：有一计算机系统采用如下图所示的位示图（行号、列号都从0开始编号）来管理空闲盘块。如果盘块从1开始编号，每个盘块的大小为1KB。 （1）现要为文件分配两个盘块，试具体说明分配过程。 （2）若要释放磁盘的第300块，应如何处理？","categories":[{"name":"期末复习","slug":"期末复习","permalink":"http://yoursite.com/categories/期末复习/"},{"name":"操作系统","slug":"期末复习/操作系统","permalink":"http://yoursite.com/categories/期末复习/操作系统/"}],"tags":[{"name":"期末复习","slug":"期末复习","permalink":"http://yoursite.com/tags/期末复习/"},{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/tags/操作系统/"}]},{"title":"Spring Boot整合Druid","slug":"Spring Boot 整合Druid","date":"2019-06-08T06:18:16.866Z","updated":"2019-06-30T05:43:06.735Z","comments":true,"path":"2019/06/08/Spring Boot 整合Druid/","link":"","permalink":"http://yoursite.com/2019/06/08/Spring Boot 整合Druid/","excerpt":"Spring Boot整合Druid","text":"Spring Boot整合Druid pom.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-06-data-jdbc&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;spring-boot-06-data-jdbc&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--引入druid数据源--&gt; &lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.17&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; application.ymlspring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/jdbc username: root password: root type: com.alibaba.druid.pool.DruidDataSource # 数据源其他配置 initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，&#39;wall&#39;用于防火墙 filters: stat,wall maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourceStat: true connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500 DruidConfig.javapackage com.example.springboot.config; import com.alibaba.druid.pool.DruidDataSource; import com.alibaba.druid.support.http.StatViewServlet; import com.alibaba.druid.support.http.WebStatFilter; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.boot.web.servlet.FilterRegistrationBean; import org.springframework.boot.web.servlet.ServletRegistrationBean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import javax.sql.DataSource; import java.util.Arrays; import java.util.HashMap; import java.util.Map; /** * @author Yan * @date 2019/6/8 13:46 */ @Configuration public class DruidConfig { @ConfigurationProperties(prefix = &quot;spring.datasource&quot;) @Bean public DataSource druid(){ return new DruidDataSource(); } //配置Druid的监控 //1、配置一个管理后台的Servlet @Bean public ServletRegistrationBean statViewServlet(){ ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), &quot;/druid/*&quot;); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put(&quot;loginUsername&quot;,&quot;admin&quot;); initParams.put(&quot;loginPassword&quot;,&quot;123456&quot;); initParams.put(&quot;allow&quot;,&quot;&quot;);//默认就是允许所有访问 initParams.put(&quot;deny&quot;,&quot;192.168.15.21&quot;); //拒绝哪些ip访问 bean.setInitParameters(initParams); return bean; } //2、配置一个web监控的filter @Bean public FilterRegistrationBean webStatFilter(){ FilterRegistrationBean bean = new FilterRegistrationBean(); bean.setFilter(new WebStatFilter()); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put(&quot;exclusions&quot;,&quot;*.js,*.css,/druid/*&quot;); bean.setInitParameters(initParams); bean.setUrlPatterns(Arrays.asList(&quot;/*&quot;)); return bean; } }","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/categories/Spring-Boot/"},{"name":"整合Druid","slug":"Spring-Boot/整合Druid","permalink":"http://yoursite.com/categories/Spring-Boot/整合Druid/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"},{"name":"整合Druid","slug":"整合Druid","permalink":"http://yoursite.com/tags/整合Druid/"}]},{"title":"个人觉得比较好的一些插件","slug":"插件","date":"2019-05-26T03:54:10.288Z","updated":"2019-05-08T13:36:55.386Z","comments":true,"path":"2019/05/26/插件/","link":"","permalink":"http://yoursite.com/2019/05/26/插件/","excerpt":"Visual Studio CodeChinese (Simplified) Language Pack for Visual Studio Code适用于 VS Code 的中文（简体）语言包。","text":"Visual Studio CodeChinese (Simplified) Language Pack for Visual Studio Code适用于 VS Code 的中文（简体）语言包。 Markdown Preview EnhancedMarkdown Preview Enhanced 是一款为 Atom 以及 Visual Studio Code 编辑器编写的超级强大的 Markdown 插件。 这款插件意在让你拥有飘逸的 Markdown 写作体验。 City Lights Icon package一个美化 Visual Studio Code 图标的插件。 浏览器插件广告净化器免费高效的广告过滤工具：可以过滤烦人的视频广告、弹窗广告、大横幅广告等网页广告，让你清爽浏览网页。 下载地址：谷歌浏览器 火狐浏览器 Convertio一个文件转换器。网址：https://convertio.co/zh/ 适用于Chrome的Web服务器Web Server for Chrome适用于Chrome的Web服务器使用HTTP通过网络从本地文件夹提供网页。可离线运行。","categories":[{"name":"插件","slug":"插件","permalink":"http://yoursite.com/categories/插件/"}],"tags":[{"name":"插件","slug":"插件","permalink":"http://yoursite.com/tags/插件/"}]},{"title":"Ubuntu18.04 安装 Docker","slug":"Ubuntu18.04 安装 Docker","date":"2019-05-26T03:54:10.201Z","updated":"2019-08-03T08:34:47.428Z","comments":true,"path":"2019/05/26/Ubuntu18.04 安装 Docker/","link":"","permalink":"http://yoursite.com/2019/05/26/Ubuntu18.04 安装 Docker/","excerpt":"准备工作系统要求Docker CE 支持以下版本的 Ubuntu 操作系统： Artful 17.10(Docker CE 17.11 Edge) Zesty 17.04 Xenial 16.04(LTS) Trusty 14.04(LTS) 推荐使用 LTS 版本的，在Ubuntu发行版中，LTS是长期支持版本，会更稳定。","text":"准备工作系统要求Docker CE 支持以下版本的 Ubuntu 操作系统： Artful 17.10(Docker CE 17.11 Edge) Zesty 17.04 Xenial 16.04(LTS) Trusty 14.04(LTS) 推荐使用 LTS 版本的，在Ubuntu发行版中，LTS是长期支持版本，会更稳定。 卸载旧版本旧版本的 Docker 称为 docker 或者 docker-engine，使用以下命令卸载旧版本： sudo apt-get remove docker \\ docker-engine \\ docker.io 安装与验证从 Ubuntu 14.04 开始，一部分内核模块移到了可选内核模块包 (linux-image-extra-*) ，以减少内核软件包的体积。正常安装的系统应该会包含可选内核模块包，而一些裁剪后的系统可能会将其精简掉。AUFS 内核驱动属于可选内核模块的一部分，作为推荐的 Docker 存储层驱动，一般建议安装可选内核模块包以使用 AUFS。 如果系统没有安装可选内核模块的话，可以执行下面的命令来安装可选内核模块包：(操作均为普通用户下) sudo apt-get update sudo apt-get install \\ linux-image-extra-$(uname -r) \\ linux-image-extra-virtual Ubuntu 16.04 + 上的 Docker CE 默认使用 overlay2 存储层驱动,无需手动配置。 使用APT安装由于 apt 源使用 HTTPS 以确保软件下载过程中不被篡改。因此，我们首先需要添加使用 HTTPS 传输的软件包以及 CA 证书。 sudo apt-get update sudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ software-properties-common 鉴于国内网络问题，强烈建议使用国内源，官方源请在注释中查看。为了确认所下载软件包的合法性，需要添加软件源的 GPG 密钥。 (任选其一即可) curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add - 官方源 curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - 然后，我们需要向 source.list 中添加 Docker 软件源 sudo add-apt-repository \\ &quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu \\ $(lsb_release -cs) \\ stable&quot; # 官方源 # $ sudo add-apt-repository \\ # &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \\ # $(lsb_release -cs) \\ # stable&quot; 安装 Docker CEsudo apt update sudo apt install docker-ce 建立 docker 用户组建立docker组: sudo groupadd docker 将当前用户加入docker组： sudo usermod -aG docker $USER 更换国内Docker仓库创建文件： sudo vim /etc/docker/daemon.json 加入以下内容： { &quot;registry-mirrors&quot;: [ &quot;https://registry.docker-cn.com&quot; ] } 然后重启系统。 验证输入以下命令： docker run hello-world 若输出以下内容则为成功。 Unable to find image &#39;hello-world:latest&#39; locally latest: Pulling from library/hello-world ca4f61b1923c: Pull complete Digest: sha256:be0cd392e45be79ffeffa6b05338b98ebb16c87b255f48e297ec7f98e123905c Status: Downloaded newer image for hello-world:latest Hello from Docker! This message shows that your installation appears to be working correctly. To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal. To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bash Share images, automate workflows, and more with a free Docker ID: https://cloud.docker.com/ For more examples and ideas, visit: https://docs.docker.com/engine/userguide/ 参考Ubuntu 下安装 DockerDocker —— 从入门到实践","categories":[{"name":"Docker","slug":"Docker","permalink":"http://yoursite.com/categories/Docker/"},{"name":"安装","slug":"Docker/安装","permalink":"http://yoursite.com/categories/Docker/安装/"}],"tags":[{"name":"Docker安装","slug":"Docker安装","permalink":"http://yoursite.com/tags/Docker安装/"}]},{"title":"Spring MVC和MyBatis开发环境准备","slug":"Spring MVC和MyBatis开发环境准备","date":"2019-05-26T03:54:10.189Z","updated":"2019-05-26T10:51:54.221Z","comments":true,"path":"2019/05/26/Spring MVC和MyBatis开发环境准备/","link":"","permalink":"http://yoursite.com/2019/05/26/Spring MVC和MyBatis开发环境准备/","excerpt":"Spring MVC和MyBatis开发环境准备准备 jdk Intellij IDEA Tomcat Maven MySql","text":"Spring MVC和MyBatis开发环境准备准备 jdk Intellij IDEA Tomcat Maven MySql JDK 安装下载JDK建议使用1.8及以上的版本。官方下载路径：jdk下载路地址 安装双击下载软件，一路单击下一步即可。 配置环境变量Windows：右击【我的电脑】→【属性】→【高级系统设置】→【环境变量】→【系统变量】→【新建】，接着如下图所示： 在【系统变量】的path中添加 %JAVA_HOME%\\bin。 验证，如下图所示： Intellij IDEA下载路径：indea U 激活（针对学生的免费使用计划）参考：Intellij IDEA的下载和使用（针对学生的免费使用计划） Tomcat的安装与配置下载下载链接：Tomcat 8.0其他版本可以查看该页面：下载页面 下载完成后对文件进行解压，解压路径自行设置。 Intellij IDEA 配置 Tomcat步骤如下图： Maven 的安装和配置下载地址：Maven 配置 在Maven的安装目录新建文件夹repository,用来作为本地仓库。 如下图： MySql参考：MySQL 安装| 菜鸟教程","categories":[{"name":"SSM","slug":"SSM","permalink":"http://yoursite.com/categories/SSM/"},{"name":"开发环境准备","slug":"SSM/开发环境准备","permalink":"http://yoursite.com/categories/SSM/开发环境准备/"}],"tags":[{"name":"Spring MVC和MyBatis开发环境准备","slug":"Spring-MVC和MyBatis开发环境准备","permalink":"http://yoursite.com/tags/Spring-MVC和MyBatis开发环境准备/"}]},{"title":"qtp破解","slug":"qtp","date":"2019-05-26T03:54:10.169Z","updated":"2019-04-20T14:22:35.124Z","comments":true,"path":"2019/05/26/qtp/","link":"","permalink":"http://yoursite.com/2019/05/26/qtp/","excerpt":"qtp安装与破解准备： QTP 10.0 破解文件","text":"qtp安装与破解准备： QTP 10.0 破解文件 下载 链接: https://pan.baidu.com/s/19TGLWjd_znKFM8RZkj1ITg 提取码: 9wjv 安装 qtp 选择 QTP10.iso,解压后点击文件目录中的 setup.exe,双击运行。按照图片顺序进行操作。 破解1.在c:\\program files\\common files\\mercury interactive目录下新建一个文件夹：License Manager注：64位操作系统在c:\\program files(x86)\\common files\\mercury interactive以下步骤以此类推。 2.将下载的文件中的qtp破解解压，将mgn-mqt8.2.exe复制到qtp的安装路径的bin文件夹中，然后以管理员身份运行。 3.打开c:\\program files\\common files\\mercury interactive\\License Manager中的lservrc文件。 4.将lservrc文件中的内容（将”QuickTestPro”之前的所有字符复制进去，不包括”QuickTestPro”字符）粘贴到如下图中。","categories":[{"name":"软件测试","slug":"软件测试","permalink":"http://yoursite.com/categories/软件测试/"},{"name":"qtp","slug":"软件测试/qtp","permalink":"http://yoursite.com/categories/软件测试/qtp/"}],"tags":[{"name":"软件测试","slug":"软件测试","permalink":"http://yoursite.com/tags/软件测试/"},{"name":"qtp","slug":"qtp","permalink":"http://yoursite.com/tags/qtp/"}]},{"title":"LoadRunner","slug":"LoadRunner","date":"2019-05-26T03:54:10.137Z","updated":"2019-05-11T06:14:47.837Z","comments":true,"path":"2019/05/26/LoadRunner/","link":"","permalink":"http://yoursite.com/2019/05/26/LoadRunner/","excerpt":"LoadRunner 11.0准备： LoadRunner 11.0 安装包 LoadRunner 11.0 破解相关文件","text":"LoadRunner 11.0准备： LoadRunner 11.0 安装包 LoadRunner 11.0 破解相关文件 下载： LoadRunner 11.0 安装包（迅雷下载）：http://www.genilogix.com/downloads/loadrunner/loadrunner-11.iso LoadRunner 11.0 破解相关文件 安装步骤 打开LoadRunner 11.0 安装包文件夹，点击setup.exe。 点击LoadRunner完整安装程序，接着按提示进行下去，当它提示缺省文件的时候可以直接打开“附加组件”进入“Monitor Probe for Microsoft COM+ Server Components”这个文件夹，运行“Com_Plus_Probe.exe”文件即可。 安装成功即进入主界面，进入的时候会有一个提示框出现，意思就是你拥有10天的试用权限。 破解 打开LoadRunner 11.0 破解相关文件，将mlr5lprg.dll和lm70.dll这两个文件复制替换到LoadRunner安装目录的/bin文件下。 以管理员身份运行deletelicense.exe 管理员身份运行LoadRunner。 点击“configuration-&gt;loadRunner License”进入界面，现在你就可以new你自己的license了。下面是不同数量并发的代码：10000个并发：AEABEXFR-YTIEKEKJJMFKEKEKWBRAUNQJU-KBYGB提供一个超级license 最高支持6.5w个并发：AEACFSJI-YJKJKJJKEJIJD-BCLBR。 参考loadRunner 安装及破解 LoadRunner 11.0安装+汉化+破解 loadRunner破解不成功的几个原因","categories":[{"name":"软件测试","slug":"软件测试","permalink":"http://yoursite.com/categories/软件测试/"},{"name":"LoadRunner","slug":"软件测试/LoadRunner","permalink":"http://yoursite.com/categories/软件测试/LoadRunner/"}],"tags":[{"name":"软件测试","slug":"软件测试","permalink":"http://yoursite.com/tags/软件测试/"},{"name":"LoadRunner","slug":"LoadRunner","permalink":"http://yoursite.com/tags/LoadRunner/"}]},{"title":"Hexo主题casper使用教程","slug":"Hexo主题casper使用教程","date":"2019-05-26T03:54:07.007Z","updated":"2019-04-17T14:08:16.453Z","comments":true,"path":"2019/05/26/Hexo主题casper使用教程/","link":"","permalink":"http://yoursite.com/2019/05/26/Hexo主题casper使用教程/","excerpt":"Hexo主题casper使用教程demo","text":"Hexo主题casper使用教程demo 安装下载git clone https://github.com/xzhih/hexo-theme-casper.git themes/hexo-casper 更改主题为casper把Hexo根目录的配置文件_config.yml中的theme改为hexo-casper。 升级建议先备份以下再执行下面的操作。 cd themes/casper git pull 添加统一的文章模板参数把下面的内容添加到Hexo根目录下的scaffolds/post.md。 cover_img: # 在文章摘要上显示 feature_img: # 在文章详细页面上置顶 description: # 文章描述 keywords: # 关键字 自定义配置编辑themes/hexo-casper/_config.yml进行配置。 # Config rss: # link favicon: https://i.loli.net/2017/11/26/5a19c0b50432e.png blog_logo: header_image: https://i.loli.net/2017/11/26/5a19c56faa29f.jpg bio: This is a demo post_toc: true # 菜单 menu: About: /about Archives: /archives # 其他的可以按照上面的模板添加 # 作者 author_image: # 链接 author_bio: # 描述 author_location: # 地址 # 社交链接 social: facebook: https://www.facebook.com twitter: https://www.twitter.com twitter: https://twitter.com facebook: https://facebook telegram: bilibili: youtube: # 插件（显示在网站底部） widgets: recent_posts: true category: true tagcloud: true # 这是个简洁的主题，我认为3个就够了 # 文章图片相册（点击图片可以放大） # https://github.com/sachinchoolur/lightgallery.js lightgallery: true # 懒加载 # 首页已经默认开启，其他页面在此开启 # https://github.com/dinbror/blazy lazyload: true # 搜索功能 local_search: true # Valine 评论系统 # https://valine.js.org comment: false valine: notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code appId: # your leancloud application appid appKey: # your leancloud application appkey placeholder: Just go go # comment box placeholder avatar: mm # gravatar style pageSize: 10 # pagination size # PWA # 你需要在 hexo 目录的 source 文件夹里创建一个 manifest.json 文件 manifest: false service_workers: false navColor: &#39;3c484e&#39; # Baidu 链接提交 baidu: false # Google Analytics googleAnalytics: false GA_TRACKING_ID: UA-XXXXXXXXXX-1 本地搜索功能安装npm install hexo-generator-search --save 配置在Hexo根目录下中的_config.yml进行配置。 search： path：search.xml field：post content：true path-文件路径。默认为search.xml。如果文件扩展名为.json，则输出格式为JSON。否则将导出XML格式文件。filed-要搜索的文件范围。 post（默认）-所有帖子 page -所有页面 all -所有帖子和页面 content-是否包含每篇文章的全部内容。默认为true。如果false，生成的结果仅覆盖没有主体的标题和其他元信息。 排除索引要将某个帖子或页面排除在索引之外，您只需indexing: false在其前端的顶部插入设置，例如： title: &quot;Code Highlight&quot; date: &quot;2014-03-15 20:17:16&quot; tags: highlight categories: Demo description: &quot;A collection of Hello World applications from helloworld.org.&quot; toc: true indexing: false ---","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/categories/Hexo/"},{"name":"Hexo主题casper使用教程","slug":"Hexo/Hexo主题casper使用教程","permalink":"http://yoursite.com/categories/Hexo/Hexo主题casper使用教程/"}],"tags":[{"name":"Hexo主题casper使用教程","slug":"Hexo主题casper使用教程","permalink":"http://yoursite.com/tags/Hexo主题casper使用教程/"}]},{"title":"hexo-theme-indigo","slug":"hexo-theme-indigo","date":"2019-05-26T03:54:06.999Z","updated":"2019-04-16T14:29:05.240Z","comments":true,"path":"2019/05/26/hexo-theme-indigo/","link":"","permalink":"http://yoursite.com/2019/05/26/hexo-theme-indigo/","excerpt":"hexo-theme-indigo 主题demo","text":"hexo-theme-indigo 主题demo 主题安装安装需确认Hexo版本在 3.0 以上，以及Node版本在6.x以上，在Hexo根目录，执行以下命令： git clone git@github.com:yscoder/hexo-theme-indigo.git themes/indigo 切换主题在Hexo根目录下的_config.yml文件中修改，如下： theme: indigo 注：记得保存。 依赖安装Less主题默认使用 less 作为 css 预处理工具。 npm install hexo-renderer-less --save Feed用于生成 rss。 npm install hexo-generator-feed --save Json-content用于生成静态站点数据，用作站内搜索的数据源。 npm install hexo-generator-json-content --save QRCode(可选)用于生成微信分享二维码。可选，不安装时会请求 jiathis Api 生成二维码。 npm install hexo-helper-qrcode --save 开启分类页仅 card theme 支持。 hexo new page categories 修改 hexo/source/categories/index.md 的元数据 layout: categories comments: false --- 开启标签页hexo new page tags 修改 hexo/source/tags/index.md 的元数据 layout: tags comments: false --- 常见问题文章截断在Markdown中加 添加多个标签tags: [a, b, c] 或 tags: - a - b - c 分类categories: [a, b, c] 更改站点配色编辑 themes\\indigo\\source\\css_partial\\variable.less，更改对应的颜色变量。配色参考：Material Design Color Palette Generator注意：使用自定义配色时需把主题配置中的 cdn 关闭，cdn: false。 其他参考：https://github.com/yscoder/hexo-theme-indigo/wiki/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98 站点配置编辑站点配置文件 \\themes\\landscape的_config.yml文件。 启动主题theme: indigo 基本配置左侧菜单menu: home: text: 主页 url: / archives: url: /archives tags: url: /tags github: url: https://github.com/yscoder target: _blank weibo: url: http://www.weibo.com/ysweb target: _blank link: text: 测试 url: / 添加新菜单项时，在 menu 下增加子属性即可。属性说明如下： menu: link: # fontawesome图标，省略前缀，本主题前缀为 icon-，必须 text: About # 菜单显示的文字，如果省略即默认与图标一致，首字母会转大写 url: /about # 链接，绝对或相对路径，必须 target: _blank # 是否跳出，省略则在当前页面打开 favicon站点 logo，显示在浏览器当前标签页左上角。 favicon: /favicon.ico 头像位于左侧菜单上方 avatar: /img/logo.jpg email头像下方 email: 634206017@qq.com color设置 Android L Chrome 浏览器状态栏颜色，不需要可去除此项或设为 false。 color: &#39;#3F51B5&#39; 其他参考：https://github.com/yscoder/hexo-theme-indigo/wiki/%E9%85%8D%E7%BD%AE","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/categories/Hexo/"},{"name":"hexo-theme-indigo","slug":"Hexo/hexo-theme-indigo","permalink":"http://yoursite.com/categories/Hexo/hexo-theme-indigo/"}],"tags":[{"name":"hexo-theme-indigo","slug":"hexo-theme-indigo","permalink":"http://yoursite.com/tags/hexo-theme-indigo/"}]},{"title":"Hexo yilia 添加目录页面","slug":"Hexo yilia 添加目录页面","date":"2019-05-26T03:54:06.987Z","updated":"2018-12-17T14:02:00.000Z","comments":true,"path":"2019/05/26/Hexo yilia 添加目录页面/","link":"","permalink":"http://yoursite.com/2019/05/26/Hexo yilia 添加目录页面/","excerpt":"步骤 1.添加 categories 页面 2.添加 categories 链接 3.修改 yilia 主题 4.多层分类 5.效果 6.参考文档","text":"步骤 1.添加 categories 页面 2.添加 categories 链接 3.修改 yilia 主题 4.多层分类 5.效果 6.参考文档 1 添加 categories 页面1.1 新建 categories 页面 输入命令： hexo new page categories 该命令在 source 目录下生成一个 categories 目录，categories 目录下有一个 index.md 文件。 1.2 修改 index.md 文件--- title: 文章分类 date: 2018-10-19 11:22:21 type: &quot;categories&quot; layout: &quot;categories&quot; comments: false #关闭评论 --- 2 添加 categories 链接 若主题为 yilia ，则打开 yilia/_config.yml ，修改为： menu: 主页: / 相册: / 分类: /categories 3 修改 yilia 主题3.1 新建yilia/layout/categories.ejs&lt;article class=&quot;article article-type-post show&quot;&gt; &lt;header class=&quot;article-header&quot;&gt; &lt;h1 class=&quot;article-title&quot; itemprop=&quot;name&quot;&gt; &lt;%= page.title %&gt; &lt;/h1&gt; &lt;/header&gt; &lt;% if (site.categories.length){ %&gt; &lt;div class=&quot;category-all-page article-type-post show&quot;&gt; &lt;h3&gt;共计&amp;nbsp;&lt;%= site.categories.length %&gt;&amp;nbsp;个分类&lt;/h3&gt; &lt;ul class=&quot;category-list&quot;&gt; &lt;% site.categories.sort(&#39;name&#39;).each(function(item){ %&gt; &lt;% if(item.posts.length){ %&gt; &lt;li class=&quot;category-list-item&quot;&gt; &lt;a href=&quot;&lt;%- config.root %&gt;&lt;%- item.path %&gt;&quot; title=&quot;&lt;%= item.name %&gt;&quot;&gt;&lt;%= item.name %&gt;&lt;sup&gt;[&lt;%= item.posts.length %&gt;]&lt;/sup&gt;&lt;/a&gt; &lt;/li&gt; &lt;% } %&gt; &lt;% }); %&gt; &lt;/ul&gt; &lt;/div&gt; &lt;% } %&gt; &lt;/article&gt; 3.2 修改 yilia\\source\\main.0cf68a.css，将下面的内容添加进去category-all-page { margin: 30px 40px 30px 40px; position: relative; min-height: 70vh; } .category-all-page h2 { margin: 20px 0; } .category-all-page .category-all-title { text-align: center; } .category-all-page .category-all { margin-top: 20px; } .category-all-page .category-list { margin: 0; padding: 0; list-style: none; } .category-all-page .category-list-item-list-item { margin: 10px 15px; } .category-all-page .category-list-item-list-count { color: $grey; } .category-all-page .category-list-item-list-count:before { display: inline; content: &quot; (&quot;; } .category-all-page .category-list-item-list-count:after { display: inline; content: &quot;) &quot;; } .category-all-page .category-list-item { margin: 10px 10px; } .category-all-page .category-list-count { color: $grey; } .category-all-page .category-list-count:before { display: inline; content: &quot; (&quot;; } .category-all-page .category-list-count:after { display: inline; content: &quot;) &quot;; } .category-all-page .category-list-child { padding-left: 10px; } 4 多层分类4.1 修改yilia/layout/categories.ejs为：&lt;article class=&quot;article article-type-post show&quot;&gt; &lt;header class=&quot;article-header&quot; style=&quot;border-bottom: 1px solid #ccc&quot;&gt; &lt;h1 class=&quot;article-title&quot; itemprop=&quot;name&quot;&gt; &lt;%= page.title %&gt; &lt;/h1&gt; &lt;/header&gt; &lt;% if (site.categories.length){ %&gt; &lt;div class=&quot;category-all-page&quot;&gt; &lt;h2&gt;共计&amp;nbsp;&lt;%= site.categories.length %&gt;&amp;nbsp;个分类&lt;/h2&gt; &lt;%- list_categories(site.categories, { show_count: true, class: &#39;category-list-item&#39;, style: &#39;list&#39;, depth: 2, separator: &#39;&#39; }) %&gt; &lt;/div&gt; &lt;% } %&gt; &lt;/article&gt; 4.2 修改自己的文章--- title: Hexo yilia 添加目录页面 tags: Hexo yilia 添加目录 toc: true categories: [Hexo,创建目录] --- 5 效果 如下图： 6 参考文档 Hexo添加categories页面","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/categories/Hexo/"},{"name":"创建目录","slug":"Hexo/创建目录","permalink":"http://yoursite.com/categories/Hexo/创建目录/"}],"tags":[{"name":"Hexo yilia 添加目录","slug":"Hexo-yilia-添加目录","permalink":"http://yoursite.com/tags/Hexo-yilia-添加目录/"}]},{"title":"Hexo yilia 添加Valine","slug":"Hexo yilia 添加Valine","date":"2019-05-26T03:54:06.971Z","updated":"2018-10-21T04:49:50.000Z","comments":true,"path":"2019/05/26/Hexo yilia 添加Valine/","link":"","permalink":"http://yoursite.com/2019/05/26/Hexo yilia 添加Valine/","excerpt":"步骤 1.Valine 介绍 2.注册LeanCloud 3.配置 4.参考文档","text":"步骤 1.Valine 介绍 2.注册LeanCloud 3.配置 4.参考文档 Valine 介绍 Valine- 一款快速、简洁且高效的无后端评论系统。 Valine 诞生于2017年8月7日，是一款基于Leancloud的快速、简洁且高效的无后端评论系统。理论上支持但不限于静态博客，目前已有Hexo、Jekyll、Typecho、Hugo 等博客程序在使用Valine。 特性 快速安全Emoji 😉无后端实现MarkDown 全语法支持轻量易用(~15kb gzipped)文章阅读量统计 v1.2.0+ 注册 LeanCloud 注册 LeanCloud 注册完成后创建一个应用。然后打开设置-应用Key。如下图： 复制图中的 App ID App key Master Key 作为备用 配置 _config.yml #6、Valine https://valine.js.org valine: appid: #Leancloud应用的appId appkey: #Leancloud应用的appKey verify: false #验证码 notify: false #评论回复提醒 avatar: mm #评论列表头像样式：&#39;&#39;/mm/identicon/monsterid/wavatar/retro/hide placeholder: Just go go #评论框占位符 layout/_partial/article.ejs &lt;% if (theme.valine &amp;&amp; theme.valine.appid &amp;&amp; theme.valine.appkey){ %&gt; &lt;section id=&quot;comments&quot; style=&quot;margin:10px;padding:10px;background:#fff;&quot;&gt; &lt;%- partial(&#39;post/valine&#39;, { key: post.slug, title: post.title, url: config.url+url_for(post.path) }) %&gt; &lt;/section&gt; &lt;% } %&gt; &lt;% } %&gt; layout/_partial/post/valine.ejs &lt;div id=&quot;vcomment&quot; class=&quot;comment&quot;&gt;&lt;/div&gt; &lt;script src=&quot;//cdn1.lncld.net/static/js/3.0.4/av-min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;//unpkg.com/valine/dist/Valine.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var notify = &#39;&lt;%= theme.valine.notify %&gt;&#39; == true ? true : false; var verify = &#39;&lt;%= theme.valine.verify %&gt;&#39; == true ? true : false; window.onload = function() { new Valine({ el: &#39;.comment&#39;, notify: notify, verify: verify, app_id: &quot;&lt;%= theme.valine.appid %&gt;&quot;, app_key: &quot;&lt;%= theme.valine.appkey %&gt;&quot;, placeholder: &quot;&lt;%= theme.valine.placeholder %&gt;&quot;, avatar:&quot;&lt;%= theme.valine.avatar %&gt;&quot; }); } &lt;/script&gt; 参考文档 1 为你的Hexo加上评论系统-Valine2 新增对Valine评论系统的支持","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/categories/Hexo/"},{"name":"Valine评论","slug":"Hexo/Valine评论","permalink":"http://yoursite.com/categories/Hexo/Valine评论/"}],"tags":[{"name":"Hexo yilia Valine","slug":"Hexo-yilia-Valine","permalink":"http://yoursite.com/tags/Hexo-yilia-Valine/"}]},{"title":"git使用","slug":"git使用","date":"2019-05-26T03:54:06.950Z","updated":"2019-06-03T05:43:52.083Z","comments":true,"path":"2019/05/26/git使用/","link":"","permalink":"http://yoursite.com/2019/05/26/git使用/","excerpt":"","text":"提交文件到GitHub具体步骤如下： 登录GitHub，复制git仓库的地址 [github_repository_url]。 执行 git clone [github_repository_url],将GitHub 的仓库克隆到本地。 进入到克隆的仓库目录，若目录是很久之前克隆出来，需要使用 git pull 以更新到GitHub中的最新文件。 执行 git add . 将所有改动添加到本地仓库中。 执行 git commit -m “这次提交的内容的描述，自行填写” 将改动提交到本地仓库。 执行 git push origin master 将本地的改动提交到GitHub，master 为主分支。 重写历史git add Title git commit -m &quot;ceshi&quot; git commit --amend ##重写上次提交的信息 分支首先，先创建dev,然后切换到dev分支： git checkout -b dev git checkout 命令加上-b参数表示创建并切换，相当于一下两条命令： git branch dev git checkout dev 然后用git branch命令查看当前分支： git branch * dev master git branch命令会列出所有分支，当前分支前面会标一个*号。 之后提交同上步。 合并分支git merge dev git merge命令用于合并指定分支到当前分支 删除分支git branch -d dev","categories":[{"name":"版本控制","slug":"版本控制","permalink":"http://yoursite.com/categories/版本控制/"},{"name":"git","slug":"版本控制/git","permalink":"http://yoursite.com/categories/版本控制/git/"}],"tags":[{"name":"版本控制","slug":"版本控制","permalink":"http://yoursite.com/tags/版本控制/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"GitHub+Hexo搭建个人博客","slug":"GitHub+Hexo搭建个人博客","date":"2019-05-26T03:54:06.938Z","updated":"2018-12-12T13:43:01.000Z","comments":true,"path":"2019/05/26/GitHub+Hexo搭建个人博客/","link":"","permalink":"http://yoursite.com/2019/05/26/GitHub+Hexo搭建个人博客/","excerpt":"搭建步骤 1.GitHub 创建个人仓库 2.安装Git 3.安装Node.js 4.安装Hexo 5.美化 6.部署","text":"搭建步骤 1.GitHub 创建个人仓库 2.安装Git 3.安装Node.js 4.安装Hexo 5.美化 6.部署 1 GitHub 创建个人仓库1.1 创建仓库（用户名.github.io) 1 登录GitHub,如果没有的话请先注册。 2 登录之后点击GitHub 中的 New repository创建新的仓库. 3 仓库名应为：用户名.github.io 比如： 2 安装Git2.1 安装Git 1 安装Git。 2 下载安装成功后进行将自己的Github账号与Git进行绑定. 2.2 配置 1 打开Git,并配置。输入以下命令： git config --global user.name &quot;自己注册GitHub的用户名&quot; git config --global user.email &quot;注册GitHub时所用的邮箱&quot; 2.3 ssh 1 设置user.name和user.email配置信息之后进行生成ssh密匙文件 ssh-keygen -t rsa -C &quot;####@####.com&quot; 2 然后找到该命令生成的id_rsa.pub密匙。路径为 C:\\Users\\Admin\\.ssh 3 打开该文件，推荐使用 Visual Studio Code 打开 2.4 GitHub 添加密匙 1 复制文件中的所有内容，然后进入 GitHub_Settings_Deploy keys 界面，点击右边的Add deploy key 如图所示： 2 新建 new SSH Key 注： title可自定义内容，Key为之前复制的密匙 2.5 检测 1 以上步骤完成后， 检测GitHub公匙是否成功，输入下面的命令： ssh git@github.com ssh连接成功 3 安装Node.js3.1 安装Node.js 1 下载并安装Node.js,根据自己的喜好下载不同的版本 3.2 检测是否安装成功 1 检测Node.js是否安装成功 node -v 2 检测nopm是否安装成功 npm -v 4 安装Hexo4.1 创建 1 创建一个文件夹，创建完成之后选择该文件夹并按住shift右键,如下图所示： 4.2 添加Hexo 1 依次输入,参考Hexo官方文档 npm install hexo-cli -g hexo init npm install hexo server 4.3 预览 1 在浏览器输入localhost:4000 2 若出现错误，参考以下： 使用localhost:4000访问本地blog一直无响应使用localhost:4000访问本地blog一直无响应使用localhost:4000访问本地blog一直无响应 5 美化5.1 挑选主题 1 Hexo官网提供的主题 2 我使用的是yilia，我的博客 5.2 下载主题 1 在根目录打开Git，输入 git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 5.3 更新主题cd thems/yilia git pull 5.4 配置主题 1 根目录打开_config.yml配置文件 2 将 themes:##### 改为 theme: yilia 5.5 个性化主题 1 打开 themes 下的 yilia 文件夹中的 _config.yml 2 配置主题（添加头像，图标及其他） # Header menu: 主页: / 相册: /photos # SubNav subnav: #github: &quot;#&quot; #weibo: &quot;#&quot; #rss: &quot;#&quot; #zhihu: &quot;#&quot; #qq: &quot;#&quot; #weixin: &quot;#&quot; #jianshu: &quot;#&quot; #douban: &quot;#&quot; #segmentfault: &quot;#&quot; #bilibili: &quot;#&quot; #acfun: &quot;#&quot; #mail: &quot;#&quot; #facebook: &quot;#&quot; #google: &quot;#&quot; #twitter: &quot;#&quot; #linkedin: &quot;#&quot; #rss: /atom.xml url: # # 是否需要修改 root 路径 # 如果您的网站存放在子目录中，例如 http://yoursite.com/blog， # 请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。 root: / # Content # 文章太长，截断按钮文字 excerpt_link: more # 文章卡片右下角常驻链接，不需要请设置为false show_all_link: &#39;展开全文&#39; # 数学公式 mathjax: false # 是否在新窗口打开链接 open_in_new: false # 打赏 # 打赏type设定：0-关闭打赏； 1-文章对应的md文件里有reward:true属性，才有打赏； 2-所有文章均有打赏 reward_type: 0 # 打赏wording reward_wording: &#39;谢谢你请我吃糖果&#39; # 支付宝二维码图片地址，跟你设置头像的方式一样。比如：/assets/img/alipay.jpg alipay: # 微信二维码图片地址 weixin: # 目录 # 目录设定：0-不显示目录； 1-文章对应的md文件里有toc:true属性，才有目录； 2-所有文章均显示目录 toc: 1 # 根据自己的习惯来设置，如果你的目录标题习惯有标号，置为true即可隐藏hexo重复的序号；否则置为false toc_hide_index: true # 目录为空时的提示 toc_empty_wording: &#39;目录，不存在的…&#39; # 是否有快速回到顶部的按钮 top: true # Miscellaneous baidu_analytics: &#39;&#39; google_analytics: &#39;&#39; #路径为E:\\Blog\\source favicon: /assets/img/head.png #你的头像url 路径为E:\\Blog\\source avatar: /assets/img/face.jpg #是否开启分享 share_jia: true #评论：1、多说；2、网易云跟帖；3、畅言；4、Disqus；5、Gitment #不需要使用某项，直接设置值为false，或注释掉 #具体请参考wiki：https://github.com/litten/hexo-theme-yilia/wiki/ #1、多说 duoshuo: false #2、网易云跟帖 wangyiyun: false #3、畅言 changyan_appid: false changyan_conf: false #4、Disqus 在hexo根目录的config里也有disqus_shortname字段，优先使用yilia的 disqus: false #5、Gitment gitment_owner: false #你的 GitHub ID gitment_repo: &#39;&#39; #存储评论的 repo gitment_oauth: client_id: &#39;&#39; #client ID client_secret: &#39;&#39; #client secret # 样式定制 - 一般不需要修改，除非有很强的定制欲望… style: # 头像上面的背景颜色 header: &#39;#4d4d4d&#39; # 右滑板块背景 slider: &#39;linear-gradient(200deg,#a0cfe4,#e8c37e)&#39; # slider的设置 slider: # 是否默认展开tags板块 showTags: false # 智能菜单 # 如不需要，将该对应项置为false # 比如 #smart_menu: # friends: false smart_menu: innerArchive: &#39;所有文章&#39; friends: &#39;友链&#39; aboutme: &#39;关于我&#39; friends: 友情链接: # aboutme: # 注：可以根据这个自己修改，记得保存 6 部署6.1 安装Git插件 1 为Hexo安装Git插件 npm install hexo-deployer-git --save 2 修改根目录下的 _config.yml 配置文件。 deploy: type: git repository: https://github.com/yanxin152133/yanxin152133.github.io.git branch: master 6.2 部署 1 打开Git，输入： hexo d 2 成功的标志","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/categories/Hexo/"},{"name":"搭建","slug":"Hexo/搭建","permalink":"http://yoursite.com/categories/Hexo/搭建/"}],"tags":[{"name":"GitHub Hexo 个人博客","slug":"GitHub-Hexo-个人博客","permalink":"http://yoursite.com/tags/GitHub-Hexo-个人博客/"}]},{"title":"Rocket.chat","slug":"Docker搭建Rocket.chat","date":"2019-05-26T03:54:06.931Z","updated":"2019-03-23T05:01:07.832Z","comments":true,"path":"2019/05/26/Docker搭建Rocket.chat/","link":"","permalink":"http://yoursite.com/2019/05/26/Docker搭建Rocket.chat/","excerpt":"Docker 搭建 Rocket.chat","text":"Docker 搭建 Rocket.chat 安装 Docker 参考 Ubuntu 安装 Docker Rocket.chat 搭建获取镜像请输入以下命令： docker pull rocket.chat 启动 首先启动一个mongo实例 docker run --name db -d mongo:3.0 --smallfiles 启动Rocket.chat链接到这个mongo实例 docker run --name rocketchat --link db -d rocket.chat 如果想直接在主机上的标准端口访问实例 docker run --name rocketchat -p 80:3000 --env ROOT_URL=http://localhost --link db -d rocket.chat","categories":[{"name":"Docker","slug":"Docker","permalink":"http://yoursite.com/categories/Docker/"},{"name":"Rocket.chat","slug":"Docker/Rocket-chat","permalink":"http://yoursite.com/categories/Docker/Rocket-chat/"}],"tags":[{"name":"Rocket.chat","slug":"Rocket-chat","permalink":"http://yoursite.com/tags/Rocket-chat/"}]},{"title":"deepin","slug":"deepin","date":"2019-05-26T03:54:06.918Z","updated":"2019-03-21T04:16:23.111Z","comments":true,"path":"2019/05/26/deepin/","link":"","permalink":"http://yoursite.com/2019/05/26/deepin/","excerpt":"Deepin无线网络极慢的解决方案初次安装，出现无线网络网速极慢的状况。","text":"Deepin无线网络极慢的解决方案初次安装，出现无线网络网速极慢的状况。 更改文件参数vim /etc/modprobe.d/iwlwifi.conf 将该文件中的11n_disable=1改为11n_disable=8 驱动安装查看驱动型号输入以下命令 lspci|grep Wireless 例如下图中的型号： 型号为：Intel Corporation Intel Dual Band Wireless-AC 3165 Plus Bluetooth (rev 99) 下载相对应的驱动下载地址：英特尔® 无线适配器的 Linux* 支持 安装输入以下命令： tar -zxvf iwlwifi-7265-ucode-25.30.14.0.tgz sudo cp iwlwifi-*.ucode /lib/firmware sudo reboot 一般情况下是可以解决该问题的。 electorn-ssr下载地址下载地址：electron-ssr也可以根据喜好自己下载：列表 配置一般情况下安装后是无法使用electron-ssr的，需要进行配置。如图（二选一即可）： node.js安装主要讲两个方式： 第一种方式下载下载地址：node.js根据个人习惯进行下载。 安装输入以下命令： tar xvJf node-v10.15.3-linux-x64.tar.xz //解压 cd node-v10.15.3-linux-x64/bin/ ./node -v 设置全局ln -s /home/kun/mysofltware/node-v0.10.28-linux-x64/bin/node /usr/local/bin/node ln -s /home/kun/mysofltware/node-v0.10.28-linux-x64/bin/npm /usr/local/bin/npm # /home/kun/mysofltware/node-v0.10.28-linux-x64/bin/node为自己存放文件的地址 /usr/local/bin/npm和/usr/local/bin/node不需要更改 第二种方式通过命令进行安装，输入以下命令： sudo apt-get install nodejs sudo apt-get install npm 配置Clion更新sudo apt update gcc、g++sudo apt-get install build-essential sudo apt-get install g++ 设置环境变量 sudo vim /etc/profile ## 将以下内容填写进去 export CC=/usr/bin/gcc export CXX=/usr/bin/g++ 验证是否安装成功 gcc --version g++ --version cmake下载下载列表：cmake下载地址:[cmake-3.11.3.tar.gz]https://cmake.org/files/v3.11/cmake-3.11.3.tar.gz 安装新建一个“cmake”目录 cd /home mkdir Cmake 解压 cd /home/Cmake tar -xzvf cmake-3.11.3.tar.gz 进入cmake 目录 cd cmake-3.11.3 编译安装 ### 最好使用root用户 ./bootstrap &amp;&amp; make &amp;&amp; make install 验证是否安装成功 cmake -version 配置Clion如图所示： deepin下idea中文异常输入以下命令 su passwd aptitude search uming aptitude install fonts-arphic-uming 之后重新启动idea（Netbeans也适用） 安装 Docker参考链接：deepin安装Docker Android Studio: /dev/kvm device permission denied安装 qemu-kvm输入以下命令： sudo apt install qemu-kvm 检查/dev/kvm 使用的所有权输入以下命令： ls -al /dev/kvm 结果为： crw-rw---- 1 root kvm 10, 232 3月 11 10:36 /dev/kvm 检查组中的用户kvm，使用： grep kvm /etc/group 添加用户到kvm中，请使用： sudo adduser yourname kvm 再检查 grep kvm /etc/group 最后重启或注销。","categories":[{"name":"deepin","slug":"deepin","permalink":"http://yoursite.com/categories/deepin/"},{"name":"配置","slug":"deepin/配置","permalink":"http://yoursite.com/categories/deepin/配置/"}],"tags":[{"name":"deepin","slug":"deepin","permalink":"http://yoursite.com/tags/deepin/"}]},{"title":"CentOS7+Hadoop-2.9.2+Hbase-1.4.9+MapReduce编程","slug":"CentOS 7+Hadoop-2.9.2+Hbase-1.4.9+MapReduce编程","date":"2019-05-26T03:54:06.907Z","updated":"2019-01-10T07:47:41.000Z","comments":true,"path":"2019/05/26/CentOS 7+Hadoop-2.9.2+Hbase-1.4.9+MapReduce编程/","link":"","permalink":"http://yoursite.com/2019/05/26/CentOS 7+Hadoop-2.9.2+Hbase-1.4.9+MapReduce编程/","excerpt":"所用软件及环境 Centos 7 jdk1.8.0_181 hadoop-2.9.2 Hbase-1.4.9 idea U","text":"所用软件及环境 Centos 7 jdk1.8.0_181 hadoop-2.9.2 Hbase-1.4.9 idea U 注：全程使用root用户 规划 组件 版本 路径 jdk 1.8.0_181 /usr/local/java Hadoop 2.9.2 /usr/local/hadoop Hbase 1.4.9 /usr/local/hbase 节点 node01 node02 node03 注：节点IP根据实际情况自行配置 Hadoop、jdk、Hbase下载下载地址点击即可下载 Hadoop-2.9.2jdk-1.8.0_181Hbase-1.4.9 配置1.主机名修改 在node01上输入 hostnamectl --static set-hostname node01 2.添加各个节点的IP输入： vim /etc/hosts 添加各个节点信息 &lt;!-- 下列的IP需根据自己的主机确定，不唯一 --&gt; 192.168.130.130 node01 192.168.130.133 node02 192.168.130.135 node03 3.防火墙设置 若主机中未安装iptables,执行以下命令进行安装 yum install iptables-services 执行iptables -L -n -v命令可以查看iptables配置，执行以下命令永久关闭主机的iptables： chkconfig iptables off 同时关闭主机的iptables和firewalld并设置开机不启动，执行以下命令： systemctl stop iptables systemctl disable iptables systemctl stop firewalld systemctl disable firewalld 执行systemctl status iptables和systemctl status firewalld可以查看防火墙已经关闭。 4.时钟同步 执行以下命令安装ntdate yum install ntpdate 执行以下命令同步时针 ntpdate us.pool.ntp.org 添加时针同步的定时任务，执行以下命令 crontab -e 接着输入以下内容，设置每天凌晨5点同步时针 0 5 * * * /usr/sbin/ntpdate cn.pool.ntp.org 执行以下命令重启服务并设置开机自启： service crond restart systemctl enable crond.service 5.SSH免密登录 首先执行以下以下命令，可以生成.ssh隐藏文件夹 ssh localhost 接着执行 cd .ssh ssh-keygen -t rsa #遇到提示一路回车就行 ll #会看到 id_rsa id_rsa.pub 两文件前为私钥，后为公钥 cat id_rsa.pub &gt;&gt; authorized_keys #把公钥内容追加到authorized_keys文件中 chmod 600 authorized_keys #修改文件权限，重要不要忽略 在最后的克隆node01得到的node02,node03主机以及node01上可通过ssh node01/node02/node03/node04测试是否可以免密登录若能连接即为成功 6.安装并配置jdk 通过 git 将已下载好的jdk1.8.0_181 发送给各个节点，执行以下命令 cd C:/Users//Yan/Downloads #C:/Users//Yan/Downloads为本人jdk1.8.0_181下载后的路径 scp jdk1.8.0_181 root@192.168.130.130:/usr/local/java #输入密码后即可将jdk1.8.0_181发送给node01,192.168.130.130为自己node01的IP cd /usr/local/java进入该目录后执行 tar -zxvf jdk-8u181-linux-x64.tar.gz 添加环境变量,执行 vim /etc/profile 添加以下配置 export JAVA_HOME=/usr/local/java/jdk1.8.0_181 export JRE_HOME=$JAVA_HOME/jre export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar export PATH=.:$JAVA_HOME/bin:$PATH 之后执行以下命令使配置生效 source /etc/profile 可通过 java -version 查看jdk版本 安装 Hadoop 并配置 执行以下命令 cd /usr/local/hadoop tar -zxvf hadoop-2.9.2.tar.gz #解压 添加环境变量,执行 vim /etc/profile 在该文件中添加以下内容 export HADOOP_HOME=/usr/local/hadoop/hadoop-2.9.2 export PATH=$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbin 执行 source /etc/profile 使配置生效同时创建Hadoop相关配置目录 mkdir -p /data/hadoop/hdfs/name /data/hadoop/hdfs/data /var/log/hadoop/tmp 修改相关文件 执行以下命令 cd /usr/local/hadoop/hadoop-2.9.2/etc/hadoop hadoop-env.shexport JAVA_HOME=/usr/local/java/jdk1.8.0_181 #一定要写真实路径 core-site.xml&lt;configuration&gt; &lt;!-- define the default file system host and port --&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://node01:9000/&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; hdfs-site.xml&lt;configuration&gt; &lt;!-- set namenode storage path--&gt; &lt;!-- storage node info --&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt; &lt;value&gt;file:///root/hdfs/namenode&lt;/value&gt; &lt;description&gt;NameNode directory for namespace and transaction logs storage.&lt;/description&gt; &lt;/property&gt; &lt;!-- set datanode storage path--&gt; &lt;!-- storage data --&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt; &lt;value&gt;file:///root/hdfs/datanode&lt;/value&gt; &lt;description&gt;DataNode directory&lt;/description&gt; &lt;/property&gt; &lt;!-- set the number of copies, default 3, reset to 2 --&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;2&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; mapred-site.xml&lt;configuration&gt; &lt;!-- specify the frame name --&gt; &lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; slavesnode02 node03 node04 yarn-site.xml&lt;configuration&gt; &lt;!-- Ancillary services running on the NodeManager. You need to configure &quot;mapreduce_shuffle&quot; to run the MapReduce program. --&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt; &lt;/property&gt; &lt;!-- The class corresponding to the auxiliary service in the NodeManager. --&gt; &lt;!-- &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services.mapreduce_shuffle.class&lt;/name&gt; &lt;value&gt;org.apache.hadoop.mapred.ShuffleHandler&lt;/value&gt; &lt;/property&gt; --&gt; &lt;!-- Configuration name node --&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt; &lt;value&gt;node01&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; 启动 Hadoop初始化 执行以下命令 cd /usr/local/hadoop/hadoop-2.9.2/bin ./hdfs namenode -format 等待一会后，不报错返回 “Exiting with status 0” 为成功，“Exiting with status 1”为失败切勿多次执行 克隆 对node01进行克隆操作进而得到node02,node03,node04修改node02,node03,node04的主机名，以及检查/etc/hosts文件中的各个节点对应的IP地址是否有误同时也要检查自己配置的/etc/profile文件是否已经生效 启动Hadoop输入以下命令 sudo -s #若是root用户可省略 cd /usr/local/hadoop/hadoop-2.9.2/sbin ./start-all.sh 查看Hadoop进程输入命令jps若出现6个进程则为配置正确在浏览器输入192.168.130.130：8088则可以看到在浏览器输入192.168.130.130：50070则可以看到即配置成功 停止Hadoop./stop-all.sh #在/usr/local/hadoop/hadoop-2.9.2/sbin目录下 安装 Hbase 并配置 执行以下命令 cd /usr/local/hbase/ &lt;!-- 解压 --&gt; tar -zxvf hbase-1.4.9-bin.tar.gz &lt;!-- 创建目录 --&gt; cd hbase-1.4.9/ mkdir logs mkdir pids mkdir tmp 配置/etc/profileexport HBASE_HOME=/usr/local/hbasehbase-1.4.9 export PATH=$HBASE_HOME/bin:$PATH source /etc/profile #使配置立即生效 hbase-env.sh#内容 export JAVA_HOME=/usr/local/java/jdk1.8.0_181 export HBASE_CLASSPATH=/usr/local/hbase/hbase-1.4.9/conf # 此配置信息，设置由hbase自己管理zookeeper，不需要单独的zookeeper。 export HBASE_MANAGES_ZK=true export HBASE_HOME=/usr/local/hbase/hbase-1.4.9 export HADOOP_HOME=/usr/local/hadoop/hadoop-2.9.2 #Hbase日志目录 export HBASE_LOG_DIR=/usr/local/hbase/hbase-1.4.9/logs hbase-site.xml&lt;configuration&gt; &lt;property&gt; &lt;name&gt;hbase.rootdir&lt;/name&gt; &lt;value&gt;hdfs://node01:9000/hbase&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.cluster.distributed&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.master&lt;/name&gt; &lt;value&gt;node01:60000&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt; &lt;value&gt;node01:2181,node02:2181,node03:2181&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; regionserversnode01 node02 node03 拷贝给其他节点scp -r /usr/local/hbase root@node02:/usr/local/ scp -r /usr/local/hbase root@node03:/usr/local/ 启动HBase在node01上启动 执行 cd /usr/local/hbase/hbase-1.4.9/bin ./start-hbase.sh 验证 在每个节点使用jps命令查看 node01上是否有HMaster进程node02,node03上是否有HRegionServer进程 通过node:16010查看HBase集群相关情况,如下图所示： 500 为初始化，稍等即可 wordcount 输入以下命令(root用户下) cd /home/hadoop #hadoop为自己创建的用户名，不固定 touch README.txt vim README.txt #下面为README.txt的内容 hello c hello java hello python hadoop fs -mkdir /wordcount hadoop fs -mkdir /wordcount/input hadoop fs -put /home/hadoop/README.txt /wordcount/input cd /usr/local/hadoop/hadoop-2.9.2/share/hadoop/mapreduce/ hadoop jar hadoop-mapreduce-examples-2.9.2.jar wordcount /wordcount/input /wordcount/output 出现以下信息即为成功： 2018-12-29 20:38:15,997 INFO mapreduce.Job: map 100% reduce 0% 2018-12-29 20:38:24,174 INFO mapreduce.Job: map 100% reduce 100% 2018-12-29 20:38:28,259 INFO mapreduce.Job: Job job_1546086772385_0001 completed successfully 2018-12-29 20:38:29,164 INFO mapreduce.Job: Counters: 55 File System Counters FILE: Number of bytes read=50 FILE: Number of bytes written=429541 FILE: Number of read operations=0 FILE: Number of large read operations=0 FILE: Number of write operations=0 HDFS: Number of bytes read=144 HDFS: Number of bytes written=28 HDFS: Number of read operations=8 HDFS: Number of large read operations=0 HDFS: Number of write operations=2 Job Counters Failed map tasks=3 Launched map tasks=4 Launched reduce tasks=1 Other local map tasks=3 Data-local map tasks=1 Total time spent by all maps in occupied slots (ms)=38093 Total time spent by all reduces in occupied slots (ms)=5732 Total time spent by all map tasks (ms)=38093 Total time spent by all reduce tasks (ms)=5732 Total vcore-milliseconds taken by all map tasks=38093 Total vcore-milliseconds taken by all reduce tasks=5732 Total megabyte-milliseconds taken by all map tasks=39007232 Total megabyte-milliseconds taken by all reduce tasks=5869568 Map-Reduce Framework Map input records=5 Map output records=6 Map output bytes=56 Map output materialized bytes=50 Input split bytes=110 Combine input records=6 Combine output records=4 Reduce input groups=4 Reduce shuffle bytes=50 Reduce input records=4 Reduce output records=4 Spilled Records=8 Shuffled Maps =1 Failed Shuffles=0 Merged Map outputs=1 GC time elapsed (ms)=152 CPU time spent (ms)=2050 Physical memory (bytes) snapshot=517804032 Virtual memory (bytes) snapshot=5624598528 Total committed heap usage (bytes)=336592896 Peak Map Physical memory (bytes)=293904384 Peak Map Virtual memory (bytes)=2790219776 Peak Reduce Physical memory (bytes)=223899648 Peak Reduce Virtual memory (bytes)=2834378752 Shuffle Errors BAD_ID=0 CONNECTION=0 IO_ERROR=0 WRONG_LENGTH=0 WRONG_MAP=0 WRONG_REDUCE=0 File Input Format Counters Bytes Read=34 File Output Format Counters Bytes Written=28 查看统计结果 hdfs dfs -ls /wordcount/output hdfs dfs -cat /wordcount/output/part-r-00000 MapReduce编程pom.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.hadoop&lt;/groupId&gt; &lt;artifactId&gt;wordcount&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;commons-beanutils&lt;/groupId&gt; &lt;artifactId&gt;commons-beanutils&lt;/artifactId&gt; &lt;version&gt;1.9.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-common&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-hdfs&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-mapreduce-client-common&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-mapreduce-client-core&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; src/main/java/WordcountMapper.javaimport org.apache.hadoop.io.IntWritable; import org.apache.hadoop.io.LongWritable; import org.apache.hadoop.io.Text; import org.apache.hadoop.mapreduce.Mapper; import java.io.IOException; /** * Created by zxk on 2017/6/29. */ public class WordcountMapper extends Mapper&lt;LongWritable, Text, Text, IntWritable&gt; { protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException { //得到输入的每一行数据 String line = value.toString(); //通过空格分隔 String[] words = line.split(&quot; &quot;); //循环遍历输出 for (String word : words) { context.write(new Text(word), new IntWritable(1)); } } } src/main/java/WordcountReducer.javaimport org.apache.hadoop.io.IntWritable; import org.apache.hadoop.io.Text; import org.apache.hadoop.mapreduce.Reducer; import java.io.IOException; /** * Created by zxk on 2017/6/29. */ public class WordcountReducer extends Reducer&lt;Text, IntWritable, Text, IntWritable&gt; { protected void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context) throws IOException, InterruptedException { Integer count = 0; for (IntWritable value : values) { count += value.get(); } context.write(key, new IntWritable(count)); } } src/main/java/WordCountMapReduce.java import org.apache.hadoop.conf.Configuration; import org.apache.hadoop.fs.Path; import org.apache.hadoop.io.IntWritable; import org.apache.hadoop.io.Text; import org.apache.hadoop.mapreduce.Job; import org.apache.hadoop.mapreduce.lib.input.FileInputFormat; import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat; /** * Created by zxk on 2017/6/29. */ public class WordCountMapReduce { public static void main(String[] args) throws Exception { //创建配置对象 Configuration conf = new Configuration(); //创建job对象 Job job = Job.getInstance(conf, &quot;wordcount&quot;); //设置运行job的类 job.setJarByClass(WordCountMapReduce.class); //设置mapper 类 job.setMapperClass(WordcountMapper.class); //设置reduce 类 job.setReducerClass(WordcountReducer.class); //设置map输出的key value job.setMapOutputKeyClass(Text.class); job.setMapOutputValueClass(IntWritable.class); //设置reduce 输出的 key value job.setOutputKeyClass(Text.class); job.setOutputValueClass(IntWritable.class); //设置输入输出的路径 FileInputFormat.setInputPaths(job, new Path(args[0])); FileOutputFormat.setOutputPath(job, new Path(args[1])); //提交job boolean b = job.waitForCompletion(true); if (!b) { System.out.println(&quot;wordcount task fail!&quot;); } } } 编译打包 在idea中打jar包可以参考这里 点击 运行&lt;!-- 一些命令与worcount命令相同不再重复 --&gt; hadoop jar hadoop-demo.jar WordCountMapReduce /wordcount/input /wordcount/output 参考 在centos7上搭建hadoop集群CentOS 7搭建Apache Hadoop 3.1.1集群Linux上安装Hadoop集群(CentOS7+hadoop-2.8.0)Centos7虚拟机 搭建 Hadoop3.1.1 教程CentOS 7下安装集群HBase1.2.4windows下idea编写WordCount程序，并打jar包上传到hadoop集群运行 推荐 使用 Docker 搭建 Hadoop 集群","categories":[{"name":"大数据","slug":"大数据","permalink":"http://yoursite.com/categories/大数据/"},{"name":"Hadoop Hbase MapReduce编程","slug":"大数据/Hadoop-Hbase-MapReduce编程","permalink":"http://yoursite.com/categories/大数据/Hadoop-Hbase-MapReduce编程/"}],"tags":[{"name":"大数据","slug":"大数据","permalink":"http://yoursite.com/tags/大数据/"},{"name":"Hadoop Hbase MapReduce编程","slug":"Hadoop-Hbase-MapReduce编程","permalink":"http://yoursite.com/tags/Hadoop-Hbase-MapReduce编程/"}]},{"title":"bugzilla","slug":"buzilla","date":"2019-05-26T03:54:06.886Z","updated":"2019-05-22T11:11:34.904Z","comments":true,"path":"2019/05/26/buzilla/","link":"","permalink":"http://yoursite.com/2019/05/26/buzilla/","excerpt":"bugzilla准备 系统：Windows 7 MySql 5.5.62及以上 Bugzilla 4.2及以上 ActivePerl 5.24.3.2404及以上 XAMPP 7.1.29及以上","text":"bugzilla准备 系统：Windows 7 MySql 5.5.62及以上 Bugzilla 4.2及以上 ActivePerl 5.24.3.2404及以上 XAMPP 7.1.29及以上 下载MySql 5.5.62下载地址：MySql 5.5.62 Bugzilla 4.2下载地址：Bugzilla 4.2 ActivePerl 5.24.3.2404下载地址：ActivePerl 5.24.3.2404 XAMPP 7.1.29下载地址：XAMPP 7.1.29 安装XAMPP 7.1.29参考：https://www.jianshu.com/p/07455416d68c ActivePerl 5.24.3.2404双击activeperl安装界面，一直点击next直至完成安装，activeperl的选项都是默认的选项，依照默认安装即可。 验证perl是否安装成功cmd界面运行perl -v，出现版本号即为成功。如下图： MySql 5.5.62步骤大致如下图： 路径设置为C:\\MySql,因为Bugzilla默认的引导路径为这个。 Bugzilla 4.2 解压Bugzilla 4.2文件，将解压后的内容复制到C:\\xampp\\htdocs\\bugzilla文件夹下，若没有则先建一个文件夹。 win+R 打开cmd窗口，同时进入到C:\\xampp\\htdocs\\bugzilla目录下。 输入checksetup.pl命令。如下图： 安装perl模块，使用perl install XXX进行安装未安装的perl模块。如下图所示： 可能会有一些模块无法安装，可以直接忽略。再次运行checksetup.pl命令，可能会需要安装DDB-MySql这个模块，安装之后再次运行checksetup.pl命令，出现下图则未成功。 编辑C:\\xampp\\htdocs\\bugzilla下的localconfig文件。 打开localconfig文件，将其中的$db_port = 0;改为$db_port = 3306; $index_html = 0;改为$index_html = 1。 打开MySQL 5.5 Command Line Client。下面在MySQL服务器中创建一个bugs数据库，和一个bugs用户，以及为该用户授予相应的权限，命令如下：create database bugs; 创建一个数据库bugscreate user bugs@localhost; 创建一个用户bugsgrant all on bugs.* to bugs@’localhost’; 为用户bugs授权flush privileges; 刷新用户权限 在命令行下再次运行checksetup.pl将会生成和数据库有关的数据表。但是可能会出现报错，显示的是无法找到什么什么的表，这时候只需要把上一步创建的数据库bugs删除再重新创建即可，若无法解决自行查找资料。生成数据表后会要求填入主机的地址服务器地址，管理员名字和账号（该账号是一个email地址）以及管理员登陆的密码。（自由发挥） 将C:\\xampp\\htdocs\\bugzilla下的后缀名为.cgi的文件中的 #!/usr/bin/perl 改为#!”C:\\Perl64\\bin\\perl.exe”。 运行打开XAMPP界面的Apache,在浏览器中输入http://localhost/bugzilla。","categories":[{"name":"软件缺陷","slug":"软件缺陷","permalink":"http://yoursite.com/categories/软件缺陷/"},{"name":"bugzilla","slug":"软件缺陷/bugzilla","permalink":"http://yoursite.com/categories/软件缺陷/bugzilla/"}],"tags":[{"name":"软件缺陷","slug":"软件缺陷","permalink":"http://yoursite.com/tags/软件缺陷/"},{"name":"bugzilla","slug":"bugzilla","permalink":"http://yoursite.com/tags/bugzilla/"}]},{"title":"BugFree安装","slug":"BugFree","date":"2019-05-26T03:54:06.865Z","updated":"2019-04-22T14:06:59.994Z","comments":true,"path":"2019/05/26/BugFree/","link":"","permalink":"http://yoursite.com/2019/05/26/BugFree/","excerpt":"BugFree准备工作：（Windows环境下） XAMPP 版本在5.x.x bugfree_v3.0.1 不要用最新版本的XAMPP，切记。","text":"BugFree准备工作：（Windows环境下） XAMPP 版本在5.x.x bugfree_v3.0.1 不要用最新版本的XAMPP，切记。 下载XAMPP bugfree提取码: ff5d XAMPP 安装双击exe文件傻瓜式安装。 安装 bugfree1.在上一步安装XAMPP时路径C:\\xampp\\htdocs\\下新建文件夹bugfree,将下载bugfree文件解压后的内容复制进去。同时在新建一个BugFile文件夹，用于下一步操作。2.打开XAMPP主界面上的前两个start按钮。3.打开浏览器输入localhost/bugfree,如下图： 4.上图中的全部为绿色的勾勾仅为成功。然后点击继续。5.按照下图中进行配置。 6.然后修改C:\\xampp\\htdocs\\bugfree\\protected\\config中的main.php。全部替换即可。 &lt;?php return array ( &#39;basePath&#39; =&gt; &#39;C:\\\\xampp\\\\htdocs\\\\bugfree\\\\protected\\\\config\\\\..&#39;, &#39;name&#39; =&gt; &#39;BugFree 3.0.1&#39;, &#39;preload&#39; =&gt; array ( 0 =&gt; &#39;log&#39;, ), &#39;language&#39; =&gt; &#39;zh_cn&#39;, &#39;theme&#39; =&gt; &#39;classic&#39;, &#39;defaultController&#39; =&gt; &#39;site&#39;, &#39;timeZone&#39; =&gt; &#39;Asia/Shanghai&#39;, &#39;import&#39; =&gt; array ( 0 =&gt; &#39;application.models.*&#39;, 1 =&gt; &#39;application.components.*&#39;, 2 =&gt; &#39;application.service.*&#39;, ), &#39;modules&#39; =&gt; array ( &#39;gii&#39; =&gt; array ( &#39;class&#39; =&gt; &#39;system.gii.GiiModule&#39;, &#39;password&#39; =&gt; &#39;123456&#39;, &#39;ipFilters&#39; =&gt; array ( 0 =&gt; &#39;127.0.0.1&#39;, 1 =&gt; &#39;::1&#39;, ), ), ), &#39;components&#39; =&gt; array ( &#39;user&#39; =&gt; array ( &#39;allowAutoLogin&#39; =&gt; true, ), &#39;request&#39; =&gt; array ( &#39;enableCookieValidation&#39; =&gt; true, ), &#39;cache&#39; =&gt; array ( &#39;class&#39; =&gt; &#39;CDbCache&#39;, &#39;connectionID&#39; =&gt; &#39;db&#39;, ), &#39;db&#39; =&gt; array ( &#39;pdoClass&#39; =&gt; &#39;NestedPDO&#39;, &#39;connectionString&#39; =&gt; &#39;mysql:host=localhost;dbname=bugfree;port=3306&#39;, &#39;emulatePrepare&#39; =&gt; true, &#39;username&#39; =&gt; &#39;root&#39;, &#39;password&#39; =&gt; &#39;&#39;, &#39;charset&#39; =&gt; &#39;utf8&#39;, &#39;tablePrefix&#39; =&gt; &#39;bf_&#39;, ), &#39;errorHandler&#39; =&gt; array ( &#39;errorAction&#39; =&gt; &#39;site/error&#39;, ), &#39;log&#39; =&gt; array ( &#39;class&#39; =&gt; &#39;CLogRouter&#39;, &#39;routes&#39; =&gt; array ( 0 =&gt; array ( &#39;class&#39; =&gt; &#39;CFileLogRoute&#39;, &#39;levels&#39; =&gt; &#39;info, error, warning&#39;, &#39;categories&#39; =&gt; &#39;bugfree.*&#39;, ), ), ), ), &#39;params&#39; =&gt; array ( &#39;uploadPath&#39; =&gt; &#39;../BugFile&#39;, &#39;picPreviewApp&#39; =&gt; &#39;http://::1/BugFile&#39;, &#39;allUserGroupId&#39; =&gt; 1, &#39;ldap&#39; =&gt; array ( &#39;host&#39; =&gt; &#39;&#39;, &#39;port&#39; =&gt; &#39;&#39;, &#39;base&#39; =&gt; &#39;&#39;, &#39;user&#39; =&gt; &#39;&#39;, &#39;pass&#39; =&gt; &#39;&#39;, ), &#39;mail&#39; =&gt; array ( &#39;on&#39; =&gt; &#39;1&#39;, &#39;from_address&#39; =&gt; &#39;bugfree-noreply@test.com&#39;, &#39;from_name&#39; =&gt; &#39;BugFree&#39;, &#39;send_method&#39; =&gt; &#39;SMTP&#39;, &#39;send_params&#39; =&gt; array ( &#39;host&#39; =&gt; &#39;&#39;, &#39;smtp_auth&#39; =&gt; false, &#39;username&#39; =&gt; &#39;&#39;, &#39;password&#39; =&gt; &#39;&#39;, ), ), ), ) ?&gt; 7.刷新之后就会出现登录界面。","categories":[{"name":"软件缺陷","slug":"软件缺陷","permalink":"http://yoursite.com/categories/软件缺陷/"},{"name":"BugFree","slug":"软件缺陷/BugFree","permalink":"http://yoursite.com/categories/软件缺陷/BugFree/"}],"tags":[{"name":"软件缺陷","slug":"软件缺陷","permalink":"http://yoursite.com/tags/软件缺陷/"},{"name":"BugFree","slug":"BugFree","permalink":"http://yoursite.com/tags/BugFree/"}]},{"title":"Android studio安装","slug":"Android studio安装","date":"2019-05-26T03:54:06.827Z","updated":"2018-11-07T09:47:10.000Z","comments":true,"path":"2019/05/26/Android studio安装/","link":"","permalink":"http://yoursite.com/2019/05/26/Android studio安装/","excerpt":"准备 1.配置环境变量 2.安装 3.创建HelloWorld","text":"准备 1.配置环境变量 2.安装 3.创建HelloWorld 配置环境变量 为什么首先要配置环境变量呢？配置环境变量可以防止之后Android studio安装SDK时安装到默认位置，减少C盘的占用空间。 新建 变量名 ANDROID_HOME ，值为 自己创建的放置SDK的路径 安装 首先下载 Android studio &gt;下载完成直接打开。 如果不想安装到C盘也可以选择其他的。 等待一段时间。 点击 cancle 选择喜欢的主题 之后就是漫长的等待… 等待总会有结果的。 创建第一个 Android 程序 HelloWorld 点击上图中的 Start a new Android Studio project Application name 填写 HelloWorldCompany domain 按照系统默认的就行Project location 存放自己代码的位置，可自定义。 系统默认即可 一般选择 Empty Activity 点击 Finish。 等待红线部分加载完毕。加载完成后点击工具栏-Bulid—Bulid Bundle(s)/APK(s)-Bulid APK(s)。之后可以选择自己手机运行自己的程序。也可以选择下图中的自行安装模拟器运行。 之后再补充…","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"Android studio安装","slug":"Android/Android-studio安装","permalink":"http://yoursite.com/categories/Android/Android-studio安装/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Android studio安装","slug":"Android-studio安装","permalink":"http://yoursite.com/tags/Android-studio安装/"}]}]}