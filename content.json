{"meta":{"title":"Yan's blog","subtitle":null,"description":null,"author":"Yan","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2019-05-02T03:51:18.000Z","updated":"2019-05-02T03:52:19.545Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-05-02T03:51:26.000Z","updated":"2019-05-02T03:52:17.154Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"解决git clone速度慢的问题","slug":"解决git clone速度慢的问题","date":"2019-07-16T12:12:59.244Z","updated":"2019-07-17T07:05:14.312Z","comments":true,"path":"2019/07/16/解决git clone速度慢的问题/","link":"","permalink":"http://yoursite.com/2019/07/16/解决git clone速度慢的问题/","excerpt":"解决方案","text":"解决方案 1. 在git内部设置代理 命令行 12git config --global http.proxy socks5://127.0.0.1:1080git config --global https.proxy socks5://127.0.0.1:1080 直接编辑相关文件 C:\\Users\\用户名文件夹下的 .gitconfig,点击打开。将以下内容添加进去。1234[http] proxy = socks5://127.0.0.1:1080[https] proxy = socks5://127.0.0.1:1080 2. 注意下载时是否是https3. 在使用代理下载时，会遇到git push需要每次输入密码。通过以下方式解决该问题。 设置记住密码（默认15分钟）： 1git config --global credential.helper cache 如果想自己设置时间，可以这样做： 1git config credential.helper 'cache --timeout=3600' 这样就设置一个小时之后失效 长期存储密码：1git config --global credential.helper store 参考 提高 git clone 速度 git设置代理、记住密码","categories":[{"name":"git","slug":"git","permalink":"http://yoursite.com/categories/git/"},{"name":"git clone速度慢","slug":"git/git-clone速度慢","permalink":"http://yoursite.com/categories/git/git-clone速度慢/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"git clone速度慢","slug":"git-clone速度慢","permalink":"http://yoursite.com/tags/git-clone速度慢/"}]},{"title":"Java基础","slug":"java基础","date":"2019-07-14T13:17:20.148Z","updated":"2019-07-18T14:36:35.929Z","comments":true,"path":"2019/07/14/java基础/","link":"","permalink":"http://yoursite.com/2019/07/14/java基础/","excerpt":"代码仓库地址欢迎下载：GitHub 运行环境： IntelliJ IDEA 2019.1.3(Ultimate Edition) jdk 1.8.0_211 Java 基础Java简介","text":"代码仓库地址欢迎下载：GitHub 运行环境： IntelliJ IDEA 2019.1.3(Ultimate Edition) jdk 1.8.0_211 Java 基础Java简介 Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程。 Java具有简单性、面向对象、分布式、健壮性、安全性、平台独立与可移植性、多线程、动态性等特点 。Java可以编写桌面应用程序、Web应用程序、分布式系统和嵌入式系统应用程序等。 详情 运行环境搭建下载JDK建议使用1.8及以上的版本。官方下载路径：jdk下载路地址 安装双击下载软件，一路单击下一步即可。 配置环境变量Windows：右击【我的电脑】→【属性】→【高级系统设置】→【环境变量】→【系统变量】→【新建】，接着如下图所示： 在【系统变量】的path中添加 %JAVA_HOME%\\bin。 验证，如下图所示： Hello World12345public class helloworld &#123; public static void main(String[] args) &#123; System.out.println(\"helloworld\"); &#125;&#125; Hello World 运行原理 工具Intellij IDEA下载路径：indea U 激活（针对学生的免费使用计划）参考：Intellij IDEA的下载和使用（针对学生的免费使用计划） 注释、标识符命名规则及Java中的关键字1. Java注释1231. 单行注释：//2. 多行注释：/*。。。。。*/3. 文档注释：/**。。。*/ 2. 标识符命名12345标识符定义：Java语言中，对于变量、常量、函数、语句块也有名字，我们统统称为Java标识符。标识符作用：标识符是用来给类、对象、方法、常量、接口和自定义数据类型命令的。 标识符命名规则：Java标识符由数字、字母和下划线（_），美元符号（$）组成。在Java中是区分大小写的，而且还要求首位不能是数字。最重要的是，Java关键字不能当作Java标识符。 3. Java关键字 访问控制 private protected public 类，方法和变量修饰符 abstract class extends final implements interface native new static strictfp synchronized transient volatile 程序控制 break continue return do while if else for instanceof switch case default 错误处理 try catch throw throws finally 包相关 import package 基本类型 boolean byte char double float int long short null true false 变量引用 super this void 保留字 goto const 参考：Java 关键字总结 Java基本数据类型1. 数据类型分类 2. 整数类型 序号 数据类型 大小/位 可表示的数据范围 1 byte(位) 8 -27到（26-1） 2 short(整型) 16 -215到（215-1） 3 int(整型) 32 -231到（231-1） 4 long(长整型) 64 -263到（263-1） Byte数据范围表示 符号位 1 1 1 1 1 1 1 1 符号位0表示正 范围 00000000~01111111符号位1表示负 范围 10000000~11111111（减一取反） 代码实例：12345678910111213141516171819202122232425262728293031323334353637package com.java1234.chap02;/** * @author Yan * @date 2019/7/15 13:53 */public class Demo1 &#123; public static void main(String[] args) &#123; //定义一个int类型的变量 int a; //给变量a赋值 a=1; System.out.println(a); //定义一个int类型的变量a2 int a2=1; System.out.println(\"a2=\"+a2); //定义一个byte类型的变量b byte b=3; System.out.println(\"b=\"+b); //定义一个short类型的变量 short s=4; System.out.println(\"s=\"+s); //定义一个long类型的变量l long l=5; System.out.println(\"l=\"+l); int a11=1; int a22=2; int a3=a11+a22; System.out.println(\"a1+a2=\"+a3); &#125;&#125; 3. 浮点类型 序号 数据类型 大小/位 可表示的数据范围 1 float(单精度) 32 -3.4E38(-3.4x1038) 到 3.4E38(3.4x1038)) 2 double(双精度) 64 -1.7E308(-1.7x10308) 到 1.7E308(1.7x10308)) 代码示例：12345678910111213141516171819202122232425package com.java1234.chap02;/** * @author Yan * @date 2019/7/15 14:10 */public class Demo2 &#123; public static void main(String[] args) &#123; //定义一个float类型的变量f //小数默认是double类型，所以必须加一个f,来表示float类型 float f=1.1f; System.out.println(\"f=\"+f); //定义一个double类型变量d double d=1.2; System.out.println(\"d=\"+d); //获取float的最大值 float maxF=Float.MAX_VALUE; System.out.println(\"float最大值：\"+maxF); //获取float的最小值 float minF=Float.MIN_VALUE; System.out.println(\"float最小值：\"+minF); &#125;&#125; 4. 字符型字符型常量有3种表示形式。char 1. 直接通过单个字符来指定字符型常量，如‘A’，‘b’，‘5’； 2. 通过转义字符表示特殊字符型常量，如‘\\n’,‘\\\\’; 3. 直接使用Unicode值来表示字符型常量，如‘\\u66f9’，‘\\yu950b’； 转义字符 说明 \\b 退格 \\n 换行 \\t 制表符 \\” 双引号 \\’ 单引号 \\ 反斜杠 \\r 回车符 代码示例:12345678910111213141516171819202122232425package com.java1234.chap02;/** * @author Yan * @date 2019/7/15 14:33 */public class Demo3 &#123; public static void main(String[] args) &#123; //定义一个单个字符 char c1='A'; System.out.println(\"c1=\"+c1); //定义一个反斜杠字符 char c2='\\\\'; System.out.println(\"c2=\"+c2); //用Unicode编码输出自己的名字 char c3='\\u66f9'; char c4='\\u950b'; System.out.println(\"c3=\"+c3); System.out.println(\"c4=\"+c4); &#125;&#125; 5. 布尔类型布尔类型的变量只有true(真)和false(假)两种。 12345678910111213141516package com.java1234.chap02;/** * @author Yan * @date 2019/7/15 14:51 */public class Demo4 &#123; public static void main(String[] args) &#123; //定义一个布尔类型变量b1 boolean b1=true; System.out.println(\"b1=\"+b1); //定义一个布尔类型变量b2 boolean b2=false; System.out.println(\"b2=\"+b2); &#125;&#125; 6. 基本类型的类型转换1. 自动类型转换 条件： 1. 转换前后的数据类型兼容； 2. 转换后的数据类型的表示范围要比转换前的大； 2. 强制类型转换 代码示例：123456789101112131415161718192021222324package com.java.chap03;/** * @author Yan * @date 2019/7/15 15:26 */public class Demo5 &#123; public static void main(String[] args) &#123; //自动类型转换 short s=1; int i; //自动类型转换 short类型转成int类型 i=s; System.out.println(\"i=\"+i); //强制类型转换 double d=1.333; float f; //把double类型的数据强制转换成float类型 f=(float) d; System.out.println(\"f=\"+f); &#125;&#125; Java运算符与表达式 1. 赋值运算符符号：=（赋值）12345678910111213141516171819package com.java.chap04;/** * @author Yan * @date 2019/7/16 13:01 */public class Demo1 &#123; public static void main(String[] args) &#123; //定义变量a int a; //给变量a赋值 a=1; System.out.println(\"a=\"+a); //定义变量a，并且给a赋值 int a2=2; System.out.println(\"a2=\"+a2); &#125;&#125; 2. 算数运算符符号：+（加），-（减），*（乘），/（除），%（取模）123456789101112131415161718192021222324252627package com.java.chap04;/** * @author Yan * @date 2019/7/16 13:07 */public class Demo2 &#123; public static void main(String[] args) &#123; int a=10; int b=3; //+运算符 System.out.println(a+\"+\"+b+\"=\"+(a+b)); //-运算符 System.out.println(a+\"-\"+b+\"=\"+(a-b)); //*运算符 System.out.println(a+\"*\"+b+\"=\"+(a*b)); // /运算符 System.out.println(a+\"/\"+b+\"=\"+(a/b)); //%运算符 System.out.println(a+\"%\"+b+\"=\"+(a%b)); &#125;&#125; 3. 自增与自减运算符符号：++（自增），–（自减）重点：a++和++a的区别12345678910111213141516171819202122package com.java.chap04;/** * @author Yan * @date 2019/7/16 13:13 */public class Demo3 &#123; public static void main(String[] args) &#123; int a = 1; //a++表示先做赋值操作，然后自增 /* int b=a++; System.out.println(\"b=\"+b); System.out.println(\"a=\"+a); */ //++a表示先自增，然后赋值操作 int b=++a; System.out.println(\"b=\"+b); System.out.println(\"a=\"+a); &#125;&#125; 4. 逻辑运算符符号：&amp;&amp;（与），&amp;（不短路与），||（或），|（不短路或），!(非)，^（亦或）123456789101112131415161718192021222324252627282930313233343536package com.java.chap04;/** * @author Yan * @date 2019/7/16 13:53 */public class Demo4 &#123; public static void main(String[] args) &#123; // &amp;&amp; 与 前后两个操作数必须都是true才返回true，否则返回false boolean b1 = (5 &lt; 3) &amp;&amp; (4 &gt; 5); System.out.println(\"b1 = \" + b1); //&amp; 不短路与 boolean b2 = (5 &lt; 3) &amp; (4 &gt; 5); System.out.println(\"b2 = \" + b2); //一般都使用 &amp;&amp; //原因：效率高 // || 或 只要两个操作数中有一个是true，就返回true，否则返回false boolean b3 = (2 &lt; 3) || (4 &gt; 5); System.out.println(\"b3 = \" + b3); // | 不短路或 boolean b4 = (2 &lt; 3) | (4 &gt; 5); System.out.println(\"b4 = \" + b4); // ! 非，如果操作数为true，返回false，否则返回true boolean b5 = !(3 &lt; 4); System.out.println(\"b5 = \" + b5); // ^ 异或 当两个操作数不相同时，返回true，否则返回false boolean b6 = (5 &gt; 4) ^ (4 &gt; 5); System.out.println(\"b6 = \" + b6); &#125;&#125; 5. 关系运算符符号：&gt;(大于)，&lt;(小于)，&gt;=（大于等于），&lt;=(小于等于)，==（等于），!=(不等于)12345678910111213141516171819202122232425262728293031package com.java.chap04;/** * @author Yan * @date 2019/7/16 14:22 */public class Demo5 &#123; public static void main(String[] args) &#123; int a = 2; int b = 3; // &gt; 大于 System.out.println(a + \"&gt;\" + b + \":\" + (a &gt; b)); // &lt; 小于 System.out.println(a + \"&lt;\" + b + \":\" + (a &lt; b)); // &gt;= 大于等于 System.out.println(a + \"&gt;=\" + b + \":\" + (a &gt;= b)); // &lt;= 小于等于 System.out.println(a + \"&lt;=\" + b + \":\" + (a &lt;= b)); // == 等于 System.out.println(a + \"==\" + b + \":\" + (a == b)); // != 不等于 System.out.println(a + \"!=\" + b + \":\" + (a != b)); &#125;&#125; 6. 三目运算符格式：（表达式）？表达式为true返回值A：表达式为false返回值B12345678910111213package com.java.chap04;/** * @author Yan * @date 2019/7/16 14:26 */public class Demo6 &#123; public static void main(String[] args) &#123; //三目运算符 String s=2&gt;3?\"表达式为真\":\"表达式为假\"; System.out.println(\"s = \" + s); &#125;&#125; Java选择与循环语句1. 程序的选择结构1. if 语句 2. if...else 语句 3. if...else if...else 语句 12345678910111213141516171819202122232425262728293031package com.java.chap05;/** * @author Yan * @date 2019/7/16 15:16 */public class Demo1 &#123; public static void main(String[] args) &#123; int a=-1; // if语句 if (a&gt;0)&#123; System.out.println(a+\"是正数\"); &#125; //if...else语句 if (a&gt;0)&#123; System.out.println(a+\"是正数\"); &#125;else &#123; System.out.println(a+\"不是正数\"); &#125; //if...else if...else if (a&gt;0)&#123; System.out.println(a+\"是正数\"); &#125;else if (a&lt;0)&#123; System.out.println(a+\"是负数\"); &#125;else&#123; System.out.println(a+\"是0\"); &#125; &#125;&#125; 4. switch 语句 123456789101112131415161718192021222324252627282930package com.java.chap05;import java.util.Scanner;/** * @author Yan * @date 2019/7/16 15:22 */public class Demo2 &#123; public static void main(String[] args) &#123; System.out.println(\"请输入一个数字\"); //定义一个系统输入对象 Scanner scanner=new Scanner(System.in); int n=scanner.nextInt(); //System.out.println(n); switch (n)&#123; case 1:&#123; System.out.println(\"用户输入的是1\"); break; &#125; case 2:&#123; System.out.println(\"用户输入的是2\"); break; &#125; default:&#123; System.out.println(\"用户输入的是其他数字\"); &#125; &#125; &#125;&#125; 2. 程序的循环结构1. while 循环 2. do...while 循环 3. for 循环 4. for 循环的嵌套 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.java.chap05;/** * @author Yan * @date 2019/7/16 15:31 */public class Demo3 &#123; public static void main(String[] args) &#123; //在控制台输出1到10 //while 循环语句 int i = 1; while (i &lt; 11) &#123; System.out.print(i + \" \"); i++; &#125; System.out.println(\"\\n-------------------\"); // do...while 循环语句 int j = 1; do &#123; System.out.print(j + \" \"); j++; &#125; while (j &lt; 11); System.out.println(\"\\n-------------------\"); //while和do...while的区别 //while是先判断后执行，do...while是先执行后判断 // for 循环 for (int k = 1; k &lt; 11; k++) &#123; System.out.printf(k + \" \"); &#125; System.out.println(\"\\n-------------------\"); // for循环的嵌套 for (int m = 0; m &lt; 10; m++) &#123; for (int n = 0; n &lt; 10; n++) &#123; System.out.print(\"m=\" + m + \"n=\" + n+\" \"); &#125; System.out.println(); &#125; &#125;&#125; 5. 求水仙花数 12345678910111213141516171819202122package com.java.chap05;/** * @author Yan * @date 2019/7/16 15:42 */public class Demo4 &#123; public static void main(String[] args) &#123; for (int i=100;i&lt;=999;i++)&#123; //求出百位数 int b=i/100; //求出十位数 int s=(i-b*100)/10; //求出个位数 int g=(i-b*100-s*10); if (i==g*g*g+s*s*s+b*b*b)&#123; System.out.println(i+\" \"); &#125; &#125; &#125;&#125; 3. 循环结构的控制1. break 语句 结束循环 1234567891011121314151617181920package com.java.chap05;/** * @author Yan * @date 2019/7/16 15:52 */public class Demo5 &#123; public static void main(String[] args) &#123; for (int i=0;i&lt;10;i++)&#123; for (int j=0;j&lt;10;j++)&#123; if (i==1)&#123; break; &#125; System.out.print(\"i=\"+i+\" j=\"+j+\" \"); &#125; System.out.println(); &#125; &#125;&#125; 123456789101112131415161718192021package com.java.chap05;/** * @author Yan * @date 2019/7/16 15:55 */public class Demo6 &#123; public static void main(String[] args) &#123; outer: for (int i=0;i&lt;10;i++)&#123; for (int j=0;j&lt;10;j++)&#123; if (i==1)&#123; break outer; &#125; System.out.print(\"i=\"+i+\" j=\"+j+\" \"); &#125; System.out.println(); &#125; &#125;&#125; 2. continue 语句 结束本次循环 12345678910111213141516package com.java.chap05;/** * @author Yan * @date 2019/7/16 15:57 */public class Demo7 &#123; public static void main(String[] args) &#123; for (int i=0;i&lt;10;i++)&#123; if (i==4)&#123; continue; &#125; System.out.print(\"i=\"+i+\" \"); &#125; &#125;&#125; 3. return 语句 结束方法 123456789101112131415161718192021package com.java.chap05;/** * @author Yan * @date 2019/7/16 15:59 */public class Demo8 &#123; public static void main(String[] args) &#123; for (int i=0;i&lt;10;i++)&#123; for (int j=0;j&lt;10;j++)&#123; if (i==1)&#123; return; &#125; System.out.print(\"i=\"+i+\" j=\"+j+\" \"); &#125; System.out.println(); &#125; System.out.println(\"执行到这里了\"); &#125;&#125; Java数组1. 数组简介数组是Java中最常见的一种数据结构，可用于存储多个数据。 2. 数组的定义1type[] arrayName;或者type arrayName[]; 实例：1int []arr; int arr[]; 123456789101112131415package com.java.chap06;/** * @author Yan * @date 2019/7/17 14:08 */public class Demo1 &#123; public static void main(String[] args) &#123; //定义一个数组 int []arr; //定义一个数组 int arr2[]; &#125;&#125; 3. 数组的初始化1. 静态初始化 格式1arrayName=new type[]&#123;element1,element2,element3.....&#125; 实例：1int arr1[]=new int[]&#123;1,2,3&#125;; 123456789101112131415161718192021222324package com.java.chap06;/** * @author Yan * @date 2019/7/17 14:14 */public class Demo2 &#123; public static void main(String[] args) &#123; //定义一个数组，并且静态初始化 int arr[]=new int[]&#123;1,2,3&#125;; //普通的遍历数组方式 for (int i=0;i&lt;arr.length;i++)&#123; System.out.println(arr[i]); &#125; System.out.println(\"------------\"); //foreach方法遍历数组 for (int j:arr)&#123; System.out.println(j); &#125; &#125;&#125; 2. 动态初始化 格式1arrayName=new type[length]; 实例：1int arr2[]=new int[3]; 1234567891011121314151617package com.java.chap06;/** * @author Yan * @date 2019/7/17 14:18 */public class Demo3 &#123; public static void main(String[] args) &#123; //定义一个数组，然后动态初始化，长度是3 int arr[]=new int[3]; for(int i:arr)&#123; System.out.println(i); &#125; &#125;&#125; 内存分析 4. 二维数组及多维数组二维数组静态化初始化 格式：1arrayName=new type[]&#123;&#123;element1,element2&#125;,&#123;element1,element2&#125;,&#123;element1,element2&#125;&#125;; 实例：1int[][]arr=new int[][]&#123;1,2,3&#125;,&#123;4,5,6&#125;,&#123;7,8,9&#125;&#125;; 二维数组动态初始化 格式：1arrayName=new type[length][length]; 实例：1int [][]arr2=new int[3][3]; 123456789101112131415161718192021222324252627282930313233package com.java.chap06;/** * @author Yan * @date 2019/7/17 14:35 */public class Demo4 &#123; public static void main(String[] args) &#123; //定义一个二维数组,并静态初始化 int [][]arr=new int[][]&#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;,&#123;7,8,9&#125;&#125;; //输出 for (int i=0;i&lt;arr.length;i++)&#123; for (int j=0;j&lt;arr[0].length;j++)&#123; System.out.print(arr[i][j]+\" \"); &#125; System.out.println(); &#125; //二维数组的动态初始化 int [][]arr2=new int[3][3]; for (int i=0;i&lt;arr2.length;i++)&#123; for (int j=0;j&lt;arr2[0].length;j++)&#123; System.out.print(arr2[i][j]+\" \"); &#125; System.out.println(); &#125; &#125;&#125; 5. 起泡法对4，21，0，-12，-3排序。原理：起泡法是从一端开始比较的，第一次循环就是把最大数放到最后一个位置，第二次循环就是把第二最大数放到倒数第二个位置。 4 21 0 -12 -3 第1次 4 0 -12 -3 21 第2次 0 -12 -3 4 21 第3次 -12 -3 0 4 21 第4次 -12 -3 0 4 21 12345678910111213141516171819202122232425262728package com.java.chap06;/** * @author Yan * @date 2019/7/17 14:46 */public class Demo5 &#123; public static void main(String[] args) &#123; int temp; int []arr=&#123;4,21,0,-12,-3&#125;; //循环的次数n-1次 for (int i=0;i&lt;arr.length-1;i++)&#123; //比较次数n-1-i for (int j=0;j&lt;arr.length-1-i;j++)&#123; //假如前面一个数大于后面一个数，则交换数据 if (arr[j]&gt;arr[j+1])&#123; temp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; &#125; &#125; &#125; for (int i:arr)&#123; System.out.print(i+\" \"); &#125; &#125;&#125; Java面向对象1. 面向对象的基本概念定义：以基于对象的思维去分析和解决问题，万物皆对象；三大特性：封装，继承，多态； 2. 类与对象1. 类与对象的关系2. 类的定义3. 类的创建及使用123456789101112131415161718192021222324252627package com.java.chap07.sec01;/** * @author Yan * @date 2019/7/18 13:39 * Person类 */public class Person &#123; String name; //在类中，定义一个姓名name字符串属性 int age; //在类中，定义一个年龄age属性 public void speak()&#123; System.out.println(\"我叫\"+name+\"我今年\"+age+\"岁了\"); &#125; public static void main(String[] args) &#123; //定义一个Person类的对象zhangsan Person zhangsan; //实例化对象 zhangsan=new Person(); //给对象的name属性赋值 zhangsan.name=\"张三\"; zhangsan.age=23; zhangsan.speak(); &#125;&#125; 内存分析 3. 方法1. 方法的定义及简单使用12345678910111213141516171819package com.java.chap07.sec02;/** * @author Yan * @date 2019/7/18 13:54 */public class People &#123; /** * 最简单的一个方法定义 */ void speak()&#123; System.out.println(\"我叫张三\"); &#125; public static void main(String[] args) &#123; People zhangsan=new People(); zhangsan.speak(); &#125;&#125; 123456789101112131415161718package com.java.chap07.sec02;/** * @author Yan * @date 2019/7/18 13:57 */public class People2 &#123; //形参，入参 void speak(String name)&#123; System.out.println(\"我叫\"+name); &#125; public static void main(String[] args) &#123; People2 zhangsan=new People2(); zhangsan.speak(\"张三\"); &#125;&#125; 123456789101112131415161718package com.java.chap07.sec02;/** * @author Yan * @date 2019/7/18 13:57 */public class People3 &#123; //形参，入参 void speak(String name, int age) &#123; System.out.println(\"我叫\" + name+\"我今年\"+age+\"岁了\"); &#125; public static void main(String[] args) &#123; People3 zhangsan = new People3(); zhangsan.speak(\"张三\", 23); &#125;&#125; 12345678910111213141516171819202122package com.java.chap07.sec02;/** * @author Yan * @date 2019/7/18 13:57 */public class People4 &#123; //形参，入参,不固定参数 void speak(String name, int age,String ...hobbies) &#123; System.out.println(\"我叫\" + name + \"我今年\" + age + \"岁了\"); System.out.println(\"我的爱好： \"); for (String hobby:hobbies)&#123; System.out.print(hobby+\" \"); &#125; &#125; public static void main(String[] args) &#123; People4 zhangsan = new People4(); zhangsan.speak(\"张三\", 23,\"游泳\",\"唱歌\"); &#125;&#125; 123456789101112131415161718192021222324252627package com.java.chap07.sec02;/** * @author Yan * @date 2019/7/18 13:57 */public class People5 &#123; //返回类型 int speak(String name, int age,String ...hobbies) &#123; System.out.println(\"我叫\" + name + \"我今年\" + age + \"岁了\"); System.out.println(\"我的爱好： \"); for (String hobby:hobbies)&#123; System.out.print(hobby+\" \"); &#125; //获取爱好的长度 int totalHobbies=hobbies.length; return totalHobbies; &#125; public static void main(String[] args) &#123; People5 zhangsan = new People5(); int n=zhangsan.speak(\"张三\", 23,\"游泳\",\"唱歌\"); System.out.println(\"\\n有\"+n+\"个爱好\"); &#125;&#125; 2. 方法的值传递和引用传递(重点)1234567891011121314151617181920212223242526272829303132333435363738394041package com.java.chap07.sec02;/** * 三围类 * @author Yan * @date 2019/7/18 14:08 */class Sanwei&#123; int b; //胸围 int w; //腰围 int h; //臀围&#125;public class People6 &#123; /** * 报三围 * @param age 年龄 * @param sanwei 三围 */ void speak(int age,Sanwei sanwei)&#123; System.out.println(\"我今年\"+age+\"岁了,我的三围是\"+sanwei.b+\",\"+sanwei.w+\",\"+sanwei.h); age=24; sanwei.b=80; &#125; public static void main(String[] args) &#123; People6 xiaoli=new People6(); int age=23; Sanwei sanwei=new Sanwei(); sanwei.b=90; sanwei.w=60; sanwei.h=90; //age传递的是值，sanwei传递的是引用（地址）,c里叫指针 xiaoli.speak(age,sanwei); System.out.println(age); System.out.println(sanwei.b); &#125;&#125; 3. 方法的重载方法重载定义：方法名称相同，但是参数的类型或者参数的个数不同。 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.java.chap07.sec03;/** * @author Yan * @date 2019/7/18 14:22 */public class Demo &#123; int add(int a,int b)&#123; System.out.print(\"方法一:\"); return a+b; &#125; /** * 方法的重载，参数个数不一样 * @param a * @param b * @param c * @return */ int add(int a,int b,int c)&#123; System.out.print(\"方法二：\"); return a+b+c; &#125; /** * 方法的重载，参数的类型不一样 * @param a * @param b * @return */ int add(int a,String b)&#123; System.out.print(\"方法三：\"); return a+Integer.parseInt(b); &#125; public static void main(String[] args) &#123; Demo demo=new Demo(); System.out.println(demo.add(1,2)); System.out.println(demo.add(1,2,3)); System.out.println(demo.add(1,\"3\")); &#125;&#125; 4. static静态方法与普通方法static方法：方法属于类本身；调用方式：1. 类名.方法;2. 对象.方法 普通方法：方法属于类的对象；调用方式：1. 对象.方法 1234567891011121314151617181920212223242526package com.java.chap07.sec03;/** * @author Yan * @date 2019/7/18 15:33 */public class Demo2 &#123; void fun1()&#123; System.out.println(\"这是一个普通方法\"); &#125; static void fun2()&#123; System.out.println(\"这是一个静态方法\"); &#125; public static void main(String[] args) &#123; Demo2 demo2=new Demo2(); //调用普通方法，对象.方法 demo2.fun1(); //调用静态方法，类名.方法名 Demo2.fun2(); //调用静态方法，对象.方法 demo2.fun2(); &#125;&#125; 5. 递归方法求阶乘 1 2 3… (n-1) n原理： 12345N=5 F(n-1) * 5 N=4 F(n-1) * 4 N=3 F(n-1) * 3 N=2 F(n-1) * 2 N=1 1 1234567891011121314151617181920212223242526272829303132333435363738394041package com.java.chap07.sec03;/** * @author Yan * @date 2019/7/18 15:38 */public class Demo3 &#123; /** * 非递归 * @param n * @return */ static long notDiGui(int n)&#123; long result=1; for (int i=1;i&lt;=n;i++)&#123; result=result*i; &#125; return result; &#125; /** * 递归 * @param n * @return */ static long DiGUi(int n)&#123; if (n==1)&#123; return 1; &#125; return DiGUi(n-1)*n; &#125; public static void main(String[] args) &#123; System.out.println(\"非递归：\"+Demo3.notDiGui(5)); System.out.println(\"递归:\"+Demo3.DiGUi(5)); &#125;&#125; 4. 构造方法，this关键字1. 构造方法构造器是一个特殊的方法，这个特殊方法用于创建实例时可执行初始化；假如没有构造方法，系统会自动生成一个默认的无参构造方法；假如有构造方法，系统不会自动生成构造方法； 12345678910111213141516171819202122232425262728293031323334353637383940package com.java.chap07.sec04;/** * @author Yan * @date 2019/7/18 15:56 */public class People &#123; // String 类属性默认值是null private String name; //int 类属性默认值是0 private int age; /** * 默认构造方法 */ People()&#123; System.out.println(\"默认构造方法\"); &#125; /** * 有参数的构造方法 构造方法的重载 */ People(String name2,int age2)&#123; name=name2; age=age2; System.out.println(\"有参数的构造方法\"); &#125; public void say()&#123; System.out.println(\"我叫：\"+name+\"，我今年：\"+age+\"岁了\"); &#125; public static void main(String[] args) &#123; //People people=new People(); People people2=new People(\"张三\",23); people2.say(); &#125;&#125; 2. this关键字this表示当前对象 使用this调用本类中的属性； 使用this调用构造方法； 1234567891011121314151617181920212223242526272829303132333435363738394041package com.java.chap07.sec04;/** * @author Yan * @date 2019/7/18 15:56 */public class People2 &#123; // String 类属性默认值是null private String name; //int 类属性默认值是0 private int age; /** * 默认构造方法 */ People2()&#123; System.out.println(\"默认构造方法\"); &#125; /** * 有参数的构造方法 构造方法的重载 */ People2(String name2, int age2)&#123; this(); this.name=name2; this.age=age2; System.out.println(\"有参数的构造方法\"); &#125; public void say()&#123; System.out.println(\"我叫：\"+name+\"，我今年：\"+age+\"岁了\"); &#125; public static void main(String[] args) &#123; //People people=new People(); People2 people2=new People2(\"张三\",23); people2.say(); &#125;&#125; 5. 访问控制权限及package import关键字1. 访问控制权限private(私有) get,set方法package（包访问权限）protected(子类访问权限)public（公共访问权限） private package protected public 同一个类中 √ √ √ √ 同一个包中 √ √ √ 子类中 √ √ 全局范围 √ Demo1.java123456789101112131415161718192021package com.java.chap07.sec05;/** * @author Yan * @date 2019/7/18 16:16 */public class Demo1 &#123; /** * 定义一个私有的属性a */ private int a; public int getA() &#123; return a; &#125; public void setA(int a) &#123; this.a = a; &#125;&#125; TestDemo1.java1234567891011121314package com.java.chap07.sec05;/** * @author Yan * @date 2019/7/18 16:17 */public class TestDemo1 &#123; public static void main(String[] args) &#123; Demo1 demo1=new Demo1(); demo1.setA(2); int a=demo1.getA(); System.out.println(a); &#125;&#125; 2. package import 关键字package 包定义import 导入相关类 123456789101112131415161718package com.java.chap07.sec05;import com.java.chap07.sec02.People;/** * @author Yan * @date 2019/7/18 16:19 */public class Demo2 &#123; public static void main(String[] args) &#123; //不同包，则需要导入相关类 People people=new People(); //在同一个包中，则不需要导入相关类 Demo1 demo1=new Demo1(); &#125;&#125; 6. 内部类内部类定义：在类的内部定义类；内部类优点：可以方便的使用外部类的属性；内部类缺点：破环类的基本结构； Demo1.java1234567891011121314151617181920212223242526272829package com.java.chap07.sec06;/** * @author Yan * @date 2019/7/18 16:38 */public class Outer &#123; private int a=1; /** * 定义内部类 */ class Inner&#123; public void show()&#123; System.out.println(a); &#125; &#125; public void show()&#123; Inner inner=new Inner(); inner.show(); &#125; public static void main(String[] args) &#123; Outer outer=new Outer(); outer.show(); &#125;&#125; Demo2.java12345678910111213141516171819202122232425package com.java.chap07.sec06;/** * @author Yan * @date 2019/7/18 16:38 */public class Outer2 &#123; private int a = 1; /** * 定义内部类 */ class Inner &#123; public void show() &#123; System.out.println(a); &#125; &#125; public static void main(String[] args) &#123; Outer2 outer2 = new Outer2(); //实例化外部类对象 Outer2.Inner inner = outer2.new Inner(); //实例化内部类对象 inner.show(); &#125;&#125; 7. 代码块 普通代码块 12345678910111213141516171819package com.java.chap07.sec07;/** * @author Yan * @date 2019/7/18 16:49 */public class Demo1 &#123; public static void main(String[] args) &#123; int a=1; /** * 普通代码块 */ &#123; a=2; System.out.println(\"普通代码块\"); &#125; System.out.println(\"a=\"+a); &#125;&#125; 构造块 1234567891011121314151617181920212223242526272829303132333435363738394041package com.java.chap07.sec07;/** * @author Yan * @date 2019/7/18 16:52 */public class Demo2 &#123; /** * 构造块 * @param args */ &#123; System.out.println(\"通用构造块\"); &#125; /** * 构造方法一 */ public Demo2()&#123; System.out.println(\"构造方法一\"); &#125; /** * 构造方法二 */ public Demo2(int i)&#123; System.out.println(\"构造方法二\"); &#125; /** * 构造方法三 */ public Demo2(int i,int j)&#123; System.out.println(\"构造方法三\"); &#125; public static void main(String[] args) &#123; new Demo2(); //实例化一个对象 匿名类 new Demo2(1); new Demo2(1,2); &#125;&#125; 静态代码块 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.java.chap07.sec07;/** * @author Yan * @date 2019/7/18 16:55 */public class Demo3 &#123; /** * 构造块 */ &#123; System.out.println(\"通用构造块\"); &#125; /** * 静态代码块 */ static &#123; System.out.println(\"静态代码块\"); &#125; /** * 构造方法一 */ public Demo3()&#123; System.out.println(\"构造方法一\"); &#125; /** * 构造方法二 */ public Demo3(int i)&#123; System.out.println(\"构造方法二\"); &#125; /** * 构造方法三 */ public Demo3(int i,int j)&#123; System.out.println(\"构造方法三\"); &#125; public static void main(String[] args) &#123; new Demo3(); new Demo3(1); new Demo3(1,2); &#125;&#125; 8. String 类1. 实例化String对象方法一：1String name1=\"张三\"; 方法二：1String name2=new String(\"李四\"); 1234567891011121314151617package com.java.chap07.sec08;/** * @author Yan * @date 2019/7/18 21:32 */public class Demo1 &#123; public static void main(String[] args) &#123; //实例化String的方式一 String name1=\"张三\"; System.out.println(\"name1:\"+name1); //实例化String的方式二 String name2=new String(\"李四\"); System.out.println(\"name2:\"+name2); &#125;&#125; 2. “==” VS “equals方法” “==”，比较的是引用，“equals方法”比较的是具体内容 1234567891011121314151617181920212223242526package com.java.chap07.sec08;/** * @author Yan * @date 2019/7/18 21:39 */public class Demo2 &#123; public static void main(String[] args) &#123; String name1=\"张三\"; //直接赋值方式 String name2=new String(\"张三\"); //new 的方式 String name3=name2; // 传递引用 //==比较的是引用 System.out.println(\"name1==name2:\"+(name1==name2)); System.out.println(\"name1==name3:\"+(name1==name3)); System.out.println(\"name2==name3:\"+(name2==name3)); System.out.println(\"-------------\"); //equals比较的是内容 System.out.println(\"name1.equals(name2):\"+(name1.equals(name2))); System.out.println(\"name1.equals(name3):\"+(name1.equals(name3))); System.out.println(\"name2.equals(name3):\"+(name2.equals(name3))); &#125;&#125; 3. String 两种实例化方式的区别 直接赋值方式，创建的对象存放到字符串对象池里，假如存在的，就不会创建； new对象方式，每次都创建一个新的对象； 123456789101112131415161718package com.java.chap07.sec08;/** * @author Yan * @date 2019/7/18 21:46 */public class Demo3 &#123; public static void main(String[] args) &#123; String name1=\"张三\"; String name2=\"张三\"; String name3=new String(\"张三\"); String name4=new String(\"张三\"); System.out.println(\"name1==name2:\"+(name1==name2)); System.out.println(\"name1==name3:\"+(name1==name3)); System.out.println(\"name3==name4:\"+(name3==name4)); &#125;&#125; 4. 字符串的内容不可变性字符串的特性：不能改变字符串的内容；只能通过指向一个新的内存地址； 12345678910111213package com.java.chap07.sec08;/** * @author Yan * @date 2019/7/18 21:51 */public class Demo4 &#123; public static void main(String[] args) &#123; String name=\"张\"; name+=\"三\"; System.out.println(name); &#125;&#125; 5. String类常用方法及基本使用 char charAt(int index)返回指定索引处的char值。 1234567891011121314151617181920package com.java.chap07.sec08;/** * @author Yan * @date 2019/7/18 22:00 */public class Demo5 &#123; public static void main(String[] args) &#123; String name=\"张三\"; char ming=name.charAt(1); System.out.println(ming); String srt=\"我是中国人\"; //遍历字符串 for (int i=0;i&lt;srt.length();i++)&#123; System.out.println(srt.charAt(i)); &#125; &#125;&#125; int length()返回此字符串的长度。 int indexOf() 返回指定字符在此字符中第一次出现处的索引。 1234567891011121314package com.java.chap07.sec08;/** * @author Yan * @date 2019/7/18 22:03 */public class Demo6 &#123; public static void main(String[] args) &#123; //indexOf方法使用示例 String str=\"abcdefghdijklmnopqrstuvwxyz\"; System.out.println(\"d在字符串str中第一次出现的索引位置：\"+str.indexOf(\"d\")); System.out.println(\"d在字符串str中第一次出现的索引位置,从索引4开始：\"+str.indexOf(\"d\",4)); &#125;&#125; String substring(int beginIndex)返回一个新的字符串，它是此字符串的一个子字符串。该子字符串从指定索引处的字符开始，直到此字符串末尾。 1234567891011121314151617package com.java.chap07.sec08;/** * @author Yan * @date 2019/7/18 22:08 */public class Demo7 &#123; public static void main(String[] args) &#123; //subString方法使用 String str=\"不开心每一天,不可能\"; String newStr=str.substring(1); String newStr2=str.substring(1,6); System.out.println(str); System.out.println(newStr); System.out.println(newStr2); &#125;&#125; String toUpperCase() 使用默认语言环境的规则将此String中的所有字符都转换为大写。 123456789101112131415161718package com.java.chap07.sec08;/** * @author Yan * @date 2019/7/18 22:12 */public class Demo8 &#123; public static void main(String[] args) &#123; String str=\"I'm a boy!\"; String upStr=str.toUpperCase(); //转换成大写 System.out.println(\"str:\"+str); System.out.println(\"upStr:\"+upStr); String lowerStr=upStr.toLowerCase(); //转换成小写 System.out.println(\"lowerStr:\"+lowerStr); &#125;&#125; 综合实例编程输入一个字符串，要求去掉前后的空格，然后分别统计其中英文字母，空格，数字和其他字符的个数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.java.chap07.sec08;/** * @author Yan * @date 2019/7/18 22:18 */public class Demo9 &#123; public static void main(String[] args) &#123; String str=\" aB23 2&amp;* &amp;* s2 \"; //去掉前面和后面的空白 String newStr=str.trim(); System.out.println(\"str:\"+str); System.out.println(\"newStr:\"+newStr); int yingWen=0; int kongGe=0; int shuZi=0; int qiTa=0; for (int i=0;i&lt;newStr.length();i++)&#123; char c=newStr.charAt(i); if (c&gt;='a'&amp;&amp;c&lt;='z'||(c&gt;='A'&amp;&amp;c&lt;='Z'))&#123; //判断英文字符 yingWen++; System.out.println(\"英文字符：\"+c); &#125;else if (c&gt;='0'&amp;&amp;c&lt;='9')&#123; //判断数字 shuZi++; System.out.println(\"数字：\"+c); &#125;else if (c==' ')&#123; //判断空格 kongGe++; System.out.println(\"空格：\"+c); &#125;else &#123; //判断其他 qiTa++; System.out.println(\"其他：\"+c); &#125; &#125; System.out.println(); System.out.println(\"英文总数：\"+yingWen); System.out.println(\"数字总数：\"+shuZi); System.out.println(\"空格总数：\"+kongGe); System.out.println(\"其他总数：\"+qiTa); &#125;&#125; 9. Java类的继承&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js&quot;&gt;&lt;/script&gt;{% raw %}op=>operation: Hello World.java(Javac 编译) op1=>operation: Hello World.class(Java 运行) op2=>operation: 执行并运行结果 e=>end op->op1->op2{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-0\", options);{% endraw %}","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"},{"name":"基础","slug":"Java/基础","permalink":"http://yoursite.com/categories/Java/基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"基础","slug":"基础","permalink":"http://yoursite.com/tags/基础/"}]},{"title":"整合Swagger","slug":"Spring Boot 整合Swagger","date":"2019-07-13T12:40:56.543Z","updated":"2019-07-13T12:48:58.192Z","comments":true,"path":"2019/07/13/Spring Boot 整合Swagger/","link":"","permalink":"http://yoursite.com/2019/07/13/Spring Boot 整合Swagger/","excerpt":"Swagger 是一款RESTFUL接口的文档在线自动生成+功能测试功能软件。本文简单介绍了在项目中集成swagger的方法和一些常见问题。 如果想深入分析项目源码，了解更多内容，见参考资料。Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。总体目标是使客户端和文件系统作为服务器以同样的速度来更新。文件的方法，参数和模型紧密集成到服务器端的代码，允许API来始终保持同步。Swagger 让部署管理和使用功能强大的API从未如此简单。","text":"Swagger 是一款RESTFUL接口的文档在线自动生成+功能测试功能软件。本文简单介绍了在项目中集成swagger的方法和一些常见问题。 如果想深入分析项目源码，了解更多内容，见参考资料。Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。总体目标是使客户端和文件系统作为服务器以同样的速度来更新。文件的方法，参数和模型紧密集成到服务器端的代码，允许API来始终保持同步。Swagger 让部署管理和使用功能强大的API从未如此简单。 整合pom.xml1234567891011 &lt;!-- swagger api文档 --&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.6.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.6.1&lt;/version&gt;&lt;/dependency&gt; SwaggerConfig.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.cleanhome.service.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;/** * @author Yan * @date 2019/6/10 13:58 * * swaggerui配置文件 */@Configuration@EnableSwagger2public class SwaggerConfig &#123; /** * 创建API应用 * apiInfo() 增加API相关信息 * 通过select()函数返回一个ApiSelectorBuilder实例,用来控制哪些接口暴露给Swagger来展现， * 本例采用指定扫描的包路径来定义指定要建立API的目录。 * * @return */ @Bean public Docket createRestApi() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage(&quot;com.cleanhome.service.controller&quot;)) .paths(PathSelectors.any()) .build(); &#125; /** * 创建该API的基本信息（这些基本信息会展现在文档页面中） * 访问地址：http://项目实际地址/swagger-ui.html * @return */ private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title(&quot;XXXX&quot;) .description(&quot;XXXX&quot;) .termsOfServiceUrl(&quot;https://yanxin152133.github.io/&quot;) .contact(&quot;yan&quot;) .version(&quot;1.0&quot;) .build(); &#125;&#125; 使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155package com.cleanhome.service.controller;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import com.cleanhome.service.bean.EjCustomer;import com.cleanhome.service.service.impl.IEjCustomerServiceImpl;import com.cleanhome.service.utils.Message;import com.cleanhome.service.utils.MessageUtil;import io.swagger.annotations.Api;import io.swagger.annotations.ApiImplicitParam;import io.swagger.annotations.ApiImplicitParams;import io.swagger.annotations.ApiOperation;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.propertyeditors.CustomDateEditor;import org.springframework.web.bind.WebDataBinder;import org.springframework.web.bind.annotation.*;import org.springframework.web.context.request.WebRequest;import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.Date;import java.util.List;import java.util.Map;/** * @author Yan、ysq * @date 2019/6/11 8:40 * 顾客 * 主要功能： * 1.查询顾客的所有信息 * 2.查询顾客数量 * 3.添加顾客信息 * 4.根据编号进行删除顾客信息 * 5.根据编号进行更新操作 */@RestController@RequestMapping(&quot;/customer&quot;)@Api(value = &quot;/customer&quot;, description = &quot;顾客信息管理&quot;)public class EjCustomerController &#123; Logger logger = LoggerFactory.getLogger(EjCustomerController.class); @Autowired private IEjCustomerServiceImpl ejCustomerService; @InitBinder public void initBinder(WebDataBinder binder, WebRequest request) &#123; //转换日期 DateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, true));// CustomDateEditor为自定义日期编辑器 &#125; //查询顾客的所有信息 @ApiOperation(value = &quot;查询顾客的所有信息&quot;) @GetMapping(&quot;findAll&quot;) public Message findAll() &#123; List&lt;EjCustomer&gt; list = ejCustomerService.findAll(); logger.info(&quot;查询顾客所有信息成功&quot;); return MessageUtil.success(&quot;查询顾客所有信息成功&quot;, list); &#125; //查询顾客数量 @ApiOperation(value = &quot;查询顾客数量&quot;) @GetMapping(&quot;findCustomer_Num&quot;) public Message findCustomer_Num() &#123; int num = ejCustomerService.findCustomer_Num(); logger.info(&quot;查询顾客数量成功&quot;); return MessageUtil.success(&quot;查询顾客数量成功&quot;, num); &#125; //查询当天新增顾客量 @ApiOperation(value = &quot;查询当天新增顾客量&quot;) @GetMapping(&quot;TodayCustomerNum&quot;) public Message TodayCustomerNum() &#123; int num = ejCustomerService.TodayCustomerNum(); logger.info(&quot;查询当天新增顾客量成功&quot;); return MessageUtil.success(&quot;查询当天新增顾客量成功&quot;, num); &#125; //添加顾客信息 @ApiOperation(value = &quot;添加顾客信息&quot;) @PostMapping(&quot;insert&quot;) @ApiImplicitParams(&#123; @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;id&quot;, value = &quot;顾客编号&quot;, required = false, dataType = &quot;Integer&quot;), @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;account&quot;, value = &quot;顾客账号&quot;, required = true, dataType = &quot;Long&quot;), @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;password&quot;, value = &quot;顾客账号密码&quot;, required = true, dataType = &quot;String&quot;), @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;realname&quot;, value = &quot;顾客真实姓名&quot;, required = true, dataType = &quot;String&quot;), @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;status&quot;, value = &quot;状态&quot;, required = true, dataType = &quot;String&quot;), @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;photo&quot;, value = &quot;顾客头像&quot;, required = true, dataType = &quot;String&quot;), @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;telephone&quot;, value = &quot;顾客联系方式&quot;, required = true, dataType = &quot;String&quot;), @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;register_time&quot;, value = &quot;顾客注册时间&quot;, required = true, dataType = &quot;java.util.Date&quot;) &#125;) public Message insert(EjCustomer ejCustomer) throws Exception &#123; boolean isValid = ejCustomerService.isExits(ejCustomer.getAccount()); if (isValid) &#123; try &#123; ejCustomerService.insert(ejCustomer); logger.info(&quot;添加顾客信息成功&quot;); return MessageUtil.success(&quot;添加顾客信息成功&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); return MessageUtil.error(e.getMessage()); &#125; &#125; else &#123; logger.warn(&quot;添加顾客信息失败&quot;); return MessageUtil.error(&quot;error&quot;); &#125; &#125; //根据顾客id删除用户信息 @ApiOperation(value = &quot;根据顾客id删除顾客信息&quot;) @GetMapping(&quot;deleteById&quot;) @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;id&quot;, value = &quot;顾客编号&quot;, required = true, dataType = &quot;Integer&quot;) public Message deleteById(Integer id) throws Exception &#123; try &#123; ejCustomerService.deleteById(id); logger.info(&quot;顾客编号为&quot; + id + &quot;删除成功&quot;); return MessageUtil.success(&quot;删除顾客信息成功&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); logger.warn(&quot;顾客信息删除失败&quot;); return MessageUtil.error(e.getMessage()); &#125; &#125; //根据顾客id进行更新操作 @ApiOperation(value = &quot;根据顾客id进行更新&quot;) @PostMapping(&quot;updateById&quot;) @ApiImplicitParams(&#123; @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;id&quot;, value = &quot;顾客编号&quot;, required = true, dataType = &quot;Integer&quot;), @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;account&quot;, value = &quot;顾客账号&quot;, required = false, dataType = &quot;Long&quot;), @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;password&quot;, value = &quot;顾客账号密码&quot;, required = false, dataType = &quot;String&quot;), @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;realname&quot;, value = &quot;顾客真实姓名&quot;, required = false, dataType = &quot;String&quot;), @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;status&quot;, value = &quot;状态&quot;, required = false, dataType = &quot;String&quot;), @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;photo&quot;, value = &quot;顾客头像&quot;, required = false, dataType = &quot;String&quot;), @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;telephone&quot;, value = &quot;顾客联系方式&quot;, required = false, dataType = &quot;String&quot;), &#125;) public Message updateById(EjCustomer ejCustomer) throws Exception&#123; try &#123; ejCustomerService.updateById(ejCustomer); logger.info(&quot;顾客编号&quot;+ejCustomer.getId()+&quot;更新成功&quot;); return MessageUtil.success(&quot;更新顾客信息成功&quot;); &#125;catch (Exception e)&#123; e.printStackTrace(); logger.warn(&quot;顾客信息更新失败&quot;); return MessageUtil.error(e.getMessage()); &#125; &#125;&#125;","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/categories/Spring-Boot/"},{"name":"Swagger","slug":"Spring-Boot/Swagger","permalink":"http://yoursite.com/categories/Spring-Boot/Swagger/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"},{"name":"Swagger","slug":"Swagger","permalink":"http://yoursite.com/tags/Swagger/"}]},{"title":"缺陷跟踪","slug":"缺陷跟踪","date":"2019-07-10T03:41:31.838Z","updated":"2019-07-10T03:42:10.290Z","comments":true,"path":"2019/07/10/缺陷跟踪/","link":"","permalink":"http://yoursite.com/2019/07/10/缺陷跟踪/","excerpt":"简答题开发各阶段缺陷放大图","text":"简答题开发各阶段缺陷放大图 同行评审 同行评审的种类 正式评审 技术审查 走查 同行评审方式的选择 工作产品刚勾画，起草时—走查 完成了某一个单独的章节时—技术审查 整个产品完成时—正式评审 软件缺陷发现 同行评审 软件测试 管理评审 PPQA发现 项目组内部发现 客户反馈 软件缺陷生命周期软件缺陷生命周期主要由四个阶段组成： 识别 调查 改正 总结 缺陷度量 缺陷度量：CMMI第四级（量化管理级）的软件组织会根据已收集的缺陷数据，采用统计过程控制（Statistical Process Control,SPC)的方法建立软件过程能力基线（Process Capability Baseline，PCB），定量地刻划出软件或过程的特点，进行量化管理。 SPC:利用统计方法对过程中的各个阶段进行控制，从而达到改进与保证质量的目的；强调以全过程的预防为主；方法是建立控制图 PCB：用基线形式量化地表示过程能力；PCB是个不断随着数据累积校正的过程，本身数据收集必须遵循客观、准确、事实，确保组织基线可以持续为各项目研发作为参考标准；运用PCB有助于对过程的分析和改进； PCB是一组能力指标，是过程实际能力的具体体现。通常包括期望值（Mean）、控制上限（Upper Control Limit，UCL）、控制下限（Low Control Limit，LCL）。以缺陷密度为例， Mean描述了未来项目的缺陷密度的预期值，UCL和LCL描述了未来项目的缺陷密度的合理变化范围。 这样的过程能力基线可用来：(1)帮助未来的项目设立量化的项目质量目标；(2)理解和控制未来项目的实际结果。 软件缺陷跟踪管理流程 总体流程 提交流程 修复流程 验证流程 拒绝流程 争议处理流程 缺陷挂起流程 缺陷状态常用软件缺陷状态 编号 缺陷状态 描述 1 提交（Submitted或New） 已提交的缺陷 2 打开（Open或Active） 经审查后确认的缺陷，等待处理 3 拒绝（Rejected、Refuse或Not a bug） 经审查确认不是缺陷、不需要修复或不需要提交 4 修复（Resolved或Fixed） 或为Fixed。缺陷已被修复 5 关闭（Closed或Inactive） 经审查确认已被修复的缺陷，可将其关闭 6 推迟（Later、Pending或Deferred） 当前无法修复，以后条件具备时再解决，但要确定修复的日期 7 重新打开（Reopen) 经过修复的缺陷未通过验证测试，或已关闭的缺陷重新出现 软件缺陷报告“5C”原则： 内容正确(Correct)：每个组成部分的描述正确，不会引起误解。 内容清晰(Clear)：每个组成部分的描述清晰，易于理解。 步骤简洁(Concise)：只包含必不可少的信息，不包括任何多余的内容。 结构完整(Complete)：包含复现该缺陷的完整步骤和其他本质信息。 风格一致（Consistent）：按照一致的格式书写全部缺陷报告。 优秀的缺陷报告 重现步骤 (1) 打开编辑文字的软件 （2）创建一个新文档（这个文档可以录入文字） （3）在这个文档里随意录入一两行文字（任意） （4）选中录入的一两行文字，选择Font菜单，然后选择Arial字体格式 （5）一两行文字变成了无意义的乱字符 期望结果 当用户选择已录入的文字并改变文字格式时，文本应该正确显示选中的文字格式，不会显示成乱字符 实际结果 这是字体格式的问题，如果把文字格式改变成Arial前保存文件，缺陷不会出现。缺陷仅发生在Win98，且改变文字格式成其他字体格式时正常。 缺陷工具： Bugzilla是一款免费、跨平台的开源缺陷跟踪系统，最初是专门为Unix定制开发的，目前也可在windows、Mac OS平台安装使用，在wins操作系统下的安装和配置略为复杂。bugzilla历史悠久、功能强大、受到很多企业用户的欢迎。 Mantis是一款开源的基于PHP的轻量级跟踪系统，简洁灵活，安装容易，扩展性强，其实用性足以满足中小型项目的缺陷管理和跟踪需要。 禅道：集产品管理、项目管理、质量管理、文档管理、组织管理和事务管理于一体，避免了一个团队使用多个工具，较bugfree功能更全面。 TestCenter是一款集测试需求、测试用例、测试过程、测试结果、以及测试报告管理的测试管理工具。 BugFree基于浏览器，简单、方便、易用的免费、开源的缺陷管理工具。 大题注入-发现矩阵实例 缺陷注入阶段/缺陷发现阶段 需求阶段 概要设计阶段 详细设计阶段 编码阶段 单元测试阶段 集成测试阶段 系统测试阶段 现场阶段 注入合计 需求评审 概要设计审查 49 681 730 详细设计审查 6 42 681 729 代码审查 12 28 114 941 1095 单元测试 21 43 43 223 2 332 集成测试 20 41 61 261 —— 4 387 系统测试 6 8 24 72 —— —— 1 111 现场 8 16 16 40 —— —— —— 1 81 发现合计 122 859 939 1537 2 4 1 1 3465 本阶段缺陷移除率 —— 74% 61% 55% 36% 67% 58% 思路：单元测试：332/（122+859+939+1537+2-730-729-1095）x100%=36% 故障树参考：故障树PPT 故障树分析逻辑门 例题 使用MOCUS算法确定最小割集。首先画出一个足够大的矩阵表格，然后按下面的步骤填充矩阵： 将故障事件门的字符放在左上角（0，0）单元格 将每个门的字符用其下方较低级别的门或基本事件的字符或数字替换，重复此过程。 对于或门：将字符写成一竖排（也就是竖着写）；对于与门：将字符写成一横排。","categories":[{"name":"缺陷跟踪","slug":"缺陷跟踪","permalink":"http://yoursite.com/categories/缺陷跟踪/"}],"tags":[{"name":"缺陷跟踪","slug":"缺陷跟踪","permalink":"http://yoursite.com/tags/缺陷跟踪/"}]},{"title":"软件测试","slug":"软件测试","date":"2019-07-06T05:24:49.898Z","updated":"2019-07-07T14:18:22.247Z","comments":true,"path":"2019/07/06/软件测试/","link":"","permalink":"http://yoursite.com/2019/07/06/软件测试/","excerpt":"思考题1. 你怎样组建一支新的测试团队，包含一些什么岗位，如果要去招聘，开出什么条件？","text":"思考题1. 你怎样组建一支新的测试团队，包含一些什么岗位，如果要去招聘，开出什么条件？参考：首先，测试团队包含的成员（即工作岗位） 测试经理测试部门的负责人。主要职责： 对外： 公司内团队之间的沟通 向上沟通、汇报、日常作业 人才招募 外部影响力（公司内外） 对内 团队管理与建设 项目管理 人才培养 目标拆解、执行、调整、跟进 测试架构师测试技术的负责人，主要承担教练职责，是测试部门的技术核心，涵盖产品测试技术、自动化测试技术、专项测试技术、交付测试技术等方向。主要负责：测试技术管理、测试技术调研、测试技术应用、测试人员的技术培养等。 核心测试人员测试任务的主要执行者，主要负责核心测试任务的落地执行、重要测试技术的落地实践、测试管理要求的有效实施。中等职级、业务专家或擅长某一方向技术。 一般测试人员测试任务的主要辅助执行者，主要负责一般测试任务的落地执行、一般测试技术的落地实践、测试管理要求的有效实施。中低等职级。 测试项目负责人类似于项目经理。工作重点在于沟通和协调。 外包测试人员视为人力，作为一些特殊项目的补充。 测试实习生除了做一些特殊时期的补充外，是选择和提前培养优秀应届生的途径之一。 其次，招聘条件（仅供参考）任职要求： 计算机相关专业，本科及以上学历，3年及以上测试经验，有互联网、SaaS平台产品测试经验者优先； 具备一定的编程能力，熟练掌握Java/C/C++或各类脚本语言中一种，熟悉MySQL等数据库； 熟悉Linux操作系统，有自动化测试经验，能独立设计用例并编写代码实现自动化测试； 熟练测试理论与方法，对互联网质量保证领域有强烈的兴趣； 具有较强的业务分析能力，较好的沟通表达和综合协调能力，对质量保证有深刻理解； 具备撰写自动化测试工具以及搭建自动化测试平台的实战经验者优先。 参考链接： 如何搭建测试团队（研发同理) 2. 如果你作为测试项目负责人，你为什么要对软件测试过程进行管理？测试过程管理的原则，测试过程管理的目标参考：对软件测试过程进行管理的原因： 能够使规定时间内完成所需完成的测试任务。 测试过程管理原则：①有关测试需求；②测试计划先行；③建立任务优先级；④建立客观的评估标准；⑤尽早测试；⑥全面测试；⑦全过程测试；⑧独立的、迭代的测试。 测试过程管理目标：尽可能早地找出软件缺陷，并保证其得以修复。 参考链接： 测试过程管理 测试过程管理 3. 白盒测试策略定义：白盒测试也称结构测试或逻辑驱动测试，是一种测试用例设计方法，它从程序的控制结构导出测试用例。（测试用例由测试输入数据以及与之对应的输出结果组成。） 白盒测试使用被测单元内部如何工作的信息，允许测试人员对程序内部逻辑结构及有关信息来设计和选择测试用例，对程序的逻辑路径进行测试。基于一个应用代码的内部逻辑知识，测试是基于覆盖全部代码、分支、路径、条件。 策略： 桌前检查 模块测试 代码评审 同行评审 代码走查 静态分析 其他参考： 白盒测试：理论基础 4. 掌握功能测试需求分析确定测试优先级参考： 快速划分测试用例优先级 5. 掌握性能测试需求分析会用80-20原理计算负载量书本例题： 测试强度估算80-20原理：每个工作日中80%的业务在20%的时间内完成。举例：每年业务量集中在8个月，每个月20个工作日，每个工作日8个小时即每天80%的业务在1.6小时完成去年全年处理业务约100万笔，其中15%的业务处理中每笔业务需对应用服务器提交7次请求；其中70%的业务处理中每笔业务需对应用服务器提交5次请求；其余15%的业务处理中每笔业务需对应用服务器提交3次请求。根据以往统计结果，每年的业务增量为15%，考虑到今后3年业务发展的需要，测试需按现有业务量的两倍进行。 每年总的请求数：（100x15%x7+100x70%x5+100x15%x3）x2=1000万次/年 每天请求数：1000/160=6.25万次/天 每秒请求数：（62500x80%）/(8x20%x3600)=8.68次/秒即服务器处理请求的能力应达到9次/秒。 6. 设计功能测试用例测试用例模板（仅供参考） 项目/软件 XXX 程序版本 XXX 功能模块名 Login 编制人 XXXX 用例编号 XXXX 编制时间 XXXX 相关的用例 无 功能特性 用户身份验证 测试目的 验证是否输入合法的信息，允许合法登录，阻止非法登录 预置条件 无 特殊规格说明 如数据库访问权限 参考信息 需求说明中关于“登录”的说明 测试数据 用户名=yiii密码=1 操作步骤 操作描述 数据 期望结果 预期结果 实际结果 测试状态 1 输入用户名称按“登录”按钮 用户名=yiyh密码为空 显示警告信息，请输入用户名和密码 2 输入密码，按“登录”按钮 用户名为空密码=1 显示警告信息请输入用户名和密码 测试人员 开发人员 项目负责人 操作步骤需要写出所有情况 7. I/O接口测试，局部数据结构测试检查模块接口是否正确CheckList: 输入的实际参数与形式参数是否一致 个数、属性、量纲 调用其他模块的实际参数与被调模块的形参是否一致 个数、属性、量纲 全程变量的定义在各模块是否一致 外部输入、输出 文件、缓冲区、错误处理 其他 当一个模块执行外部I/O操作时，必须进行附加的接口测试 文件属性是否正确 OPEN/CLOSE语句是否正确？ 格式规约是否和I/O语句匹配？ 缓冲区大小是否和记录大小匹配？ 文件是否在打开之前被使用？ 是否处理了文件结束条件？ 是否处理了I/O错误？ 在输出信息里时候有文本错误？ 模块的局部数据结构是经常出现的错误源。应当设计测试用例以发现下列类型的错误 不正确或不一致的类型描述 错误的初始化或缺省值 不正确的（拼写错误的或被截断的）变量名字 不一致的数据类型 下溢、上溢和地址错误除了局部数据结构，全局数据对模块的影响在单元测试过程中应当进行审查。 检查局部数据结构完整性Checklist: 不适合或不相容的类型说明 变量无初值 变量初始化或默认值有错 不正确的变量名或从来未被使用过 出现上溢或下溢和地址异常 其他 8. 怎样对一段Java代码进行测试，找出代码错误参考：单元测试的步骤： 理解需求和设计 概览源代码 精读源代码 设计测试用例 搭建单元测试环境 执行测试 补充和完善测试用例 分析结果，给出评价 参考链接： 单元测试的步骤 9. 进行项目测试计划时间安排的时候，怎样才算是合理的时间安排？参考：测试计划时间安排上遵守：趋势收敛的原则，越到后面，周期越短，问题应该越少。那么测试执行的原则就是：尽可能的把问题都暴露在前面，这样才能保证测试时间上呈收敛趋势。 做测试计划时，测试轮次的安排，一般根据不同的项目来定，小项目2+1或者1+1，大项目3+1或者2+1。举例说明：假如现有一项目，测试总时间为10天，需要分3轮进行测试。那么测试时间的安排我们采取4、3、2的原则。第一轮（4天）：全面覆盖所有用例；第二轮（3天）：基本上是基本功能全覆盖（故要刷筛选好一级用例），回归问题单，缺陷比较多的模块功能全覆盖；第三轮（2天）：基本上是回归问题单+基本功能全覆盖（执行一级用例）。还有1天留着备用，若第3轮测试有未关闭的bug，需要再加一轮，用于回归问题。 以上就是常见测试计划安排模式：3+1模式。 参考链接： 如何合理安排测试时间 软件测试的测试计划是如何计算测试时间 10. 如果时间紧迫了，测试范围怎样裁剪？参考： 网上资料 部分不重要的需求可以裁剪，不进行测试 对测试范围按照重要性和风险进行优先级评定，优先测试重要的和风险大的 课本 优先级最高的需求功能（优先级如何确定） 新功能和编码改动较大（提高性能表现）的旧功能 经常容易出现问题部分的功能 一些经常被用户使用的功能和配置 11. QTP自动化测试的时候，怎样提高测试脚本执行效率？参考： 使用VBS文件来启动QTP 把变量和函数定义放到外部VBS文件，而不要放在Action中 通过AOM控制QTP重启来解决QTP内存泄露问题 尽量不要使用wait，而使用.sync或exist语句 使用with语句可以让代码更清晰，而且效率更好 使用OR要比DP快点 不要保存image和movie到测试结果中 把运行模式设置为fast 通过AOM控制QTP 在调用Action时使用相对路径 参考链接： QTP：如何优化测试脚本 提高测试效率 以及脚本结构化 如何让你的QTP脚本执行效率更高？ 12. 理解性能测试的指标和性能测试给出的结果曲线参考：性能测试的指标 bs结构程序一般会关注的通用指标如下： Web服务器指标指标： Avg Rps: 平均每秒钟响应次数=总请求时间 / 秒数； Avg time to last byte per terstion （mstes）：平均每秒业务脚本的迭代次数，有人会把这两者混淆； Successful Rounds：成功的请求； Failed Rounds ：失败的请求； Successful Hits ：成功的点击次数； Failed Hits ：失败的点击次数； Hits Per Second ：每秒点击次数； Successful Hits Per Second ：每秒成功的点击次数； Failed Hits Per Second ：每秒失败的点击次数； Attempted Connections ：尝试链接数； cs结构程序，由于一般软件后台通常为数据库，所以我们更注重数据库的测试指标： User 0 Connections ：用户连接数，也就是数据库的连接数量； Number of deadlocks：数据库死锁； Buffer Cache hit ：数据库Cache的命中情况 性能测试给出的结果曲线参考LoadRunner性能测试工具—（三）测试结果样例分析 13. 如果让你负责性能测试，你会按照什么思路开展工作？参考：性能测试的方法是通过模拟生产运行的业务压力量和使用场最组合,测试系统的性能是否满足生产的性能要求。即在特定的运行条件下验证系统的能力状况。主要强调在特定的软硬件环境、特定的测试业务场景下,获得系统的各个性能指标。而身为一个软件测试工程师应根据以下步骤开展工作： 制定目标和分析系统 选择测试度量的方法 学习的相关技术和工具 制定评估标准 设计测试用例 运行测试用例 分析测试结果 课本补充有关软件测试的作用 产品质量的保证 控制成本的关键 软件可靠性确认 让企业具备国际竞争的实力 QA、QC、QM QA 质量保证 QC 质量控制 QM 质量管理 软件测试人才需求快速增长的体现 中国软件产业正在快速增长，需要大量软件相关人才。 软件企业的发展要求测试人才达到一个合适的比例 软件企业开始认识到软件测试对于提高软件质量的重要性，开始重视软件测试。 软件测试技术的内容软件测试包括： 测试计划、测试流程、测试策略、设计测试用例、执行测试、撰写测试报告 单元测试、集成测试、系统测试、确认测试 手工测试、自动化测试 测试工具、缺陷管理和维护工具 编写操作手册、功能手册、系统管理手册、培训手册 维护文档、维护测试环境、分析问题、归纳推理能力 测试用例的组成 用例标识 用例名称 被测功能 用例目的 数据准备 测试步骤 预期结果 实际结果 测试人员 测试日期 编写测试用例的注意事项要解决4W问题 why when who what 测试用例说明包含的要素 标识符 测试项 输入说明 输出说明 环境要求 特殊要求 用例依赖性 测试的三大原则1. 尽早测试2. 连续测试3. 自动化测试 软件测试职业素质 软件测试员的目标：——发现潜在的软件缺陷 软件测试员应具备的素质： 具有探索精神 具有创造性 坚持不懈的精神 故障排除专家 判断准确 追求完美 沟通能力 软件危机内在的原因 在软件开发过程中，软件缺陷的积累和放大效应是导致软件危机的主要原因 人员和其他资源的投入导致开发成本急剧增加，带有缺陷的开发成果导致开发质量大幅下降，反复无常的修改导致开发效率严重底下 因此，迫切地需要规范化地过程来制约软件开发的无序性，便产生了软件工程。 怎样写测试计划 确定内容 总的测试计划 分阶段的测试计划 参考测试模板 考虑以下问题 测试问题 测试策略 测试技术 测试组织 测试准备 测试计划的用途 为测试中的管理工作和技术工作提供指导 确定达到测试目标和测试目的的必要的测试类型和范围 概述有效使用资源的时间和活动的时间顺序安排 通过建立需求跟踪矩阵，为可能的、最高水平的测试覆盖提供保证 概述测试程序脚本的详细内容，描述如何执行测试程序脚本 概述测试所需的人员、财力、设备和工具资源 测试计划的作用 避免测试的“事件驱动” 使测试工作和整个开发工作融合起来 资源和变更事先作为一个可控制的风险 测试需求分析 什么时候进行测试需求分析在开始测试设计之前确定测试需求 测试需求分析做什么？清晰地定义测试需求并形成文档，使所有工作人员理解测试工作的基础 测试需求分析的目的是什么？识别验证系统所需的不同类型的测试，在哪个测试阶段完成。 白盒测试能做什么？ 保证模块内的所有独立路径至少执行一次 执行所有逻辑判定为真和为假的情况 在循环可操作范围内，执行所有边界循环 运用内部数据结构以保证其有效性 单元测试方法在对每个模块进行单元测试时，需要考虑它和周围模块之间的相互联系。为模拟这一联系，在进行单元测试时，必须设置若干个辅助测试模块，这些辅助模块分为两种： 驱动模块。相当于被测模块的主程序，用以模拟被测模块的上级模块，用于接收测试数据，并把这些数据传送给被测模块，启动被测模块，最后输出实测结果。 桩模块。相当于被测模块调用的子模块，用以模拟被测模块的下级模块。 测试评估 软件测试的主要评测方法包括覆盖评测和质量评测。 覆盖评测是对测试完全程度的评测，它建立在测试覆盖基础上测试覆盖是由 测试需求和 测试用例的覆盖或 已执行代码的覆盖表示的 质量评测是对测试对象（系统或测试的应用程序）的可靠性、稳定性以及性能的评测。质量建立在对测试结果的评估和对测试过程中确定的缺陷及缺陷修复的分析的基础上。 功能测试一般什么时候执行 白盒测试可以在编码的早期进行 功能测试主要在后期执行 功能测试的两种策略 顺序测试每个程序特性的功能 一个模块一个模块的测试，即每个功能在其最先调用的地方测试 功能测试的特点 优点 对于较大的代码单元来说（子系统甚至系统级），黑盒测试效率高 测试人员不需要了解实现的细节，包括特定的编程语言 测试人员和编码人员是彼此独立的 从用户的视角进行测试，很容易被理解和接受 有助于暴露任何规格不一致或有歧义的问题 测试用例设计可以在规格完成之后马上进行 缺点 覆盖率较低，大概只能达到总代码量的30% 自动化测试的复用性较低 没有清晰的和简明的规格，测试用例是很难设计的 测试需求和用户需求的区别 测试范围变化 实现方式变化 用测试策略去过滤用户需求 标准手工功能测试和实用手工功能测试的比较 标准软件开发生命周期 实际软件开发生命周期 标准手工功能测试的过程 实用手工功能测试的过程 实用手工功能测试的关注重点 良好的测试用例的特征 可以最大程度地找出软件隐藏的缺陷 可以最高效率地找出软件缺陷 可以最大程度地满足测试覆盖要求 既不过分复杂，也不能过分简单 使软件缺陷的表现可以清楚的判定 不包含重复的测试用例 测试用例的内容清晰、格式一致、分类组织管理 为什么设计良好的（最佳）的测试用例 输入量太大 输出结果太多 软件实现途径太多 软件缺陷的标准不同 完全测试是不可能的 性能测试的类型 并发（竞争）测试 负载测试 压力测试 大数据量测试 疲劳测试 可靠性测试 基准测试 配置测试 性能测试的目标（问题：为了实现目标怎么选择性能测试类型） 评价系统当前性能 寻找瓶颈，优化性能 预测系统未来性能，可扩展性 系统的参数配置 发现一些软件算法方面的缺陷 产品评估/选型 性能测试关注的内容 是否满足需求 并发用户数/吞吐量 平均响应时间 服务器资源占用情况 故障恢复时间 负载量分析的步骤 识别性能测试的目标 与最终客户一起定义 文档化以确保一致 定义负载量 识别关键业务功能 定义场景如何被执行 近似的数据访问模式 识别用户类型和特性 选择测量点 编写负载量分析文档 用来创建有效的测试场景 与最终客户一起复审（获得负载量模型的认可） 软件安全性测试的方法 功能测试（专门设计的安全功能） 漏洞扫描 模拟攻击实验 侦听技术","categories":[{"name":"软件测试","slug":"软件测试","permalink":"http://yoursite.com/categories/软件测试/"}],"tags":[{"name":"软件测试","slug":"软件测试","permalink":"http://yoursite.com/tags/软件测试/"}]},{"title":"软件工程","slug":"软件工程","date":"2019-07-04T07:09:11.097Z","updated":"2019-07-04T11:29:48.341Z","comments":true,"path":"2019/07/04/软件工程/","link":"","permalink":"http://yoursite.com/2019/07/04/软件工程/","excerpt":"软件工程简答题1. 社会、健康、安全、法律、文化、环境对软件工程有什么影响？（举例子说明）","text":"软件工程简答题1. 社会、健康、安全、法律、文化、环境对软件工程有什么影响？（举例子说明） 答： 卓越工程师教育培养计划 金融危机会导致软件业风险的不确定增加。等等。。。 软件工程监理体系建设及其对软件产业影响研究 知识产权 软件工程环境 996ICU 隐私保护等等。 2. 以下是否是软件需求项？什么类别的需求项？ 目标软件必须用Java语言实现。约束性需求 目标软件必须有一个主控模块和分别移动、照相和岩石采集控制的三个子模块组成。否 目标软件必须在0.5秒内响应外部事件。非功能需求-性能需求 当目标软件与用户交互时，必须使用特定的菜单和对话框。否 3. 比较黑盒测试和白盒测试的优缺点。答： 黑盒测试的优点 比较简单，不需要了解程序内部的代码及实现。 与软件的内部实现无关。 从用户角度出发，能很容易的知道用户会用到哪些功能，会遇到哪些问题。 基于软件开发文档，所以也能知道软件实现了文档中的哪些功能。 在做软件自动化测试时较为方便。 黑盒测试的缺点 不可能覆盖所有的代码，覆盖率较低，大概只能达到总代码量的30%。 自动化测试的复用性较低。 白盒测试的优点 帮助软件测试人员增大代码的覆盖，提高代码的质量，发现代码中隐藏的问题。 白盒测试的缺点 程序运行会有很多不同的路径，不可能测试所有的运行路径。 测试基于代码，只能测试开发人员做的对不对，而不能知道设计的正确与否，可能会漏掉一些功能需求。 系统庞大时，测试开销会非常大。 4. 软件生存期模型各个模型的适用范围答： 瀑布模型适用范围：需求明确，小规模软件开发。 快速原型模型适用范围：用户需求不明确，需要通过构建原型来清楚地了解用户的真实需求。 增量模型适用范围：软件开发周期较长的软件，有持续的合作。 螺旋模型适用范围：内部软件开发的大规模软件项目。 喷泉模型适用模型：面向对象的软件开发过程。 5. 为什么要进行软件项目管理参考：任何项目都需要管理，只有认真地管理才能使项目成功地达到预期的目标。预期的目标应该包括以下方面： 达到项目预期的软件产品功能和性能要求，使用户认为这样的软件产品正是自己所期待的，也就是说软件产品达到了用户已认可的需求规格说明的要求。 时限要求。 项目开销限制在预算之内。 同时软件项目管理涉及的几个主要方面是人员、产品、过程和项目，即所谓的4P(People、Produce、Process、Project). 开发人员项目管理是对软件工作的管理，但归根结底是对人员行为的管理，就是对人员的管理。人的因素是软件工程的核心因素，对于这一核心因素的把握决定着项目的成败。在项目的人员管理上需要考虑的几个问题是：1). 利益相关方2). 团队负责人3). 团队集体 产品软件工程是软件项目的成果和预期的目标，然而，软件这种无形的产品在开发出来以前，要想准确地描述它的规模、工作量，甚至他的功能和性能是困难的。除此以外，软件需求的稳定性问题更增加了项目工作的难度。 产品的工作环境 产品的功能和性能 产品工作处理的是什么数据，经他处理后得到什么数据。 过程过程在软件工程项目中是重要的因素，它决定着项目中开展哪些活动以及对活动的要求和开展活动的顺序。 项目项目管理的任务是如何利用已有的资源，组织实施既定的项目，提交给用户适用的产品。在此我们将项目管理要开展的主要工作分为3类：1). 计划与计划管理，其中包括：项目策划及计划制定；项目估算；风险分析及风险管理；进度管理；计划跟踪与监督。2). 资源管理，包括：人员管理；成本管理。3). 成果要求管理，包括：需求管理；配置管理；质量管理。 从开发人员、产品、过程、项目四个方面进行论述 6. 为什么软件维护的费用一直那么高参考：软件维护不仅针对程序代码，而且还针对软件定义、开发的各个阶段生成的文档。而软件在设计阶段很难预料到这个软件交给谁，在什么时候进行什么样的维护工作。软件维护的依据只能靠软件文档和有关的设计信息。这样，软件维护人员不得不花费大量的劳动，用于软件系统的再分析和对软件信息的理解。因此软件的维护费用也就一直高居不下。 7. 软件生命周期，各个过程主要工作答： 可行性分析（研究）与计划阶段要确定该软件的开发目标和总的要求，要进行可行性分析、投资收益分析、制定开发计划，并完成可行性分析报告、开发文档等文档（输出）。 需求分析阶段由系统分析人员对被设计的系统进行系统分析，确定对该软件的各项功能、性能需求和设计约束，确定对文档编制的要求，作为本阶段工作的结果，输出有：软件需求规格说明(也称为：软件需求说明、软件规格说明)、数据要求说明和初步的用户手册应该编写出来。 设计阶段系统设计人员和程序设计人员应该在反复理解软件需求的基础上，提出多个设计，分析每个设计能履行的功能并进行相互比较，最后确定一个设计，包括该软件的结构、模块(或CSCI)的划分、功能的分配，以及处理流程。系统比较复杂的情况下，设计阶段应分解成概要设计阶段和详细设计阶段两个步骤。在一般情况下，完成的文档包括：结构设计说明、详细设计说明和测试计划初稿。 实现阶段要完成源程序的编码、编译(或汇编)和排错调试得到无语法错的程序清单，要开始编写进度日报、周报和月报(是否要有日报或周报，取决于项目的重要性和规模)，并且要完成用户手册、操作手册等面向用户的文档的编写工作，还要完成测试计划的编制。 测试阶段该程序将被全面地测试，已编制的文档将被检查审阅。一般要完成测试分析报告。作为开发工作的结束，所生产的程序、文档以及开发工作本身将逐项被评价，最后写出项目开发总结报告。 运行与维护阶段软件将在运行使用中不断地被维护，根据新提出的需求进行必要而且可能的扩充和删改、更新和升级。软件维护分为改正性维护、适应性维护和预防性维护，分别对应于前面的三个问题。改正性维护就是修改原有的缺陷、适应性维护就是使软件适应新的软硬件环境，预防性维护就是把今天的技术用在昨天的软件上，以期软件在明天还能使用。 8. 为什么程序员在进行单元测试时多以白盒测试为主，而软件测试工程师在进行系统集成测试多以黑盒测试为主？参考：白盒测试方法按照程序内部的结构测试程序，检验程序中的每条通路是否都能按预定要求正确工作，而不顾它的功能。 黑盒测试并不涉及程序的内部结构和内容特性，主要根据规格说明，只依靠被测试程序的输入和输出之间关系或程序的功能来设计测试用例。 论述题1. 用户最终要执行的使用的最终产品写出来的代码，只要在开发阶段做的好，产品就是一定成功的？ 2. 软件在交付的时候，如果软件在运行的时候没有问题就是高质量的软件 3. 从用户得到的原始需求不用分析就可以作为软件设计阶段的依据。","categories":[{"name":"软件工程","slug":"软件工程","permalink":"http://yoursite.com/categories/软件工程/"}],"tags":[{"name":"软件工程","slug":"软件工程","permalink":"http://yoursite.com/tags/软件工程/"}]},{"title":"操作系统","slug":"操作系统","date":"2019-07-01T05:28:14.873Z","updated":"2019-07-03T12:15:28.888Z","comments":true,"path":"2019/07/01/操作系统/","link":"","permalink":"http://yoursite.com/2019/07/01/操作系统/","excerpt":"操作系统信号量解决进程同步问题例题：桌子上有一只盘子，最多可容纳两个水果，每次只能放入或取出一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，两个儿子专等吃盘子中的橘子，两个女儿专等吃盘子中的苹果。请用信号量操作来实现爸爸、妈妈、儿子、女儿之间的同步与互斥关系。","text":"操作系统信号量解决进程同步问题例题：桌子上有一只盘子，最多可容纳两个水果，每次只能放入或取出一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，两个儿子专等吃盘子中的橘子，两个女儿专等吃盘子中的苹果。请用信号量操作来实现爸爸、妈妈、儿子、女儿之间的同步与互斥关系。1234567891011121314151617181920212223242526272829303132333435semaphore s=2,so=0,sa=0;//s表示盘空，so表示橘子，sa表示苹果。CobeginVoid father(void)&#123;while(1)&#123;p(s);put apple();v(sa);&#125;&#125;Void mother(void)&#123;while(1)&#123;p(s);put orange();v (so);&#125;&#125;Void son(void)&#123;while(1)&#123;p(so);eat orange();v(s);&#125;&#125;Void daughter(void)&#123;while(1)&#123;p(sa);eat apple();v(s);&#125;&#125;Coend PV操作参考进程同步之信号量机制（pv操作）及三个经典同步问题 作业调度算法（先来先服务算法、短作业优先算法），计算周转时间、带权周转时间、平均周转时间、平均带权周转时间 周转时间=完成时间-提交时间带权周转时间=周转时间/执行时间平均周转时间=每个周转时间之和/作业总数平均带权周转时间=每个带权周转时间之和/作业总数 例题：求解下表中4个作业在FCFS（先来先服务算法）和SJF（短作业优先算法）调度算法下的调度次序、周转时间、带权周转时间、平均周转时间、平均带权周转时间。 作业 提交时间 执行时间 开始时间 完成时间 周转时间 带权周转时间 1 8.00 2.00 2 8.50 0.50 3 9.00 0.10 4 9.50 0.20 先来先服务调度算法 作业 提交时间 运行时间 开始时间 完成时间 周转时间 带权周转时间 执行顺序 1 8.00 2.00 8.00 10.00 2.00 1 1 2 8.50 0.50 10.00 10.50 2.00 4 2 3 9.00 0.10 10.50 10.60 1.60 16 3 4 9.50 0.20 10.60 10.80 1.30 6.5 4 平均周转时间=1.725平均带权周转时间=6.875 短作业优先调度算法 作业 提交时间 运行时间 开始时间 完成时间 周转时间 带权周转时间 执行顺序 1 8.00 2.00 8.00 10.00 2.00 1 1 2 8.50 0.50 10.30 10.80 2.30 4.6 4 3 9.00 0.10 10.00 10.10 1.10 11 2 4 9.50 0.20 10.10 10.30 0.80 4 3 平均周转时间=1.55平均带权周转时间=5.15 先来先服务算法先来先服务根据作业的提交时间来执行作业，提交的时间早则首先被执行。 短作业优先算法根据执行时间来作为执行顺序，同时第一个到达的作业要首先被执行，之后再根据运行时间的长短来执行，短的则优先执行。 资源分配图的简化资源分配图 在资源分配图中，通常使用圆圈来表示每个进程，用方框表示每种资源类型。由于同一资源类型可能有多个实例，所以在矩形中用圆点数表示实例数。 实例 说明 进程P1申请一个R1类资源 系统分配一个R1类资源给进程P1，此时系统还剩下2个R1类资源 进程P1申请2个R类资源 系统分配2个R1类资源给进程P1，此时系统还剩下1个R1类资源 系统分配一个R1类资源给进程P2，然后分配一个R1类资源给进程P1，最后进程P1收到一个R1类资源又继续申请一个R1类资源，此时系统还剩下一个R1类资源可以分配给进程P1，但是还没有分配给P1 系统分配一个R1类资源给进程P2，然后又分配一个R1类资源给进程P1，最后进程P1收到一个R1类资源又继续申请一个R1类资源，此时系统已经没有R1类资源可以分配给进程P1，于是进程P1收到阻塞 例题： 第一步：先看R1资源，它有三个箭头是向外的，因此它一共给进程分配了3个资源，此时，R1没有空闲的资源剩余。 第二步：再看R2资源，它有一个箭头是向外的，因此它一共给进程分配了1个资源，此时，R2还剩余一个空闲的资源没分配。 第三步：看完资源，再来看进程，先看进程P2，它只申请一个R1资源，但此时R1资源已经用光了，所以，进程P2进入阻塞状态，因此，进程P2暂时不能化成孤立的点。 第四步：再看进程P1，它只申请一个R2资源，此时，系统还剩余一个R2资源没分配，因此，可以满足P1的申请。这样，进程P1便得到了它的全部所需资源，所以它不会进入阻塞状态，可以一直运行，等它运行完后，我们再把它的所有的资源释放。相当于：可以把P1的所有的边去掉，变成一个孤立的点，如下图所示： 第五步：进程P1运行完后，释放其所占有的资源（2个R1资源和1个R2资源），系统回收这些资源后，空闲的资源便变成2个R1资源和1个R2资源，由于进程P2一直在申请一个R1资源，所以此时，系统能满足它的申请。这样，进程P2便得到了它的全部所需资源，所以它不会进入阻塞状态，可以一直运行，等它运行完后，我们再把它的所有的资源释放。相当于：可以把P2的所有的边都去掉，化成一个孤立的点，变成下图： 由于这个资源分配图可完全简化，因此，不会产生死锁。而如果资源分配图中的点，最终不能够化成孤立的点，则进程资源图不能够完全简化，从而会发生死锁。 分页地址变换 地址变换处理 得到页号：自动将逻辑地址分为页号和页内地址 用页号查页表，得到块号 将块号与页内地址拼接，即得物理地址 分页存储逻辑地址转物理地址例题：已知某个分页系统，页面大小为1K(即1024字节)，某一个作业有4个页面，分别装入到主存的第3、4、6、8块中，求逻辑地址2100对应的物理地址。 第一步：求逻辑地址的页号 = 2100/1024=2 （整除） 第二步：求页内偏移量 = 2100 % 1024 =52 （取余） 第三步：产生页表： 页号 块号 0 3 1 4 2 6 3 8 第四步：根据逻辑地址的页号查出物理地址的页框号/帧号：如上图，逻辑地址的第2页对应物理地址的第6页。 第五步：求出物理地址 = 6*1024 + 52 = 6196 设有8页的逻辑地址空间，每页有1024个字节，它们被映射到32块的物理存储区，那么逻辑地址的有效位是多少，物理地址至少多少位？ 逻辑地址：8x1024=2^3x2^10=2^13物理地址：32x1024=2^5x2^10=2^15逻辑地址的有效位是13，物理地址的有效位是15. 十六进制逻辑地址转物理地址一分页存储管理系统中逻辑地址长度为16位，页面大小为4KB字节，现有一逻辑地址为2F6AH，且第0、1、2页依次存放在物理块5、10、11中。求逻辑地址2F6AH对应的物理地址 解： 第一步：将逻辑地址2F6AH转换为二进制为：0010 1111 0110 1010 第二步：由于页面大小为4KB字节，（4KB=2的12次方）。所以逻辑地址的后12位为“页内地址”(也叫做页内偏移量) 第三步：由于逻辑地址的后12位为页内地址，所以剩下的前4位为页号：即0010为页号 第四步：根据页表可知，0010(十进制为2)对于的页框号为11(二进制为1011)所以最终的物理地址为：1011 1111 0110 1010即BF6AH 页面置换算法 定义：选择换出页面的算法评价依据：页面更换频率（缺页率）。 缺页率=缺页次数/页面总访问次数 最佳置换算法（OPT）最佳置换算法所选择淘汰的页面是最长（未来）时间内不再被访问的页面。 例如：系统为某进程分配3个物理块，进程访问页面的顺序是0，7，6，5，7，4，7，3，5，4，7，4，5，6，5，7，6，0，7，6。 访问页面 0 7 6 物理块 0 0 0 7 7 6 接下来下一个进入的数字是5，然后需要淘汰最久不被访问的页面。 首先，需要看0，7，6的哪个是最久不被访问的页面。0在第18次再次访问。7在第5次再次被访问。6在第14次再次被访问。因此需要淘汰0。 按照如上的规律，可以得到以下的结果。 访问页面 0 7 6 5 7 4 7 3 5 4 7 4 5 6 5 7 6 0 7 6 物理块 0 0 0 5 5 5 5 5 5 5 5 5 5 5 5 5 5 0 0 0 7 7 7 7 7 7 3 3 3 7 7 7 7 7 7 7 7 7 7 6 6 6 4 4 4 4 4 4 4 4 6 6 6 6 6 6 6 缺页中断 x x x x x x x x x 缺页率：9/20*100%=36% 缺页中断：在请求分页系统中，可以通过查询页表中的状态位来确定所要访问的页面是否存在于内存中。每当所要访问的页面不在内存时，会产生一次缺页中断，此时操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存。 通俗的讲也就是每次往物理块中添加数据就会产生一次缺页中断。 先进先出页面置换算法（FIFO）先进先出页面置换算法淘汰的页面是淘汰最先进入内存的页面。 访问页面 6 0 1 2 0 3 0 4 2 3 物理块 6 6 6 2 2 2 2 4 4 4 0 0 0 0 3 3 3 2 2 1 1 1 1 0 0 0 3 缺页中断 x x x x x x x x x 缺页率：9/10*100%=90% 最近最久未使用置换算法（LRU）最近最久未使用置换算法淘汰的页面是淘汰最近最久未使用的页面。 访问页面 2 3 2 1 5 2 4 5 3 2 5 2 物理块 2 3 2 1 5 2 4 5 3 2 5 2 2 3 2 1 5 2 4 5 3 2 5 3 2 1 5 2 4 5 3 3 缺页中断 x x x x x x x 缺页率：7/12*100%=58.3% 堆栈实现LRU：系统使用特殊的堆栈来存放内存中每一个页面的页号。每当访问一页时就调整一次，即把被访问页面的页号从栈中移出再压入栈顶。因此，栈顶始终是最新被访问页面的页号。当发生缺页中断时，总是淘汰栈底页号所对应的页面。 磁盘的调度算法先来先服务（FCFS）先来先服务算法是根据进程请求访问磁盘的先后顺序进行调度。例题：某一磁盘请求序列（磁盘号）：98，183，37，122，14，124，65，61.按照先来先服务磁盘调度对磁盘进行请求服务，假设当前磁头在53道上，则磁臂总移动倒数为多少？ 下一个磁道 移动磁道数 98 45 183 85 37 146 122 85 14 108 124 110 65 59 61 4 总移动磁道数=45+85+146+85+108+110+59+4=642. 最短寻道时间优先磁盘调度算法（SSTF）最短寻道时间优先磁盘调度算法是每次都优先满足当前磁头位置最近的磁道访问请求。 例题：若干个等待访问磁盘者依次要访问的磁道为19，43，40，4，79，11，76，当前磁头位于42号柱面，若用最短寻道时间优先磁盘调度算法，则访问序列是什么？思路：将要访问的磁道与当前磁头所在柱面相减并取绝对值，绝对值越小的优先访问。 访问序列为40，43，19，11，4，76，79. 扫描算法（SCAN） 考虑当前移动方向，一直移动到最外/内层磁道时，折返，进行反方向移动。就好比电梯。 寻道方向：…，里-&gt;外，外-&gt;里，….; 若干个等待访问磁盘者依次要访问的磁道为86,147,91,177,94,150,102,175,130，当前磁头位于143号柱面，刚刚处理完125号柱面，使用SCAN算法则访问序列是什么？ 答： 当前方向：从143向磁道号增加的方向 依次访问：147，150，175，177 反方向：130，102，94，91，86（电梯原理） 循环扫描（CSCAN） 循环扫描 寻道方向：…..,里-&gt;外，里-&gt;外，….。或者相反。 若干个等待访问磁盘者依次要访问的磁道为86,147,91,177,94,150,102,175,130，当前磁头位于143号柱面，刚刚处理完125号柱面，使用CSCAN算法则访问序列是什么？ 答： 当前方向：从143向磁道号增加的方向 依次访问：147，150，175，177 再从0开始增加方向：86，91，94，102，130 磁盘空间分配多级索引分配例题：设一个盘块大小为1k,每个盘块号占4Byte,若系统采用2级索引，求文件的最大长度。 答:每个索引块最多可存放1k/4=256个盘块号；采用2级索引是，一个文件最多可拥有的数据块数为256x256=2^6x2^10=64k文件的最长长度为64kx1k=64m. 混合索引分配存放在某磁盘上的文件系统采用混合索引分配方式，其中FCB由6个地址项构成，前四个地址项是直接寻址方式，第五个地址项是一次间接寻址方式，第六个地址项是二次间接寻址。若每个盘块的大小为1KB，盘块号用4个字节描述。那么： （1）源文件系统允许文件的最大长度是多少？（2）将文件的字节偏移量800、8193和819300 转换为物理块号和块内偏移。答：（1）每个盘块能存放的盘块号的个数：1024/4=256文件系统允许的文件最大长度：（4+256+256x256）x1K=65796KB （2） 800/1024商0余800，因为0&lt;4，所以，第一个地址项中存放的块号即为其所在物理块号，块内偏移800。 8193/1024商8余1，4&lt;=8&lt;4+256，所以一次间接寻址，8-4=4，读第五个地址项中存放的块号物理块的内容，其内容中的第五个块号即为其所在物理块号，块内偏移1。 819300/1024商800余100，4+256&lt;=800&lt;4+256+256x256，所以二次间接寻址，800-(4+256)=540，540/256商2余28，读第六个地址项中存放的块号的物理块的内容，再读其内容中的第三个块号所在物理块的内容，其内容的第29个块号即为其所在物理块号，块内偏移为100。 磁盘空间的管理位置分配位示图位示图：用二进制的一位表示磁盘中一个盘块的使用情况。 “0”，对应块是空闲块； “1”，对应块已被分配出去。 盘块分配(1) 顺序扫描位示图，从中找出一个或一组其值为“0”的二进制位(“0”表示空闲)。(2) 将所找到的一个或一组二进制位， 转换成与之相应的盘块号。假定找到的其值为“0”的二进制位，位于位示的第i行、第j列，则其相应的盘块号应按下式计算：b=n(i-1)+j式中， n代表每行的位数。(3) 修改位示图， 令map［i,j］=1。 盘块的回收(1) 将回收盘块的盘块号转换成位示图中的行号和列号。 转换公式为： i=(b-1)DIV n+1 j=(b-1)MOD n+1(2) 修改位示图。 令map ［i,j］=0。 例题：有一计算机系统采用如下图所示的位示图（行号、列号都从0开始编号）来管理空闲盘块。如果盘块从1开始编号，每个盘块的大小为1KB。 （1）现要为文件分配两个盘块，试具体说明分配过程。 （2）若要释放磁盘的第300块，应如何处理？","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/categories/操作系统/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/tags/操作系统/"}]},{"title":"Spring Boot整合Druid","slug":"Spring Boot 整合Druid","date":"2019-06-08T06:18:16.866Z","updated":"2019-06-30T05:43:06.735Z","comments":true,"path":"2019/06/08/Spring Boot 整合Druid/","link":"","permalink":"http://yoursite.com/2019/06/08/Spring Boot 整合Druid/","excerpt":"Spring Boot整合Druid","text":"Spring Boot整合Druid pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-06-data-jdbc&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;spring-boot-06-data-jdbc&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--引入druid数据源--&gt; &lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.17&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; application.yml123456789101112131415161718192021222324spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/jdbc username: root password: root type: com.alibaba.druid.pool.DruidDataSource # 数据源其他配置 initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，&apos;wall&apos;用于防火墙 filters: stat,wall maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourceStat: true connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500 DruidConfig.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.example.springboot.config;import com.alibaba.druid.pool.DruidDataSource;import com.alibaba.druid.support.http.StatViewServlet;import com.alibaba.druid.support.http.WebStatFilter;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.boot.web.servlet.FilterRegistrationBean;import org.springframework.boot.web.servlet.ServletRegistrationBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import javax.sql.DataSource;import java.util.Arrays;import java.util.HashMap;import java.util.Map;/** * @author Yan * @date 2019/6/8 13:46 */@Configurationpublic class DruidConfig &#123; @ConfigurationProperties(prefix = &quot;spring.datasource&quot;) @Bean public DataSource druid()&#123; return new DruidDataSource(); &#125; //配置Druid的监控 //1、配置一个管理后台的Servlet @Bean public ServletRegistrationBean statViewServlet()&#123; ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), &quot;/druid/*&quot;); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put(&quot;loginUsername&quot;,&quot;admin&quot;); initParams.put(&quot;loginPassword&quot;,&quot;123456&quot;); initParams.put(&quot;allow&quot;,&quot;&quot;);//默认就是允许所有访问 initParams.put(&quot;deny&quot;,&quot;192.168.15.21&quot;); //拒绝哪些ip访问 bean.setInitParameters(initParams); return bean; &#125; //2、配置一个web监控的filter @Bean public FilterRegistrationBean webStatFilter()&#123; FilterRegistrationBean bean = new FilterRegistrationBean(); bean.setFilter(new WebStatFilter()); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put(&quot;exclusions&quot;,&quot;*.js,*.css,/druid/*&quot;); bean.setInitParameters(initParams); bean.setUrlPatterns(Arrays.asList(&quot;/*&quot;)); return bean; &#125;&#125;","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/categories/Spring-Boot/"},{"name":"整合Druid","slug":"Spring-Boot/整合Druid","permalink":"http://yoursite.com/categories/Spring-Boot/整合Druid/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"},{"name":"整合Druid","slug":"整合Druid","permalink":"http://yoursite.com/tags/整合Druid/"}]},{"title":"搭建PHP环境（Windows）","slug":"搭建php环境","date":"2019-05-27T14:25:36.188Z","updated":"2019-07-14T13:12:02.056Z","comments":true,"path":"2019/05/27/搭建php环境/","link":"","permalink":"http://yoursite.com/2019/05/27/搭建php环境/","excerpt":"搭建PHP环境（Windows）Apache 下载下载地址：Apache msi","text":"搭建PHP环境（Windows）Apache 下载下载地址：Apache msi Apache 安装 双击下载的文件。 相关配置。 选择自定义安装模式 Apache 目录结构说明 Apache-httpd.exe介绍Httpd.exe的详细应用 服务器进程：运行之后才能够使用。 用来查看Apache具有哪些功能以及配置文件是否有错：httpd或者httpd.exe（文件所在目录） 查看使用的模块：httpd -M 验证配置文件是否有效：httpd -t PHP 安装下载下载地址：PHP 7.3 (7.3.7) 关于php下载时VC各版本的区别和Non Thread Safe、Thread safe的简单辨析 参考：php下载时VC各版本的区别和Non Thread Safe、Thread safe的简单辨析 安装 解压缩 将压缩包放到E:/server/,同时重命名为PHP7","categories":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/categories/PHP/"},{"name":"搭建PHP环境（Windows）","slug":"PHP/搭建PHP环境（Windows）","permalink":"http://yoursite.com/categories/PHP/搭建PHP环境（Windows）/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/tags/PHP/"},{"name":"搭建PHP环境（Windows）","slug":"搭建PHP环境（Windows）","permalink":"http://yoursite.com/tags/搭建PHP环境（Windows）/"}]},{"title":"活动的生命周期","slug":"活动的生命周期","date":"2019-05-26T03:54:10.299Z","updated":"2019-04-18T04:02:37.139Z","comments":true,"path":"2019/05/26/活动的生命周期/","link":"","permalink":"http://yoursite.com/2019/05/26/活动的生命周期/","excerpt":"活动的生命周期返回栈Android中的活动是可以层叠的。每启动一个新的活动，就会覆盖在原活动上，然后点击Back键会销毁最上面的活动，下面的一个活动就会重新显示出来。","text":"活动的生命周期返回栈Android中的活动是可以层叠的。每启动一个新的活动，就会覆盖在原活动上，然后点击Back键会销毁最上面的活动，下面的一个活动就会重新显示出来。 Android是使用任务（Task）来管理活动的，一个任务就是一组存放在栈里的活动的集合，这个栈也被称作返回栈（Back Stack）。栈是一种后进先出的数据结构，在默认情况下，每当启动一个新的活动，它会在返回栈中入栈，并处于栈顶的位置。而每当我们按下Back键或调用finfish()方法去销毁一个活动时，处于栈顶的活动会出栈，这时前一个入栈的活动就会重新处于栈顶的位置。系统总是会显示处于栈顶的活动给用户。 活动状态每个活动在其生命周期最多可能会有4种状态。 运行状态当一个活动位于返回栈的栈顶时，这时互动就处于运行状态。系统最不愿意回收的就是处于运行状态的活动，这会给用户带来非常差的使用体验。 暂停状态当一个活动不再处于栈顶位置，但仍然可见时，这时活动就进入了暂停状态。 停止状态当一个活动不在处于栈顶位置，并且完全不可见的时候，就进入了停止状态。系统仍然会为这种活动保存相应的状态和成员变量，但是这并不是完全可靠的，当其他地方需要内存时，处于停止状态的活动有可能会被系统回收。 销毁状态当一个活动从返回栈中移除后就变成了销毁状态。系统会最倾向于回收处于这种状态的活动，从而保证手机的内存充足。 活动的生存周期Activity类中定义了7个回调方法，覆盖了活动生命周期的每一个环节。 onCreate() 这个方法会在活动第一次被创建的时候调用。 onStart() 这个方法在活动由不可见变为可见的时候调用。 onResume() 这个方法在活动准备好和用户进行交互的时候调用。此时活动一定位于返回栈的栈顶，并且处于运行状态。 onPause() 这个方法在系统准备去启动或者恢复另一个活动的时候调用。 onStop() 这个方法在活动完全不可见的时候调用。它和onPause()方法的主要区别在于，如果启动的新活动是一个对话框式的活动，那么onPause()方法会得到执行，而onStop()方法并不会执行。 onDestroy() 这个方法在活动被销毁之前调用，之后的活动的状态将变为销毁状态。 onRestart() 这个方法在活动由停止状态变为运行状态之前调用，也就是活动被重新启动了。 以上七个方法中除了onRestart()方法，其他都是两两相对的，从而又可以将活动分为3种生存期。 完整生存期 onCreate() onDestroy() 可见生存期 onStart() onStop() 前台生存期 onResume() onStop() 体验活动的生命周期源代码：https://github.com/yanxin152133/Android/tree/master/Activitylive","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"活动的生命周期","slug":"Android/活动的生命周期","permalink":"http://yoursite.com/categories/Android/活动的生命周期/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"活动的生命周期","slug":"活动的生命周期","permalink":"http://yoursite.com/tags/活动的生命周期/"}]},{"title":"个人觉得比较好的一些插件","slug":"插件","date":"2019-05-26T03:54:10.288Z","updated":"2019-05-08T13:36:55.386Z","comments":true,"path":"2019/05/26/插件/","link":"","permalink":"http://yoursite.com/2019/05/26/插件/","excerpt":"Visual Studio CodeChinese (Simplified) Language Pack for Visual Studio Code适用于 VS Code 的中文（简体）语言包。","text":"Visual Studio CodeChinese (Simplified) Language Pack for Visual Studio Code适用于 VS Code 的中文（简体）语言包。 Markdown Preview EnhancedMarkdown Preview Enhanced 是一款为 Atom 以及 Visual Studio Code 编辑器编写的超级强大的 Markdown 插件。 这款插件意在让你拥有飘逸的 Markdown 写作体验。 City Lights Icon package一个美化 Visual Studio Code 图标的插件。 浏览器插件广告净化器免费高效的广告过滤工具：可以过滤烦人的视频广告、弹窗广告、大横幅广告等网页广告，让你清爽浏览网页。 下载地址：谷歌浏览器 火狐浏览器 Convertio一个文件转换器。网址：https://convertio.co/zh/ 适用于Chrome的Web服务器Web Server for Chrome适用于Chrome的Web服务器使用HTTP通过网络从本地文件夹提供网页。可离线运行。","categories":[{"name":"插件","slug":"插件","permalink":"http://yoursite.com/categories/插件/"}],"tags":[{"name":"插件","slug":"插件","permalink":"http://yoursite.com/tags/插件/"}]},{"title":"快速搭建一个SSM项目","slug":"快速搭建一个SSM项目","date":"2019-05-26T03:54:10.281Z","updated":"2019-03-26T12:53:41.029Z","comments":true,"path":"2019/05/26/快速搭建一个SSM项目/","link":"","permalink":"http://yoursite.com/2019/05/26/快速搭建一个SSM项目/","excerpt":"快速搭建一个SSM项目创建项目 在Intelli IDEA的菜单栏中选择【File】→【New】→【project】在弹出的窗口中选择【Maven】,之后操作如下图：","text":"快速搭建一个SSM项目创建项目 在Intelli IDEA的菜单栏中选择【File】→【New】→【project】在弹出的窗口中选择【Maven】,之后操作如下图： 填写下图中的【groupId】和【ArtifactId】。 接着指定archetypeCatalog为internal,即可使用maven默认的archetyppe-catalog.xml，而不用从remote下载。 然后填写项目名称和路径。 接着在/src/main目录下创建java和test目录，并标记为Sources文件，再创建resources目录，并标记为Resources文件。方法如下图所示： 整个目录结构如下图： tomcat配置： 配置文件基本相同，可参考如下链接： Intelli IDEA整合SSM 参考使用Idea创建一个JavaWeb的SSM(maven)项目~（史上最详细,傻瓜式教学，跟着我的做，不会你找我）解决Idea创建JavaWeb项目生成的web.xml没有头文件的问题(超级详细)","categories":[{"name":"SSM","slug":"SSM","permalink":"http://yoursite.com/categories/SSM/"},{"name":"快速搭建一个SSM项目","slug":"SSM/快速搭建一个SSM项目","permalink":"http://yoursite.com/categories/SSM/快速搭建一个SSM项目/"}],"tags":[{"name":"快速搭建一个SSM项目","slug":"快速搭建一个SSM项目","permalink":"http://yoursite.com/tags/快速搭建一个SSM项目/"}]},{"title":"在活动中使用Toast","slug":"在活动中使用Toast","date":"2019-05-26T03:54:10.270Z","updated":"2019-04-17T10:13:01.490Z","comments":true,"path":"2019/05/26/在活动中使用Toast/","link":"","permalink":"http://yoursite.com/2019/05/26/在活动中使用Toast/","excerpt":"在活动中使用ToastToast是Android系统提供的一种非常好的提醒方式，在程序中可以使用它将一些短小的信息通知给用户，这些消息会在一段时间后自动消失，并且不会占用任何屏幕空间。","text":"在活动中使用ToastToast是Android系统提供的一种非常好的提醒方式，在程序中可以使用它将一些短小的信息通知给用户，这些消息会在一段时间后自动消失，并且不会占用任何屏幕空间。 创建布局activity_main.xml：123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;Button android:id=&quot;@+id/button&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Button&quot; /&gt; &lt;/LinearLayout&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 为Button添加事件1234567891011protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button=findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(MainActivity.this,&quot;你点击了Button&quot;,Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"在活动中使用Toast","slug":"Android/在活动中使用Toast","permalink":"http://yoursite.com/categories/Android/在活动中使用Toast/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"在活动中使用Toast","slug":"在活动中使用Toast","permalink":"http://yoursite.com/tags/在活动中使用Toast/"}]},{"title":"在活动中使用Menu","slug":"在活动中使用Menu","date":"2019-05-26T03:54:10.257Z","updated":"2019-04-17T13:49:13.802Z","comments":true,"path":"2019/05/26/在活动中使用Menu/","link":"","permalink":"http://yoursite.com/2019/05/26/在活动中使用Menu/","excerpt":"在活动中使用Menu首先在res目录中下新建一个menu文件夹，右击res目录–&gt;New–&gt;Directory,输入文件夹名menu，点击OK。接着在这个文件夹下新建一个名叫main的菜单文件，右击menu文件夹–&gt;New–&gt;Menu resource file。文件名为main,点击OK完成创建。然后在main.xml中添加如下代码：","text":"在活动中使用Menu首先在res目录中下新建一个menu文件夹，右击res目录–&gt;New–&gt;Directory,输入文件夹名menu，点击OK。接着在这个文件夹下新建一个名叫main的菜单文件，右击menu文件夹–&gt;New–&gt;Menu resource file。文件名为main,点击OK完成创建。然后在main.xml中添加如下代码：12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:id=&quot;@+id/add_item&quot; android:title=&quot;Add&quot;/&gt; &lt;item android:id=&quot;@+id/remove_item&quot; android:title=&quot;Remove&quot;/&gt;&lt;/menu&gt; 其中创建了两个菜单项，其中&lt; item &gt;标签就是用来创建具体某一个菜单项，然后通过android:id给这个菜单项指定一个唯一的标识符，通过android:title给这个菜单项指定一个名称。 接着在MainActivity中重写onCreateOptionMeu()方法（Windows快捷键为Ctrl+O），然后修改其代码，如下：12345@Override public boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.main, menu); return true; &#125; 然后在MainActivity中重写onOptionsItemSeleted()方法，方法同上，同时修改其代码如下：12345678910111213@Override public boolean onOptionsItemSelected(MenuItem item) &#123; switch (item.getItemId()) &#123; case R.id.add_item: Toast.makeText(this, &quot;You clicked add&quot;, Toast.LENGTH_SHORT).show(); break; case R.id.remove_item: Toast.makeText(this, &quot;You clicked remove&quot;, Toast.LENGTH_SHORT).show(); break; default: &#125; return true; &#125; 最后运行程序。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"在活动中使用Menu","slug":"Android/在活动中使用Menu","permalink":"http://yoursite.com/categories/Android/在活动中使用Menu/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"在活动中使用Menu","slug":"在活动中使用Menu","permalink":"http://yoursite.com/tags/在活动中使用Menu/"}]},{"title":"创建自定义控件","slug":"创建自定义控件","date":"2019-05-26T03:54:10.229Z","updated":"2019-04-19T09:57:47.019Z","comments":true,"path":"2019/05/26/创建自定义控件/","link":"","permalink":"http://yoursite.com/2019/05/26/创建自定义控件/","excerpt":"创建自定义控件创建一个标题栏。","text":"创建自定义控件创建一个标题栏。 新建一个title.xml布局title.xml 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;Button android:id=&quot;@+id/title_back&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center&quot; android:layout_margin=&quot;5dp&quot; android:text=&quot;back&quot; android:textColor=&quot;#000&quot; /&gt; &lt;TextView android:id=&quot;@+id/title_text&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_weight=&quot;1&quot; android:gravity=&quot;center&quot; android:text=&quot;Title Text&quot; android:textColor=&quot;#000&quot; android:textSize=&quot;24sp&quot; /&gt; &lt;Button android:id=&quot;@+id/title_edit&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center&quot; android:layout_margin=&quot;5dp&quot; android:text=&quot;Edit&quot; android:textColor=&quot;#000&quot; /&gt;&lt;/LinearLayout&gt; activity_main.xml 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;include layout=&quot;@layout/title&quot; /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 隐藏系统自带的标题栏MainActivity 123456789101112public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ActionBar actionBar = getSupportActionBar(); if (actionBar != null) &#123; actionBar.hide(); &#125; &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"创建自定义控件","slug":"Android/创建自定义控件","permalink":"http://yoursite.com/categories/Android/创建自定义控件/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"创建自定义控件","slug":"创建自定义控件","permalink":"http://yoursite.com/tags/创建自定义控件/"}]},{"title":"分析项目结构（以HelloWorld项目为例）","slug":"分析项目结构","date":"2019-05-26T03:54:10.218Z","updated":"2019-04-12T02:56:53.402Z","comments":true,"path":"2019/05/26/分析项目结构/","link":"","permalink":"http://yoursite.com/2019/05/26/分析项目结构/","excerpt":"分析你的第一个Android程序以HelloWorld项目为例，其项目结构如下图：(首先先将项目结构模式切换成Project，这才是项目真实的目录结构)","text":"分析你的第一个Android程序以HelloWorld项目为例，其项目结构如下图：(首先先将项目结构模式切换成Project，这才是项目真实的目录结构) 项目结构 项目结构1..gradle和.idea这两个目录下是Android Studio自动生成的文件，不需要手动编辑，也无需关心。 2.app项目中的代码、资源等内容几乎都放置在这个目录下。 3.gradle这个目录包含了gradle wrapper 的配置文件，使用gradle wrapper 的方式不需要提前将gradle 下载好，而是自动根据本地的缓存情况决定是否需要联网下载gradle 。Android Studio默认没有启用gradle wrapper 的方式，如需打开，可以点击File–&gt;Settings–&gt;Bulid,Execution,Deployment–&gt;Gradle,进行配置更改。 4..gitignore这个文件是用来将指定的目录或文件排除在版本控制之外的。 5.build.gradle这个是项目全局的gradle构建脚本，通常这个文件中的内容是不需要修改的。 6.gradle.properties这个是全局的gradle配置文件，在这里配置的属性将会影响到项目中所有的gradle编译脚本。 7.gradlew和gradlew.bat这两个文件是用来在命令行界面中执行gradle命令的，其中gradlew是在Linux或Mac系统中使用的，gradlew.bat是在Windows系统中使用的。 8.HelloWorld.imiiml文件是所有IntelliJ IDEA项目都会生成的一个文件，用于标识这是一个IntelliJ IDEA项目，不需要修改该文件。 9.local.properties这个文件用于指定本机中的Android SDK路径，通常是自动生成的，不需要修改。若Android SDK发生变化则进行修改。 10.settings.gradle这个文件用于指定项目中所有引入的模块。通常情况下模块的引入是自动完成的。 app目录该目录是工作中的重点，其结构如下： 1.bulid同上，主要是包含了一些在编译时自动生成的文件。 2.libs如果项目中用到了第三方的jar包，需要将这些jar包都放在这个目录下，然后才会自动添加到构建路径中。 3.androidTest编写Android Test测试用例，对项目进行一些自动化测试。 4.java放置所有的Java代码。 5.res项目中用到的所有图片、布局、字符串等资源都要存放到该目录下。图片放在drawable目录下，布局放在layout目录下，字符串放在values目录下。 6.AndroidManifest.xml这个是整个Android项目的配置文件，在程序中定义的所有四大组件都需要在这个文件里注册，，另外还可以在这个文件中给应用程序添加权限声明。 7.test用来编写Unit Test测试用例,是对项目进行自动化测试的另一种方式。 8..gitignore这个文件用于将app模块内的指定的目录或文件排除在版本控制之外，作用和上面的类似。 9.app.iml自动生成的文件。 10.build.gradle这是app模块的gradle构建脚本，这个文件中会指定很多项目构建相关的配置。 11.proguard-rules .pro这个文件用于指定项目代码的混淆规则。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"分析项目结构","slug":"Android/分析项目结构","permalink":"http://yoursite.com/categories/Android/分析项目结构/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"分析项目结构","slug":"分析项目结构","permalink":"http://yoursite.com/tags/分析项目结构/"}]},{"title":"Ubuntu配置ssh","slug":"Ubuntu配置ssh","date":"2019-05-26T03:54:10.206Z","updated":"2019-01-29T14:36:20.000Z","comments":true,"path":"2019/05/26/Ubuntu配置ssh/","link":"","permalink":"http://yoursite.com/2019/05/26/Ubuntu配置ssh/","excerpt":"安装 ssh-server1sudo apt install openssh-server -y","text":"安装 ssh-server1sudo apt install openssh-server -y 安装 ssh-client1sudo apt install openssh-client -y 确认安装 ssh 是否成功1ps -e|grep sshd 生成密钥对并配置免密登录12345ssh-keygen -t rsacd .sshcat id_rsa.pub &gt;&gt; authorized_keyschmod 600 authorized_keys #修改公钥只有属主有读写权限chmod 700 ~/.ssh #修改.ssh目录为只有属主有读、写、执行权限 关闭密码登录12cd /etc/sshvim sshd_config 将PasswordAuthentication改为no，ChallengeResponseAuthentication改为no","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://yoursite.com/categories/Ubuntu/"},{"name":"ssh","slug":"Ubuntu/ssh","permalink":"http://yoursite.com/categories/Ubuntu/ssh/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://yoursite.com/tags/Ubuntu/"},{"name":"ssh","slug":"ssh","permalink":"http://yoursite.com/tags/ssh/"}]},{"title":"Ubuntu18.04 安装 Docker","slug":"Ubuntu18.04 安装 Docker","date":"2019-05-26T03:54:10.201Z","updated":"2018-12-17T14:02:04.000Z","comments":true,"path":"2019/05/26/Ubuntu18.04 安装 Docker/","link":"","permalink":"http://yoursite.com/2019/05/26/Ubuntu18.04 安装 Docker/","excerpt":"准备工作系统要求Docker CE 支持一下版本的 Ubuntu 操作系统： Artful 17.10(Docker CE 17.11 Edge) Zesty 17.04 Xenial 16.04(LTS) Trusty 14.04(LTS) 推荐使用 LTS 版本的，在Ubuntu发行版中，LTS是长期支持版本，会更稳定。","text":"准备工作系统要求Docker CE 支持一下版本的 Ubuntu 操作系统： Artful 17.10(Docker CE 17.11 Edge) Zesty 17.04 Xenial 16.04(LTS) Trusty 14.04(LTS) 推荐使用 LTS 版本的，在Ubuntu发行版中，LTS是长期支持版本，会更稳定。 卸载旧版本旧版本的 Docker 称为 docker 或者 docker-engine，使用以下命令卸载旧版本： 123sudo apt-get remove docker \\ docker-engine \\ docker.io 安装与验证从 Ubuntu 14.04 开始，一部分内核模块移到了可选内核模块包 (linux-image-extra-*) ，以减少内核软件包的体积。正常安装的系统应该会包含可选内核模块包，而一些裁剪后的系统可能会将其精简掉。AUFS 内核驱动属于可选内核模块的一部分，作为推荐的 Docker 存储层驱动，一般建议安装可选内核模块包以使用 AUFS。 如果系统没有安装可选内核模块的话，可以执行下面的命令来安装可选内核模块包：(操作均为普通用户下) 123456sudo apt-get updatesudo apt-get install \\ linux-image-extra-$(uname -r) \\ linux-image-extra-virtual Ubuntu 16.04 + 上的 Docker CE 默认使用 overlay2 存储层驱动,无需手动配置。 使用APT安装由于 apt 源使用 HTTPS 以确保软件下载过程中不被篡改。因此，我们首先需要添加使用 HTTPS 传输的软件包以及 CA 证书。 1234567sudo apt-get updatesudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ software-properties-common 鉴于国内网络问题，强烈建议使用国内源，官方源请在注释中查看。为了确认所下载软件包的合法性，需要添加软件源的 GPG 密钥。 123456(任选其一即可)curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -官方源curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - 然后，我们需要向 source.list 中添加 Docker 软件源 1234567891011sudo add-apt-repository \\ &quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu \\ $(lsb_release -cs) \\ stable&quot;# 官方源# $ sudo add-apt-repository \\# &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \\# $(lsb_release -cs) \\# stable&quot; 安装 Docker CE12sudo apt updatesudo apt install docker-ce 建立 docker 用户组建立docker组: 1sudo groupadd docker 将当前用户加入docker组： 1sudo usermod -aG docker $USER 更换国内Docker仓库创建文件： 1sudo vim /etc/docker/daemon.json 加入以下内容： 12345&#123; &quot;registry-mirrors&quot;: [ &quot;https://registry.docker-cn.com&quot; ]&#125; 然后重启系统。 验证输入以下命令： 1docker run hello-world 若输出以下内容则为成功。 1234567891011121314151617181920212223242526Unable to find image &apos;hello-world:latest&apos; locallylatest: Pulling from library/hello-worldca4f61b1923c: Pull completeDigest: sha256:be0cd392e45be79ffeffa6b05338b98ebb16c87b255f48e297ec7f98e123905cStatus: Downloaded newer image for hello-world:latestHello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal.To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bashShare images, automate workflows, and more with a free Docker ID: https://cloud.docker.com/For more examples and ideas, visit: https://docs.docker.com/engine/userguide/ 参考Ubuntu 下安装 DockerDocker —— 从入门到实践","categories":[{"name":"Docker","slug":"Docker","permalink":"http://yoursite.com/categories/Docker/"},{"name":"安装","slug":"Docker/安装","permalink":"http://yoursite.com/categories/Docker/安装/"}],"tags":[{"name":"Docker安装","slug":"Docker安装","permalink":"http://yoursite.com/tags/Docker安装/"}]},{"title":"Spring MVC和MyBatis开发环境准备","slug":"Spring MVC和MyBatis开发环境准备","date":"2019-05-26T03:54:10.189Z","updated":"2019-05-26T10:51:54.221Z","comments":true,"path":"2019/05/26/Spring MVC和MyBatis开发环境准备/","link":"","permalink":"http://yoursite.com/2019/05/26/Spring MVC和MyBatis开发环境准备/","excerpt":"Spring MVC和MyBatis开发环境准备准备 jdk Intellij IDEA Tomcat Maven MySql","text":"Spring MVC和MyBatis开发环境准备准备 jdk Intellij IDEA Tomcat Maven MySql JDK 安装下载JDK建议使用1.8及以上的版本。官方下载路径：jdk下载路地址 安装双击下载软件，一路单击下一步即可。 配置环境变量Windows：右击【我的电脑】→【属性】→【高级系统设置】→【环境变量】→【系统变量】→【新建】，接着如下图所示： 在【系统变量】的path中添加 %JAVA_HOME%\\bin。 验证，如下图所示： Intellij IDEA下载路径：indea U 激活（针对学生的免费使用计划）参考：Intellij IDEA的下载和使用（针对学生的免费使用计划） Tomcat的安装与配置下载下载链接：Tomcat 8.0其他版本可以查看该页面：下载页面 下载完成后对文件进行解压，解压路径自行设置。 Intellij IDEA 配置 Tomcat步骤如下图： Maven 的安装和配置下载地址：Maven 配置 在Maven的安装目录新建文件夹repository,用来作为本地仓库。 如下图： MySql参考：MySQL 安装| 菜鸟教程","categories":[{"name":"SSM","slug":"SSM","permalink":"http://yoursite.com/categories/SSM/"},{"name":"开发环境准备","slug":"SSM/开发环境准备","permalink":"http://yoursite.com/categories/SSM/开发环境准备/"}],"tags":[{"name":"Spring MVC和MyBatis开发环境准备","slug":"Spring-MVC和MyBatis开发环境准备","permalink":"http://yoursite.com/tags/Spring-MVC和MyBatis开发环境准备/"}]},{"title":"RecyclerView","slug":"RecyclerView","date":"2019-05-26T03:54:10.178Z","updated":"2019-04-27T05:53:20.930Z","comments":true,"path":"2019/05/26/RecyclerView/","link":"","permalink":"http://yoursite.com/2019/05/26/RecyclerView/","excerpt":"RecyclerViewRecyclerView可以说是一个增强版的ListView，不仅可以轻松实现和ListView同样的效果，还优化了ListView中存在的各种不足之处。","text":"RecyclerViewRecyclerView可以说是一个增强版的ListView，不仅可以轻松实现和ListView同样的效果，还优化了ListView中存在的各种不足之处。 添加相应的依赖库123456789dependencies &#123; implementation fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;]) implementation &apos;com.android.support:appcompat-v7:28.0.0&apos; implementation &apos;com.android.support.constraint:constraint-layout:1.1.3&apos; testImplementation &apos;junit:junit:4.12&apos; androidTestImplementation &apos;com.android.support.test:runner:1.0.2&apos; androidTestImplementation &apos;com.android.support.test.espresso:espresso-core:3.0.2&apos; implementation &apos;com.android.support:recyclerview-v7:28.0.0&apos; #添加这一行&#125; 添加之后记得点击一下Sync Now来进行同步。 android gradle依赖：implementation 和compile的区别 布局activity_main.xml 123456789&lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;android.support.v7.widget.RecyclerView android:id=&quot;@+id/recycler_view&quot; android:layout_height=&quot;match_parent&quot; android:layout_width=&quot;match_parent&quot; /&gt; &lt;/LinearLayout&gt; 由于RecyclerView并不是内置在系统SDK当中，所以 需要把完整的包路径写出来。 fruit_item.xml123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_margin=&quot;5dp&quot; &gt; &lt;ImageView android:id=&quot;@+id/fruit_image&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center_horizontal&quot; /&gt; &lt;TextView android:id=&quot;@+id/fruit_name&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;left&quot; android:layout_marginTop=&quot;10dp&quot; /&gt;&lt;/LinearLayout&gt; FruitAdapter类为RecyclerView准备一个适配器，新建FruitAdapter类，让这个适配器继承自RecyclerView.Adapter，并将泛型指定为FruitAdapter.ViewHolder。其中，ViewHolder是我们在FruitAdapter中定义的一个内部类。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class FruitAdapter extends RecyclerView.Adapter&lt;FruitAdapter.ViewHolder&gt;&#123; private List&lt;Fruit&gt; mFruitList; static class ViewHolder extends RecyclerView.ViewHolder &#123; View fruitView; ImageView fruitImage; TextView fruitName; public ViewHolder(View view) &#123; super(view); fruitView = view; fruitImage = (ImageView) view.findViewById(R.id.fruit_image); fruitName = (TextView) view.findViewById(R.id.fruit_name); &#125; &#125; public FruitAdapter(List&lt;Fruit&gt; fruitList) &#123; mFruitList = fruitList; &#125; @Override public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.fruit_item, parent, false); final ViewHolder holder = new ViewHolder(view); holder.fruitView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; int position = holder.getAdapterPosition(); Fruit fruit = mFruitList.get(position); Toast.makeText(v.getContext(), &quot;you clicked view &quot; + fruit.getName(), Toast.LENGTH_SHORT).show(); &#125; &#125;); holder.fruitImage.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; int position = holder.getAdapterPosition(); Fruit fruit = mFruitList.get(position); Toast.makeText(v.getContext(), &quot;you clicked image &quot; + fruit.getName(), Toast.LENGTH_SHORT).show(); &#125; &#125;); return holder; &#125; @Override public void onBindViewHolder(ViewHolder holder, int position) &#123; Fruit fruit = mFruitList.get(position); holder.fruitImage.setImageResource(fruit.getImageId()); holder.fruitName.setText(fruit.getName()); &#125; @Override public int getItemCount() &#123; return mFruitList.size(); &#125;&#125; Fruit类1234567891011121314151617181920public class Fruit &#123; private String name; private int imageId; public Fruit(String name, int imageId) &#123; this.name = name; this.imageId = imageId; &#125; public String getName() &#123; return name; &#125; public int getImageId() &#123; return imageId; &#125;&#125; MainACtivity.java修改MainACtivity中的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class MainActivity extends AppCompatActivity &#123; private List&lt;Fruit&gt; fruitList = new ArrayList&lt;Fruit&gt;(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initFruits(); RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recycler_view); StaggeredGridLayoutManager layoutManager = new StaggeredGridLayoutManager(3, StaggeredGridLayoutManager.VERTICAL); recyclerView.setLayoutManager(layoutManager); FruitAdapter adapter = new FruitAdapter(fruitList); recyclerView.setAdapter(adapter); &#125; private void initFruits() &#123; for (int i = 0; i &lt; 2; i++) &#123; Fruit apple = new Fruit(getRandomLengthName(&quot;Apple&quot;), R.drawable.apple_pic); fruitList.add(apple); Fruit banana = new Fruit(getRandomLengthName(&quot;Banana&quot;), R.drawable.banana_pic); fruitList.add(banana); Fruit orange = new Fruit(getRandomLengthName(&quot;Orange&quot;), R.drawable.orange_pic); fruitList.add(orange); Fruit watermelon = new Fruit(getRandomLengthName(&quot;Watermelon&quot;), R.drawable.watermelon_pic); fruitList.add(watermelon); Fruit pear = new Fruit(getRandomLengthName(&quot;Pear&quot;), R.drawable.pear_pic); fruitList.add(pear); Fruit grape = new Fruit(getRandomLengthName(&quot;Grape&quot;), R.drawable.grape_pic); fruitList.add(grape); Fruit pineapple = new Fruit(getRandomLengthName(&quot;Pineapple&quot;), R.drawable.pineapple_pic); fruitList.add(pineapple); Fruit strawberry = new Fruit(getRandomLengthName(&quot;Strawberry&quot;), R.drawable.strawberry_pic); fruitList.add(strawberry); Fruit cherry = new Fruit(getRandomLengthName(&quot;Cherry&quot;), R.drawable.cherry_pic); fruitList.add(cherry); Fruit mango = new Fruit(getRandomLengthName(&quot;Mango&quot;), R.drawable.mango_pic); fruitList.add(mango); &#125; &#125; private String getRandomLengthName(String name) &#123; Random random = new Random(); int length = random.nextInt(20) + 1; StringBuilder builder = new StringBuilder(); for (int i = 0; i &lt; length; i++) &#123; builder.append(name); &#125; return builder.toString(); &#125;&#125; 实现横向滚动修改fruit_item.xml 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;100dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_margin=&quot;5dp&quot; &gt; &lt;ImageView android:id=&quot;@+id/fruit_image&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center_horizontal&quot; /&gt; &lt;TextView android:id=&quot;@+id/fruit_name&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center_horizontal&quot; android:layout_marginTop=&quot;10dp&quot; /&gt;&lt;/LinearLayout&gt; 修改Mainactivity 12345678910111213@Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initFruits(); RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recycler_view); StaggeredGridLayoutManager layoutManager = new StaggeredGridLayoutManager(3, StaggeredGridLayoutManager.VERTICAL); layoutManager.setOrientation(LinearLayoutManager.HORIZONTAL); recyclerView.setLayoutManager(layoutManager); FruitAdapter adapter = new FruitAdapter(fruitList); recyclerView.setAdapter(adapter); &#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"RecyclerView","slug":"Android/RecyclerView","permalink":"http://yoursite.com/categories/Android/RecyclerView/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"RecyclerView","slug":"RecyclerView","permalink":"http://yoursite.com/tags/RecyclerView/"}]},{"title":"qtp破解","slug":"qtp","date":"2019-05-26T03:54:10.169Z","updated":"2019-04-20T14:22:35.124Z","comments":true,"path":"2019/05/26/qtp/","link":"","permalink":"http://yoursite.com/2019/05/26/qtp/","excerpt":"qtp安装与破解准备： QTP 10.0 破解文件","text":"qtp安装与破解准备： QTP 10.0 破解文件 下载 链接: https://pan.baidu.com/s/19TGLWjd_znKFM8RZkj1ITg 提取码: 9wjv 安装 qtp 选择 QTP10.iso,解压后点击文件目录中的 setup.exe,双击运行。按照图片顺序进行操作。 破解1.在c:\\program files\\common files\\mercury interactive目录下新建一个文件夹：License Manager注：64位操作系统在c:\\program files(x86)\\common files\\mercury interactive以下步骤以此类推。 2.将下载的文件中的qtp破解解压，将mgn-mqt8.2.exe复制到qtp的安装路径的bin文件夹中，然后以管理员身份运行。 3.打开c:\\program files\\common files\\mercury interactive\\License Manager中的lservrc文件。 4.将lservrc文件中的内容（将”QuickTestPro”之前的所有字符复制进去，不包括”QuickTestPro”字符）粘贴到如下图中。","categories":[{"name":"软件测试","slug":"软件测试","permalink":"http://yoursite.com/categories/软件测试/"},{"name":"qtp","slug":"软件测试/qtp","permalink":"http://yoursite.com/categories/软件测试/qtp/"}],"tags":[{"name":"软件测试","slug":"软件测试","permalink":"http://yoursite.com/tags/软件测试/"},{"name":"qtp","slug":"qtp","permalink":"http://yoursite.com/tags/qtp/"}]},{"title":"ProgressBar","slug":"ProgressBar","date":"2019-05-26T03:54:10.158Z","updated":"2019-04-19T07:43:59.118Z","comments":true,"path":"2019/05/26/ProgressBar/","link":"","permalink":"http://yoursite.com/2019/05/26/ProgressBar/","excerpt":"ProgressBarProgressBar用于在界面上显示一个进度条，表示程序正在加载一些数据。","text":"ProgressBarProgressBar用于在界面上显示一个进度条，表示程序正在加载一些数据。 布局activity_main.xml12345678910111213141516&lt;LinearLayout android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;Button android:id=&quot;@+id/button&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;button&quot;/&gt; &lt;ProgressBar android:id=&quot;@+id/progress_bar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; /&gt; &lt;/LinearLayout&gt; 实现点击一下按钮让进度条消失，再点击一下按钮让进度条出现的效果MainActivity 123456789101112131415161718192021222324252627public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private Button button; private ProgressBar progressBar; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); button = findViewById(R.id.button); progressBar = findViewById(R.id.progress_bar); button.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.button: if (progressBar.getVisibility() == View.GONE) &#123; progressBar.setVisibility(View.VISIBLE); &#125; else &#123; progressBar.setVisibility(View.GONE); &#125; default: break; &#125; &#125;&#125; 给ProgressBar指定不同的样式activity_main.xml 1234567891011121314151617&lt;LinearLayout android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;Button android:id=&quot;@+id/button&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;button&quot;/&gt; &lt;ProgressBar android:id=&quot;@+id/progress_bar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; style=&quot;?android:attr/progressBarStyleHorizontal&quot; android:max=&quot;100&quot;/&gt; &lt;/LinearLayout&gt; MainActivity 1234567891011121314151617181920212223242526public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private Button button; private ProgressBar progressBar; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); button = findViewById(R.id.button); progressBar = findViewById(R.id.progress_bar); button.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.button: int progress=progressBar.getProgress(); progress=progress+10; progressBar.setProgress(progress); break; default: break; &#125; &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"ProgressBar","slug":"Android/ProgressBar","permalink":"http://yoursite.com/categories/Android/ProgressBar/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"ProgressBar","slug":"ProgressBar","permalink":"http://yoursite.com/tags/ProgressBar/"}]},{"title":"ProgressDialog","slug":"ProgresDialog","date":"2019-05-26T03:54:10.146Z","updated":"2019-04-19T09:00:33.935Z","comments":true,"path":"2019/05/26/ProgresDialog/","link":"","permalink":"http://yoursite.com/2019/05/26/ProgresDialog/","excerpt":"ProgressDialogProgressDialog和AlertDialog有点类似，不同的是ProgressDialog会在对话框中显示一个进度条，一般用于表示当前操作比较耗时，让用户耐心等待。","text":"ProgressDialogProgressDialog和AlertDialog有点类似，不同的是ProgressDialog会在对话框中显示一个进度条，一般用于表示当前操作比较耗时，让用户耐心等待。 添加一个Button按钮activity_main.xml 123456789101112&lt;LinearLayout android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;Button android:id=&quot;@+id/button&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;button&quot;/&gt; &lt;/LinearLayout&gt; 为Button添加事件MainActivity 12345678910111213141516171819202122232425public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button=findViewById(R.id.button); button.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId())&#123; case R.id.button: ProgressDialog progressDialog=new ProgressDialog(MainActivity.this); progressDialog.setTitle(&quot;This is a ProgressDialog&quot;); //设置标题 progressDialog.setMessage(&quot;Loading...&quot;); //设置内容 progressDialog.setCancelable(true); //设置可否取消 progressDialog.show(); //显示 break; default: break; &#125; &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"ProgressDialog","slug":"Android/ProgressDialog","permalink":"http://yoursite.com/categories/Android/ProgressDialog/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"ProgressDialog","slug":"ProgressDialog","permalink":"http://yoursite.com/tags/ProgressDialog/"}]},{"title":"LoadRunner","slug":"LoadRunner","date":"2019-05-26T03:54:10.137Z","updated":"2019-05-11T06:14:47.837Z","comments":true,"path":"2019/05/26/LoadRunner/","link":"","permalink":"http://yoursite.com/2019/05/26/LoadRunner/","excerpt":"LoadRunner 11.0准备： LoadRunner 11.0 安装包 LoadRunner 11.0 破解相关文件","text":"LoadRunner 11.0准备： LoadRunner 11.0 安装包 LoadRunner 11.0 破解相关文件 下载： LoadRunner 11.0 安装包（迅雷下载）：http://www.genilogix.com/downloads/loadrunner/loadrunner-11.iso LoadRunner 11.0 破解相关文件 安装步骤 打开LoadRunner 11.0 安装包文件夹，点击setup.exe。 点击LoadRunner完整安装程序，接着按提示进行下去，当它提示缺省文件的时候可以直接打开“附加组件”进入“Monitor Probe for Microsoft COM+ Server Components”这个文件夹，运行“Com_Plus_Probe.exe”文件即可。 安装成功即进入主界面，进入的时候会有一个提示框出现，意思就是你拥有10天的试用权限。 破解 打开LoadRunner 11.0 破解相关文件，将mlr5lprg.dll和lm70.dll这两个文件复制替换到LoadRunner安装目录的/bin文件下。 以管理员身份运行deletelicense.exe 管理员身份运行LoadRunner。 点击“configuration-&gt;loadRunner License”进入界面，现在你就可以new你自己的license了。下面是不同数量并发的代码：10000个并发：AEABEXFR-YTIEKEKJJMFKEKEKWBRAUNQJU-KBYGB提供一个超级license 最高支持6.5w个并发：AEACFSJI-YJKJKJJKEJIJD-BCLBR。 参考loadRunner 安装及破解 LoadRunner 11.0安装+汉化+破解 loadRunner破解不成功的几个原因","categories":[{"name":"软件测试","slug":"软件测试","permalink":"http://yoursite.com/categories/软件测试/"},{"name":"LoadRunner","slug":"软件测试/LoadRunner","permalink":"http://yoursite.com/categories/软件测试/LoadRunner/"}],"tags":[{"name":"软件测试","slug":"软件测试","permalink":"http://yoursite.com/tags/软件测试/"},{"name":"LoadRunner","slug":"LoadRunner","permalink":"http://yoursite.com/tags/LoadRunner/"}]},{"title":"ListView","slug":"ListView","date":"2019-05-26T03:54:10.126Z","updated":"2019-04-21T12:35:37.867Z","comments":true,"path":"2019/05/26/ListView/","link":"","permalink":"http://yoursite.com/2019/05/26/ListView/","excerpt":"ListView由于手机屏幕空间比较有限，能够一次性在屏幕上显示的内容并不多，当我们的程序中有大量的数据需要显示的时候，就可以借助ListView来实现。ListView允许用户通过手指上下滑动的方式将屏幕外的数据滚动到屏幕内，同时屏幕上原有的数据则会滚动出屏幕。","text":"ListView由于手机屏幕空间比较有限，能够一次性在屏幕上显示的内容并不多，当我们的程序中有大量的数据需要显示的时候，就可以借助ListView来实现。ListView允许用户通过手指上下滑动的方式将屏幕外的数据滚动到屏幕内，同时屏幕上原有的数据则会滚动出屏幕。 创建布局修改activity_main.xml 123456789101112&lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;ListView android:id=&quot;@+id/list_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;/ListView&gt; &lt;/LinearLayout&gt; 修改MainActivity代码1234567891011121314151617181920public class MainActivity extends AppCompatActivity &#123; private String[] data=&#123; &quot;Apple&quot;,&quot;Banana&quot;,&quot;Orange&quot;,&quot;Watermelon&quot;,&quot;Pear&quot;, &quot;Grape&quot;,&quot;Pineapple&quot;,&quot;Strawberry&quot;,&quot;Cherry&quot;,&quot;Mango&quot;, &quot;Apple&quot;,&quot;Banana&quot;,&quot;Orange&quot;,&quot;Watermelon&quot;,&quot;Pear&quot;, &quot;Grape&quot;,&quot;Pineapple&quot;,&quot;Strawberry&quot;,&quot;Cherry&quot;,&quot;Mango&quot; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ArrayAdapter&lt;String&gt; adapter=new ArrayAdapter&lt;String&gt;( MainActivity.this,android.R.layout.simple_list_item_1,data ); ListView listView=findViewById(R.id.list_view); listView.setAdapter(adapter); &#125;&#125; ListView用于展示大量数据，这些数据可以是从网上下载的，也可以是从数据库中读取的。这里使用一个data数组来测试。运行结果如图：","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"ListView","slug":"Android/ListView","permalink":"http://yoursite.com/categories/Android/ListView/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"ListView","slug":"ListView","permalink":"http://yoursite.com/tags/ListView/"}]},{"title":"Hexo主题casper使用教程","slug":"Hexo主题casper使用教程","date":"2019-05-26T03:54:07.007Z","updated":"2019-04-17T14:08:16.453Z","comments":true,"path":"2019/05/26/Hexo主题casper使用教程/","link":"","permalink":"http://yoursite.com/2019/05/26/Hexo主题casper使用教程/","excerpt":"Hexo主题casper使用教程demo","text":"Hexo主题casper使用教程demo 安装下载1git clone https://github.com/xzhih/hexo-theme-casper.git themes/hexo-casper 更改主题为casper把Hexo根目录的配置文件_config.yml中的theme改为hexo-casper。 升级建议先备份以下再执行下面的操作。12cd themes/casper git pull 添加统一的文章模板参数把下面的内容添加到Hexo根目录下的scaffolds/post.md。 1234cover_img: # 在文章摘要上显示feature_img: # 在文章详细页面上置顶description: # 文章描述keywords: # 关键字 自定义配置编辑themes/hexo-casper/_config.yml进行配置。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273# Configrss: # linkfavicon: https://i.loli.net/2017/11/26/5a19c0b50432e.pngblog_logo: header_image: https://i.loli.net/2017/11/26/5a19c56faa29f.jpgbio: This is a demopost_toc: true# 菜单menu: About: /about Archives: /archives # 其他的可以按照上面的模板添加# 作者author_image: # 链接author_bio: # 描述author_location: # 地址# 社交链接social: facebook: https://www.facebook.com twitter: https://www.twitter.com twitter: https://twitter.com facebook: https://facebook telegram: bilibili: youtube: # 插件（显示在网站底部）widgets: recent_posts: true category: true tagcloud: true # 这是个简洁的主题，我认为3个就够了# 文章图片相册（点击图片可以放大）# https://github.com/sachinchoolur/lightgallery.jslightgallery: true# 懒加载# 首页已经默认开启，其他页面在此开启# https://github.com/dinbror/blazylazyload: true# 搜索功能local_search: true# Valine 评论系统# https://valine.js.orgcomment: falsevaline: notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code appId: # your leancloud application appid appKey: # your leancloud application appkey placeholder: Just go go # comment box placeholder avatar: mm # gravatar style pageSize: 10 # pagination size# PWA # 你需要在 hexo 目录的 source 文件夹里创建一个 manifest.json 文件manifest: falseservice_workers: falsenavColor: &apos;3c484e&apos;# Baidu 链接提交baidu: false# Google AnalyticsgoogleAnalytics: falseGA_TRACKING_ID: UA-XXXXXXXXXX-1 本地搜索功能安装1npm install hexo-generator-search --save 配置在Hexo根目录下中的_config.yml进行配置。1234search： path：search.xml field：post content：true path-文件路径。默认为search.xml。如果文件扩展名为.json，则输出格式为JSON。否则将导出XML格式文件。filed-要搜索的文件范围。 post（默认）-所有帖子 page -所有页面 all -所有帖子和页面 content-是否包含每篇文章的全部内容。默认为true。如果false，生成的结果仅覆盖没有主体的标题和其他元信息。 排除索引要将某个帖子或页面排除在索引之外，您只需indexing: false在其前端的顶部插入设置，例如： title: &quot;Code Highlight&quot; date: &quot;2014-03-15 20:17:16&quot; tags: highlight categories: Demo description: &quot;A collection of Hello World applications from helloworld.org.&quot; toc: true indexing: false ---","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/categories/Hexo/"},{"name":"Hexo主题casper使用教程","slug":"Hexo/Hexo主题casper使用教程","permalink":"http://yoursite.com/categories/Hexo/Hexo主题casper使用教程/"}],"tags":[{"name":"Hexo主题casper使用教程","slug":"Hexo主题casper使用教程","permalink":"http://yoursite.com/tags/Hexo主题casper使用教程/"}]},{"title":"hexo-theme-indigo","slug":"hexo-theme-indigo","date":"2019-05-26T03:54:06.999Z","updated":"2019-04-16T14:29:05.240Z","comments":true,"path":"2019/05/26/hexo-theme-indigo/","link":"","permalink":"http://yoursite.com/2019/05/26/hexo-theme-indigo/","excerpt":"hexo-theme-indigo 主题demo","text":"hexo-theme-indigo 主题demo 主题安装安装需确认Hexo版本在 3.0 以上，以及Node版本在6.x以上，在Hexo根目录，执行以下命令：1git clone git@github.com:yscoder/hexo-theme-indigo.git themes/indigo 切换主题在Hexo根目录下的_config.yml文件中修改，如下：1theme: indigo 注：记得保存。 依赖安装Less主题默认使用 less 作为 css 预处理工具。1npm install hexo-renderer-less --save Feed用于生成 rss。1npm install hexo-generator-feed --save Json-content用于生成静态站点数据，用作站内搜索的数据源。1npm install hexo-generator-json-content --save QRCode(可选)用于生成微信分享二维码。可选，不安装时会请求 jiathis Api 生成二维码。1npm install hexo-helper-qrcode --save 开启分类页仅 card theme 支持。1hexo new page categories 修改 hexo/source/categories/index.md 的元数据123layout: categoriescomments: false--- 开启标签页1hexo new page tags 修改 hexo/source/tags/index.md 的元数据 123layout: tagscomments: false--- 常见问题文章截断在Markdown中加 添加多个标签1tags: [a, b, c] 或 1234tags: - a - b - c 分类1categories: [a, b, c] 更改站点配色编辑 themes\\indigo\\source\\css_partial\\variable.less，更改对应的颜色变量。配色参考：Material Design Color Palette Generator注意：使用自定义配色时需把主题配置中的 cdn 关闭，cdn: false。 其他参考：https://github.com/yscoder/hexo-theme-indigo/wiki/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98 站点配置编辑站点配置文件 \\themes\\landscape的_config.yml文件。 启动主题1theme: indigo 基本配置左侧菜单1234567891011121314151617menu: home: text: 主页 url: / archives: url: /archives tags: url: /tags github: url: https://github.com/yscoder target: _blank weibo: url: http://www.weibo.com/ysweb target: _blank link: text: 测试 url: / 添加新菜单项时，在 menu 下增加子属性即可。属性说明如下：12345menu: link: # fontawesome图标，省略前缀，本主题前缀为 icon-，必须 text: About # 菜单显示的文字，如果省略即默认与图标一致，首字母会转大写 url: /about # 链接，绝对或相对路径，必须 target: _blank # 是否跳出，省略则在当前页面打开 favicon站点 logo，显示在浏览器当前标签页左上角。1favicon: /favicon.ico 头像位于左侧菜单上方1avatar: /img/logo.jpg email头像下方1email: 634206017@qq.com color设置 Android L Chrome 浏览器状态栏颜色，不需要可去除此项或设为 false。1color: &apos;#3F51B5&apos; 其他参考：https://github.com/yscoder/hexo-theme-indigo/wiki/%E9%85%8D%E7%BD%AE","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/categories/Hexo/"},{"name":"hexo-theme-indigo","slug":"Hexo/hexo-theme-indigo","permalink":"http://yoursite.com/categories/Hexo/hexo-theme-indigo/"}],"tags":[{"name":"hexo-theme-indigo","slug":"hexo-theme-indigo","permalink":"http://yoursite.com/tags/hexo-theme-indigo/"}]},{"title":"Hexo yilia 添加目录页面","slug":"Hexo yilia 添加目录页面","date":"2019-05-26T03:54:06.987Z","updated":"2018-12-17T14:02:00.000Z","comments":true,"path":"2019/05/26/Hexo yilia 添加目录页面/","link":"","permalink":"http://yoursite.com/2019/05/26/Hexo yilia 添加目录页面/","excerpt":"步骤 1.添加 categories 页面 2.添加 categories 链接 3.修改 yilia 主题 4.多层分类 5.效果 6.参考文档","text":"步骤 1.添加 categories 页面 2.添加 categories 链接 3.修改 yilia 主题 4.多层分类 5.效果 6.参考文档 1 添加 categories 页面1.1 新建 categories 页面 输入命令： 1hexo new page categories 该命令在 source 目录下生成一个 categories 目录，categories 目录下有一个 index.md 文件。 1.2 修改 index.md 文件1234567---title: 文章分类date: 2018-10-19 11:22:21type: &quot;categories&quot;layout: &quot;categories&quot;comments: false #关闭评论--- 2 添加 categories 链接 若主题为 yilia ，则打开 yilia/_config.yml ，修改为： 1234menu: 主页: / 相册: / 分类: /categories 3 修改 yilia 主题3.1 新建yilia/layout/categories.ejs12345678910111213141516171819202122&lt;article class=&quot;article article-type-post show&quot;&gt; &lt;header class=&quot;article-header&quot;&gt; &lt;h1 class=&quot;article-title&quot; itemprop=&quot;name&quot;&gt; &lt;%= page.title %&gt; &lt;/h1&gt; &lt;/header&gt; &lt;% if (site.categories.length)&#123; %&gt; &lt;div class=&quot;category-all-page article-type-post show&quot;&gt; &lt;h3&gt;共计&amp;nbsp;&lt;%= site.categories.length %&gt;&amp;nbsp;个分类&lt;/h3&gt; &lt;ul class=&quot;category-list&quot;&gt; &lt;% site.categories.sort(&apos;name&apos;).each(function(item)&#123; %&gt; &lt;% if(item.posts.length)&#123; %&gt; &lt;li class=&quot;category-list-item&quot;&gt; &lt;a href=&quot;&lt;%- config.root %&gt;&lt;%- item.path %&gt;&quot; title=&quot;&lt;%= item.name %&gt;&quot;&gt;&lt;%= item.name %&gt;&lt;sup&gt;[&lt;%= item.posts.length %&gt;]&lt;/sup&gt;&lt;/a&gt; &lt;/li&gt; &lt;% &#125; %&gt; &lt;% &#125;); %&gt; &lt;/ul&gt; &lt;/div&gt; &lt;% &#125; %&gt;&lt;/article&gt; 3.2 修改 yilia\\source\\main.0cf68a.css，将下面的内容添加进去1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950category-all-page &#123; margin: 30px 40px 30px 40px; position: relative; min-height: 70vh; &#125; .category-all-page h2 &#123; margin: 20px 0; &#125; .category-all-page .category-all-title &#123; text-align: center; &#125; .category-all-page .category-all &#123; margin-top: 20px; &#125; .category-all-page .category-list &#123; margin: 0; padding: 0; list-style: none; &#125; .category-all-page .category-list-item-list-item &#123; margin: 10px 15px; &#125; .category-all-page .category-list-item-list-count &#123; color: $grey; &#125; .category-all-page .category-list-item-list-count:before &#123; display: inline; content: &quot; (&quot;; &#125; .category-all-page .category-list-item-list-count:after &#123; display: inline; content: &quot;) &quot;; &#125; .category-all-page .category-list-item &#123; margin: 10px 10px; &#125; .category-all-page .category-list-count &#123; color: $grey; &#125; .category-all-page .category-list-count:before &#123; display: inline; content: &quot; (&quot;; &#125; .category-all-page .category-list-count:after &#123; display: inline; content: &quot;) &quot;; &#125; .category-all-page .category-list-child &#123; padding-left: 10px; &#125; 4 多层分类4.1 修改yilia/layout/categories.ejs为：1234567891011121314151617181920&lt;article class=&quot;article article-type-post show&quot;&gt; &lt;header class=&quot;article-header&quot; style=&quot;border-bottom: 1px solid #ccc&quot;&gt; &lt;h1 class=&quot;article-title&quot; itemprop=&quot;name&quot;&gt; &lt;%= page.title %&gt; &lt;/h1&gt; &lt;/header&gt; &lt;% if (site.categories.length)&#123; %&gt; &lt;div class=&quot;category-all-page&quot;&gt; &lt;h2&gt;共计&amp;nbsp;&lt;%= site.categories.length %&gt;&amp;nbsp;个分类&lt;/h2&gt; &lt;%- list_categories(site.categories, &#123; show_count: true, class: &apos;category-list-item&apos;, style: &apos;list&apos;, depth: 2, separator: &apos;&apos; &#125;) %&gt; &lt;/div&gt; &lt;% &#125; %&gt;&lt;/article&gt; 4.2 修改自己的文章123456---title: Hexo yilia 添加目录页面tags: Hexo yilia 添加目录toc: truecategories: [Hexo,创建目录]--- 5 效果 如下图： 6 参考文档 Hexo添加categories页面","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/categories/Hexo/"},{"name":"创建目录","slug":"Hexo/创建目录","permalink":"http://yoursite.com/categories/Hexo/创建目录/"}],"tags":[{"name":"Hexo yilia 添加目录","slug":"Hexo-yilia-添加目录","permalink":"http://yoursite.com/tags/Hexo-yilia-添加目录/"}]},{"title":"Hexo yilia 添加Valine","slug":"Hexo yilia 添加Valine","date":"2019-05-26T03:54:06.971Z","updated":"2018-10-21T04:49:50.000Z","comments":true,"path":"2019/05/26/Hexo yilia 添加Valine/","link":"","permalink":"http://yoursite.com/2019/05/26/Hexo yilia 添加Valine/","excerpt":"步骤 1.Valine 介绍 2.注册LeanCloud 3.配置 4.参考文档","text":"步骤 1.Valine 介绍 2.注册LeanCloud 3.配置 4.参考文档 Valine 介绍 Valine- 一款快速、简洁且高效的无后端评论系统。 Valine 诞生于2017年8月7日，是一款基于Leancloud的快速、简洁且高效的无后端评论系统。理论上支持但不限于静态博客，目前已有Hexo、Jekyll、Typecho、Hugo 等博客程序在使用Valine。 特性 快速安全Emoji 😉无后端实现MarkDown 全语法支持轻量易用(~15kb gzipped)文章阅读量统计 v1.2.0+ 注册 LeanCloud 注册 LeanCloud 注册完成后创建一个应用。然后打开设置-应用Key。如下图： 复制图中的 App ID App key Master Key 作为备用 配置 _config.yml 12345678#6、Valine https://valine.js.orgvaline: appid: #Leancloud应用的appId appkey: #Leancloud应用的appKey verify: false #验证码 notify: false #评论回复提醒 avatar: mm #评论列表头像样式：&apos;&apos;/mm/identicon/monsterid/wavatar/retro/hide placeholder: Just go go #评论框占位符 layout/_partial/article.ejs 12345678910 &lt;% if (theme.valine &amp;&amp; theme.valine.appid &amp;&amp; theme.valine.appkey)&#123; %&gt; &lt;section id=&quot;comments&quot; style=&quot;margin:10px;padding:10px;background:#fff;&quot;&gt; &lt;%- partial(&apos;post/valine&apos;, &#123; key: post.slug, title: post.title, url: config.url+url_for(post.path) &#125;) %&gt; &lt;/section&gt; &lt;% &#125; %&gt;&lt;% &#125; %&gt; layout/_partial/post/valine.ejs 123456789101112131415161718&lt;div id=&quot;vcomment&quot; class=&quot;comment&quot;&gt;&lt;/div&gt; &lt;script src=&quot;//cdn1.lncld.net/static/js/3.0.4/av-min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;//unpkg.com/valine/dist/Valine.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var notify = &apos;&lt;%= theme.valine.notify %&gt;&apos; == true ? true : false; var verify = &apos;&lt;%= theme.valine.verify %&gt;&apos; == true ? true : false; window.onload = function() &#123; new Valine(&#123; el: &apos;.comment&apos;, notify: notify, verify: verify, app_id: &quot;&lt;%= theme.valine.appid %&gt;&quot;, app_key: &quot;&lt;%= theme.valine.appkey %&gt;&quot;, placeholder: &quot;&lt;%= theme.valine.placeholder %&gt;&quot;, avatar:&quot;&lt;%= theme.valine.avatar %&gt;&quot; &#125;); &#125;&lt;/script&gt; 参考文档 1 为你的Hexo加上评论系统-Valine2 新增对Valine评论系统的支持","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/categories/Hexo/"},{"name":"Valine评论","slug":"Hexo/Valine评论","permalink":"http://yoursite.com/categories/Hexo/Valine评论/"}],"tags":[{"name":"Hexo yilia Valine","slug":"Hexo-yilia-Valine","permalink":"http://yoursite.com/tags/Hexo-yilia-Valine/"}]},{"title":"git使用","slug":"git使用","date":"2019-05-26T03:54:06.950Z","updated":"2019-06-03T05:43:52.083Z","comments":true,"path":"2019/05/26/git使用/","link":"","permalink":"http://yoursite.com/2019/05/26/git使用/","excerpt":"","text":"提交文件到GitHub具体步骤如下： 登录GitHub，复制git仓库的地址 [github_repository_url]。 执行 git clone [github_repository_url],将GitHub 的仓库克隆到本地。 进入到克隆的仓库目录，若目录是很久之前克隆出来，需要使用 git pull 以更新到GitHub中的最新文件。 执行 git add . 将所有改动添加到本地仓库中。 执行 git commit -m “这次提交的内容的描述，自行填写” 将改动提交到本地仓库。 执行 git push origin master 将本地的改动提交到GitHub，master 为主分支。 重写历史123git add Titlegit commit -m &quot;ceshi&quot;git commit --amend ##重写上次提交的信息 分支首先，先创建dev,然后切换到dev分支： 1git checkout -b dev git checkout 命令加上-b参数表示创建并切换，相当于一下两条命令： 12git branch devgit checkout dev 然后用git branch命令查看当前分支： 123git branch* dev master git branch命令会列出所有分支，当前分支前面会标一个*号。 之后提交同上步。 合并分支1git merge dev git merge命令用于合并指定分支到当前分支 删除分支1git branch -d dev","categories":[{"name":"版本控制","slug":"版本控制","permalink":"http://yoursite.com/categories/版本控制/"},{"name":"git","slug":"版本控制/git","permalink":"http://yoursite.com/categories/版本控制/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"版本控制","slug":"版本控制","permalink":"http://yoursite.com/tags/版本控制/"}]},{"title":"GitHub+Hexo搭建个人博客","slug":"GitHub+Hexo搭建个人博客","date":"2019-05-26T03:54:06.938Z","updated":"2018-12-12T13:43:01.000Z","comments":true,"path":"2019/05/26/GitHub+Hexo搭建个人博客/","link":"","permalink":"http://yoursite.com/2019/05/26/GitHub+Hexo搭建个人博客/","excerpt":"搭建步骤 1.GitHub 创建个人仓库 2.安装Git 3.安装Node.js 4.安装Hexo 5.美化 6.部署","text":"搭建步骤 1.GitHub 创建个人仓库 2.安装Git 3.安装Node.js 4.安装Hexo 5.美化 6.部署 1 GitHub 创建个人仓库1.1 创建仓库（用户名.github.io) 1 登录GitHub,如果没有的话请先注册。 2 登录之后点击GitHub 中的 New repository创建新的仓库. 3 仓库名应为：用户名.github.io 比如： 2 安装Git2.1 安装Git 1 安装Git。 2 下载安装成功后进行将自己的Github账号与Git进行绑定. 2.2 配置 1 打开Git,并配置。输入以下命令： 12git config --global user.name &quot;自己注册GitHub的用户名&quot; git config --global user.email &quot;注册GitHub时所用的邮箱&quot; 2.3 ssh 1 设置user.name和user.email配置信息之后进行生成ssh密匙文件 1ssh-keygen -t rsa -C &quot;####@####.com&quot; 2 然后找到该命令生成的id_rsa.pub密匙。路径为 C:\\Users\\Admin\\.ssh 3 打开该文件，推荐使用 Visual Studio Code 打开 2.4 GitHub 添加密匙 1 复制文件中的所有内容，然后进入 GitHub_Settings_Deploy keys 界面，点击右边的Add deploy key 如图所示： 2 新建 new SSH Key 注： title可自定义内容，Key为之前复制的密匙 2.5 检测 1 以上步骤完成后， 检测GitHub公匙是否成功，输入下面的命令： 1ssh git@github.com ssh连接成功 3 安装Node.js3.1 安装Node.js 1 下载并安装Node.js,根据自己的喜好下载不同的版本 3.2 检测是否安装成功 1 检测Node.js是否安装成功 1node -v 2 检测nopm是否安装成功 1npm -v 4 安装Hexo4.1 创建 1 创建一个文件夹，创建完成之后选择该文件夹并按住shift右键,如下图所示： 4.2 添加Hexo 1 依次输入,参考Hexo官方文档 1234npm install hexo-cli -ghexo initnpm installhexo server 4.3 预览 1 在浏览器输入localhost:4000 2 若出现错误，参考以下： 使用localhost:4000访问本地blog一直无响应使用localhost:4000访问本地blog一直无响应使用localhost:4000访问本地blog一直无响应 5 美化5.1 挑选主题 1 Hexo官网提供的主题 2 我使用的是yilia，我的博客 5.2 下载主题 1 在根目录打开Git，输入 1git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 5.3 更新主题12cd thems/yiliagit pull 5.4 配置主题 1 根目录打开_config.yml配置文件 2 将 themes:##### 改为 theme: yilia 5.5 个性化主题 1 打开 themes 下的 yilia 文件夹中的 _config.yml 2 配置主题（添加头像，图标及其他） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127# Headermenu: 主页: / 相册: /photos# SubNavsubnav: #github: &quot;#&quot; #weibo: &quot;#&quot; #rss: &quot;#&quot; #zhihu: &quot;#&quot; #qq: &quot;#&quot; #weixin: &quot;#&quot; #jianshu: &quot;#&quot; #douban: &quot;#&quot; #segmentfault: &quot;#&quot; #bilibili: &quot;#&quot; #acfun: &quot;#&quot; #mail: &quot;#&quot; #facebook: &quot;#&quot; #google: &quot;#&quot; #twitter: &quot;#&quot; #linkedin: &quot;#&quot;#rss: /atom.xmlurl: ## 是否需要修改 root 路径# 如果您的网站存放在子目录中，例如 http://yoursite.com/blog，# 请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。root: /# Content# 文章太长，截断按钮文字excerpt_link: more# 文章卡片右下角常驻链接，不需要请设置为falseshow_all_link: &apos;展开全文&apos;# 数学公式mathjax: false# 是否在新窗口打开链接open_in_new: false# 打赏# 打赏type设定：0-关闭打赏； 1-文章对应的md文件里有reward:true属性，才有打赏； 2-所有文章均有打赏reward_type: 0# 打赏wordingreward_wording: &apos;谢谢你请我吃糖果&apos;# 支付宝二维码图片地址，跟你设置头像的方式一样。比如：/assets/img/alipay.jpgalipay: # 微信二维码图片地址weixin: # 目录# 目录设定：0-不显示目录； 1-文章对应的md文件里有toc:true属性，才有目录； 2-所有文章均显示目录toc: 1# 根据自己的习惯来设置，如果你的目录标题习惯有标号，置为true即可隐藏hexo重复的序号；否则置为falsetoc_hide_index: true# 目录为空时的提示toc_empty_wording: &apos;目录，不存在的…&apos;# 是否有快速回到顶部的按钮top: true# Miscellaneousbaidu_analytics: &apos;&apos;google_analytics: &apos;&apos;#路径为E:\\Blog\\sourcefavicon: /assets/img/head.png#你的头像url 路径为E:\\Blog\\sourceavatar: /assets/img/face.jpg#是否开启分享share_jia: true#评论：1、多说；2、网易云跟帖；3、畅言；4、Disqus；5、Gitment#不需要使用某项，直接设置值为false，或注释掉#具体请参考wiki：https://github.com/litten/hexo-theme-yilia/wiki/#1、多说duoshuo: false#2、网易云跟帖wangyiyun: false#3、畅言changyan_appid: falsechangyan_conf: false#4、Disqus 在hexo根目录的config里也有disqus_shortname字段，优先使用yilia的disqus: false#5、Gitmentgitment_owner: false #你的 GitHub IDgitment_repo: &apos;&apos; #存储评论的 repogitment_oauth: client_id: &apos;&apos; #client ID client_secret: &apos;&apos; #client secret# 样式定制 - 一般不需要修改，除非有很强的定制欲望…style: # 头像上面的背景颜色 header: &apos;#4d4d4d&apos; # 右滑板块背景 slider: &apos;linear-gradient(200deg,#a0cfe4,#e8c37e)&apos;# slider的设置slider: # 是否默认展开tags板块 showTags: false# 智能菜单# 如不需要，将该对应项置为false# 比如#smart_menu:# friends: falsesmart_menu: innerArchive: &apos;所有文章&apos; friends: &apos;友链&apos; aboutme: &apos;关于我&apos;friends: 友情链接: # aboutme: # 注：可以根据这个自己修改，记得保存 6 部署6.1 安装Git插件 1 为Hexo安装Git插件 1npm install hexo-deployer-git --save 2 修改根目录下的 _config.yml 配置文件。 1234deploy: type: git repository: https://github.com/yanxin152133/yanxin152133.github.io.git branch: master 6.2 部署 1 打开Git，输入： 1hexo d 2 成功的标志","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/categories/Hexo/"},{"name":"搭建","slug":"Hexo/搭建","permalink":"http://yoursite.com/categories/Hexo/搭建/"}],"tags":[{"name":"GitHub Hexo 个人博客","slug":"GitHub-Hexo-个人博客","permalink":"http://yoursite.com/tags/GitHub-Hexo-个人博客/"}]},{"title":"Rocket.chat","slug":"Docker搭建Rocket.chat","date":"2019-05-26T03:54:06.931Z","updated":"2019-03-23T05:01:07.832Z","comments":true,"path":"2019/05/26/Docker搭建Rocket.chat/","link":"","permalink":"http://yoursite.com/2019/05/26/Docker搭建Rocket.chat/","excerpt":"Docker 搭建 Rocket.chat","text":"Docker 搭建 Rocket.chat 安装 Docker 参考 Ubuntu 安装 Docker Rocket.chat 搭建获取镜像请输入以下命令：1docker pull rocket.chat 启动 首先启动一个mongo实例 1docker run --name db -d mongo:3.0 --smallfiles 启动Rocket.chat链接到这个mongo实例 1docker run --name rocketchat --link db -d rocket.chat 如果想直接在主机上的标准端口访问实例1docker run --name rocketchat -p 80:3000 --env ROOT_URL=http://localhost --link db -d rocket.chat","categories":[{"name":"Docker","slug":"Docker","permalink":"http://yoursite.com/categories/Docker/"},{"name":"Rocket.chat","slug":"Docker/Rocket-chat","permalink":"http://yoursite.com/categories/Docker/Rocket-chat/"}],"tags":[{"name":"Rocket.chat","slug":"Rocket-chat","permalink":"http://yoursite.com/tags/Rocket-chat/"}]},{"title":"deepin","slug":"deepin","date":"2019-05-26T03:54:06.918Z","updated":"2019-03-21T04:16:23.111Z","comments":true,"path":"2019/05/26/deepin/","link":"","permalink":"http://yoursite.com/2019/05/26/deepin/","excerpt":"Deepin无线网络极慢的解决方案初次安装，出现无线网络网速极慢的状况。","text":"Deepin无线网络极慢的解决方案初次安装，出现无线网络网速极慢的状况。 更改文件参数1vim /etc/modprobe.d/iwlwifi.conf 将该文件中的11n_disable=1改为11n_disable=8 驱动安装查看驱动型号输入以下命令1lspci|grep Wireless 例如下图中的型号： 型号为：Intel Corporation Intel Dual Band Wireless-AC 3165 Plus Bluetooth (rev 99) 下载相对应的驱动下载地址：英特尔® 无线适配器的 Linux* 支持 安装输入以下命令：123tar -zxvf iwlwifi-7265-ucode-25.30.14.0.tgzsudo cp iwlwifi-*.ucode /lib/firmwaresudo reboot 一般情况下是可以解决该问题的。 electorn-ssr下载地址下载地址：electron-ssr也可以根据喜好自己下载：列表 配置一般情况下安装后是无法使用electron-ssr的，需要进行配置。如图（二选一即可）： node.js安装主要讲两个方式： 第一种方式下载下载地址：node.js根据个人习惯进行下载。 安装输入以下命令：123tar xvJf node-v10.15.3-linux-x64.tar.xz //解压cd node-v10.15.3-linux-x64/bin/./node -v 设置全局123ln -s /home/kun/mysofltware/node-v0.10.28-linux-x64/bin/node /usr/local/bin/nodeln -s /home/kun/mysofltware/node-v0.10.28-linux-x64/bin/npm /usr/local/bin/npm# /home/kun/mysofltware/node-v0.10.28-linux-x64/bin/node为自己存放文件的地址 /usr/local/bin/npm和/usr/local/bin/node不需要更改 第二种方式通过命令进行安装，输入以下命令：12sudo apt-get install nodejssudo apt-get install npm 配置Clion更新1sudo apt update gcc、g++12sudo apt-get install build-essentialsudo apt-get install g++ 设置环境变量1234sudo vim /etc/profile## 将以下内容填写进去 export CC=/usr/bin/gccexport CXX=/usr/bin/g++ 验证是否安装成功12gcc --versiong++ --version cmake下载下载列表：cmake下载地址:[cmake-3.11.3.tar.gz]https://cmake.org/files/v3.11/cmake-3.11.3.tar.gz 安装新建一个“cmake”目录12cd /homemkdir Cmake 解压12cd /home/Cmaketar -xzvf cmake-3.11.3.tar.gz 进入cmake 目录1cd cmake-3.11.3 编译安装12### 最好使用root用户./bootstrap &amp;&amp; make &amp;&amp; make install 验证是否安装成功1cmake -version 配置Clion如图所示： deepin下idea中文异常输入以下命令123supasswdaptitude search uming 1aptitude install fonts-arphic-uming 之后重新启动idea（Netbeans也适用） 安装 Docker参考链接：deepin安装Docker Android Studio: /dev/kvm device permission denied安装 qemu-kvm输入以下命令：1sudo apt install qemu-kvm 检查/dev/kvm 使用的所有权输入以下命令：1ls -al /dev/kvm 结果为：1crw-rw---- 1 root kvm 10, 232 3月 11 10:36 /dev/kvm 检查组中的用户kvm，使用：1grep kvm /etc/group 添加用户到kvm中，请使用：1sudo adduser yourname kvm 再检查1grep kvm /etc/group 最后重启或注销。","categories":[{"name":"deepin","slug":"deepin","permalink":"http://yoursite.com/categories/deepin/"},{"name":"配置","slug":"deepin/配置","permalink":"http://yoursite.com/categories/deepin/配置/"}],"tags":[{"name":"deepin","slug":"deepin","permalink":"http://yoursite.com/tags/deepin/"}]},{"title":"CentOS7+Hadoop-2.9.2+Hbase-1.4.9+MapReduce编程","slug":"CentOS 7+Hadoop-2.9.2+Hbase-1.4.9+MapReduce编程","date":"2019-05-26T03:54:06.907Z","updated":"2019-01-10T07:47:41.000Z","comments":true,"path":"2019/05/26/CentOS 7+Hadoop-2.9.2+Hbase-1.4.9+MapReduce编程/","link":"","permalink":"http://yoursite.com/2019/05/26/CentOS 7+Hadoop-2.9.2+Hbase-1.4.9+MapReduce编程/","excerpt":"所用软件及环境 Centos 7 jdk1.8.0_181 hadoop-2.9.2 Hbase-1.4.9 idea U","text":"所用软件及环境 Centos 7 jdk1.8.0_181 hadoop-2.9.2 Hbase-1.4.9 idea U 注：全程使用root用户 规划 组件 版本 路径 jdk 1.8.0_181 /usr/local/java Hadoop 2.9.2 /usr/local/hadoop Hbase 1.4.9 /usr/local/hbase 节点 node01 node02 node03 注：节点IP根据实际情况自行配置 Hadoop、jdk、Hbase下载下载地址点击即可下载 Hadoop-2.9.2jdk-1.8.0_181Hbase-1.4.9 配置1.主机名修改 在node01上输入 1hostnamectl --static set-hostname node01 2.添加各个节点的IP输入： 1vim /etc/hosts 添加各个节点信息 1234&lt;!-- 下列的IP需根据自己的主机确定，不唯一 --&gt;192.168.130.130 node01192.168.130.133 node02192.168.130.135 node03 3.防火墙设置 若主机中未安装iptables,执行以下命令进行安装 1yum install iptables-services 执行iptables -L -n -v命令可以查看iptables配置，执行以下命令永久关闭主机的iptables： 1chkconfig iptables off 同时关闭主机的iptables和firewalld并设置开机不启动，执行以下命令： 1234systemctl stop iptablessystemctl disable iptablessystemctl stop firewalldsystemctl disable firewalld 执行systemctl status iptables和systemctl status firewalld可以查看防火墙已经关闭。 4.时钟同步 执行以下命令安装ntdate 1yum install ntpdate 执行以下命令同步时针 1ntpdate us.pool.ntp.org 添加时针同步的定时任务，执行以下命令 1crontab -e 接着输入以下内容，设置每天凌晨5点同步时针 10 5 * * * /usr/sbin/ntpdate cn.pool.ntp.org 执行以下命令重启服务并设置开机自启： 12service crond restartsystemctl enable crond.service 5.SSH免密登录 首先执行以下以下命令，可以生成.ssh隐藏文件夹 1ssh localhost 接着执行 12345cd .sshssh-keygen -t rsa #遇到提示一路回车就行ll #会看到 id_rsa id_rsa.pub 两文件前为私钥，后为公钥cat id_rsa.pub &gt;&gt; authorized_keys #把公钥内容追加到authorized_keys文件中chmod 600 authorized_keys #修改文件权限，重要不要忽略 在最后的克隆node01得到的node02,node03主机以及node01上可通过ssh node01/node02/node03/node04测试是否可以免密登录若能连接即为成功 6.安装并配置jdk 通过 git 将已下载好的jdk1.8.0_181 发送给各个节点，执行以下命令 12cd C:/Users//Yan/Downloads #C:/Users//Yan/Downloads为本人jdk1.8.0_181下载后的路径scp jdk1.8.0_181 root@192.168.130.130:/usr/local/java #输入密码后即可将jdk1.8.0_181发送给node01,192.168.130.130为自己node01的IP cd /usr/local/java进入该目录后执行 1tar -zxvf jdk-8u181-linux-x64.tar.gz 添加环境变量,执行 1vim /etc/profile 添加以下配置 1234export JAVA_HOME=/usr/local/java/jdk1.8.0_181export JRE_HOME=$JAVA_HOME/jreexport CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport PATH=.:$JAVA_HOME/bin:$PATH 之后执行以下命令使配置生效 1source /etc/profile 可通过 java -version 查看jdk版本 安装 Hadoop 并配置 执行以下命令 12cd /usr/local/hadooptar -zxvf hadoop-2.9.2.tar.gz #解压 添加环境变量,执行 1vim /etc/profile 在该文件中添加以下内容 12export HADOOP_HOME=/usr/local/hadoop/hadoop-2.9.2export PATH=$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbin 执行 source /etc/profile 使配置生效同时创建Hadoop相关配置目录 1mkdir -p /data/hadoop/hdfs/name /data/hadoop/hdfs/data /var/log/hadoop/tmp 修改相关文件 执行以下命令 1cd /usr/local/hadoop/hadoop-2.9.2/etc/hadoop hadoop-env.sh1export JAVA_HOME=/usr/local/java/jdk1.8.0_181 #一定要写真实路径 core-site.xml1234567&lt;configuration&gt; &lt;!-- define the default file system host and port --&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://node01:9000/&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; hdfs-site.xml123456789101112131415161718192021&lt;configuration&gt; &lt;!-- set namenode storage path--&gt; &lt;!-- storage node info --&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt; &lt;value&gt;file:///root/hdfs/namenode&lt;/value&gt; &lt;description&gt;NameNode directory for namespace and transaction logs storage.&lt;/description&gt; &lt;/property&gt; &lt;!-- set datanode storage path--&gt; &lt;!-- storage data --&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt; &lt;value&gt;file:///root/hdfs/datanode&lt;/value&gt; &lt;description&gt;DataNode directory&lt;/description&gt; &lt;/property&gt; &lt;!-- set the number of copies, default 3, reset to 2 --&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;2&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; mapred-site.xml1234567&lt;configuration&gt; &lt;!-- specify the frame name --&gt; &lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; slaves123node02node03node04 yarn-site.xml1234567891011121314151617&lt;configuration&gt; &lt;!-- Ancillary services running on the NodeManager. You need to configure &quot;mapreduce_shuffle&quot; to run the MapReduce program. --&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt; &lt;/property&gt; &lt;!-- The class corresponding to the auxiliary service in the NodeManager. --&gt; &lt;!-- &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services.mapreduce_shuffle.class&lt;/name&gt; &lt;value&gt;org.apache.hadoop.mapred.ShuffleHandler&lt;/value&gt; &lt;/property&gt; --&gt; &lt;!-- Configuration name node --&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt; &lt;value&gt;node01&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 启动 Hadoop初始化 执行以下命令 12cd /usr/local/hadoop/hadoop-2.9.2/bin./hdfs namenode -format 等待一会后，不报错返回 “Exiting with status 0” 为成功，“Exiting with status 1”为失败切勿多次执行 克隆 对node01进行克隆操作进而得到node02,node03,node04修改node02,node03,node04的主机名，以及检查/etc/hosts文件中的各个节点对应的IP地址是否有误同时也要检查自己配置的/etc/profile文件是否已经生效 启动Hadoop输入以下命令 123sudo -s #若是root用户可省略cd /usr/local/hadoop/hadoop-2.9.2/sbin./start-all.sh 查看Hadoop进程输入命令jps若出现6个进程则为配置正确在浏览器输入192.168.130.130：8088则可以看到在浏览器输入192.168.130.130：50070则可以看到即配置成功 停止Hadoop1./stop-all.sh #在/usr/local/hadoop/hadoop-2.9.2/sbin目录下 安装 Hbase 并配置 执行以下命令 12345678cd /usr/local/hbase/&lt;!-- 解压 --&gt;tar -zxvf hbase-1.4.9-bin.tar.gz&lt;!-- 创建目录 --&gt;cd hbase-1.4.9/mkdir logsmkdir pidsmkdir tmp 配置/etc/profile12export HBASE_HOME=/usr/local/hbasehbase-1.4.9export PATH=$HBASE_HOME/bin:$PATH 1source /etc/profile #使配置立即生效 hbase-env.sh123456789#内容export JAVA_HOME=/usr/local/java/jdk1.8.0_181export HBASE_CLASSPATH=/usr/local/hbase/hbase-1.4.9/conf# 此配置信息，设置由hbase自己管理zookeeper，不需要单独的zookeeper。export HBASE_MANAGES_ZK=trueexport HBASE_HOME=/usr/local/hbase/hbase-1.4.9export HADOOP_HOME=/usr/local/hadoop/hadoop-2.9.2#Hbase日志目录export HBASE_LOG_DIR=/usr/local/hbase/hbase-1.4.9/logs hbase-site.xml123456789101112131415161718&lt;configuration&gt; &lt;property&gt; &lt;name&gt;hbase.rootdir&lt;/name&gt; &lt;value&gt;hdfs://node01:9000/hbase&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.cluster.distributed&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.master&lt;/name&gt; &lt;value&gt;node01:60000&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt; &lt;value&gt;node01:2181,node02:2181,node03:2181&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; regionservers123node01node02node03 拷贝给其他节点12scp -r /usr/local/hbase root@node02:/usr/local/scp -r /usr/local/hbase root@node03:/usr/local/ 启动HBase在node01上启动 执行 12cd /usr/local/hbase/hbase-1.4.9/bin./start-hbase.sh 验证 在每个节点使用jps命令查看 node01上是否有HMaster进程node02,node03上是否有HRegionServer进程 通过node:16010查看HBase集群相关情况,如下图所示： 500 为初始化，稍等即可 wordcount 输入以下命令(root用户下) 123456789101112cd /home/hadoop #hadoop为自己创建的用户名，不固定touch README.txtvim README.txt #下面为README.txt的内容 hello c hello java hello pythonhadoop fs -mkdir /wordcounthadoop fs -mkdir /wordcount/inputhadoop fs -put /home/hadoop/README.txt /wordcount/input cd /usr/local/hadoop/hadoop-2.9.2/share/hadoop/mapreduce/hadoop jar hadoop-mapreduce-examples-2.9.2.jar wordcount /wordcount/input /wordcount/output 出现以下信息即为成功：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364652018-12-29 20:38:15,997 INFO mapreduce.Job: map 100% reduce 0%2018-12-29 20:38:24,174 INFO mapreduce.Job: map 100% reduce 100%2018-12-29 20:38:28,259 INFO mapreduce.Job: Job job_1546086772385_0001 completed successfully2018-12-29 20:38:29,164 INFO mapreduce.Job: Counters: 55 File System Counters FILE: Number of bytes read=50 FILE: Number of bytes written=429541 FILE: Number of read operations=0 FILE: Number of large read operations=0 FILE: Number of write operations=0 HDFS: Number of bytes read=144 HDFS: Number of bytes written=28 HDFS: Number of read operations=8 HDFS: Number of large read operations=0 HDFS: Number of write operations=2 Job Counters Failed map tasks=3 Launched map tasks=4 Launched reduce tasks=1 Other local map tasks=3 Data-local map tasks=1 Total time spent by all maps in occupied slots (ms)=38093 Total time spent by all reduces in occupied slots (ms)=5732 Total time spent by all map tasks (ms)=38093 Total time spent by all reduce tasks (ms)=5732 Total vcore-milliseconds taken by all map tasks=38093 Total vcore-milliseconds taken by all reduce tasks=5732 Total megabyte-milliseconds taken by all map tasks=39007232 Total megabyte-milliseconds taken by all reduce tasks=5869568 Map-Reduce Framework Map input records=5 Map output records=6 Map output bytes=56 Map output materialized bytes=50 Input split bytes=110 Combine input records=6 Combine output records=4 Reduce input groups=4 Reduce shuffle bytes=50 Reduce input records=4 Reduce output records=4 Spilled Records=8 Shuffled Maps =1 Failed Shuffles=0 Merged Map outputs=1 GC time elapsed (ms)=152 CPU time spent (ms)=2050 Physical memory (bytes) snapshot=517804032 Virtual memory (bytes) snapshot=5624598528 Total committed heap usage (bytes)=336592896 Peak Map Physical memory (bytes)=293904384 Peak Map Virtual memory (bytes)=2790219776 Peak Reduce Physical memory (bytes)=223899648 Peak Reduce Virtual memory (bytes)=2834378752 Shuffle Errors BAD_ID=0 CONNECTION=0 IO_ERROR=0 WRONG_LENGTH=0 WRONG_MAP=0 WRONG_REDUCE=0 File Input Format Counters Bytes Read=34 File Output Format Counters Bytes Written=28 查看统计结果 12hdfs dfs -ls /wordcount/outputhdfs dfs -cat /wordcount/output/part-r-00000 MapReduce编程pom.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.hadoop&lt;/groupId&gt; &lt;artifactId&gt;wordcount&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;commons-beanutils&lt;/groupId&gt; &lt;artifactId&gt;commons-beanutils&lt;/artifactId&gt; &lt;version&gt;1.9.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-common&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-hdfs&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-mapreduce-client-common&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-mapreduce-client-core&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; src/main/java/WordcountMapper.java12345678910111213141516171819202122232425import org.apache.hadoop.io.IntWritable;import org.apache.hadoop.io.LongWritable;import org.apache.hadoop.io.Text;import org.apache.hadoop.mapreduce.Mapper;import java.io.IOException;/** * Created by zxk on 2017/6/29. */public class WordcountMapper extends Mapper&lt;LongWritable, Text, Text, IntWritable&gt; &#123; protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException &#123; //得到输入的每一行数据 String line = value.toString(); //通过空格分隔 String[] words = line.split(&quot; &quot;); //循环遍历输出 for (String word : words) &#123; context.write(new Text(word), new IntWritable(1)); &#125; &#125;&#125; src/main/java/WordcountReducer.java123456789101112131415161718import org.apache.hadoop.io.IntWritable;import org.apache.hadoop.io.Text;import org.apache.hadoop.mapreduce.Reducer;import java.io.IOException;/** * Created by zxk on 2017/6/29. */public class WordcountReducer extends Reducer&lt;Text, IntWritable, Text, IntWritable&gt; &#123; protected void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context) throws IOException, InterruptedException &#123; Integer count = 0; for (IntWritable value : values) &#123; count += value.get(); &#125; context.write(key, new IntWritable(count)); &#125;&#125; src/main/java/WordCountMapReduce.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.fs.Path;import org.apache.hadoop.io.IntWritable;import org.apache.hadoop.io.Text;import org.apache.hadoop.mapreduce.Job;import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;/** * Created by zxk on 2017/6/29. */public class WordCountMapReduce &#123; public static void main(String[] args) throws Exception &#123; //创建配置对象 Configuration conf = new Configuration(); //创建job对象 Job job = Job.getInstance(conf, &quot;wordcount&quot;); //设置运行job的类 job.setJarByClass(WordCountMapReduce.class); //设置mapper 类 job.setMapperClass(WordcountMapper.class); //设置reduce 类 job.setReducerClass(WordcountReducer.class); //设置map输出的key value job.setMapOutputKeyClass(Text.class); job.setMapOutputValueClass(IntWritable.class); //设置reduce 输出的 key value job.setOutputKeyClass(Text.class); job.setOutputValueClass(IntWritable.class); //设置输入输出的路径 FileInputFormat.setInputPaths(job, new Path(args[0])); FileOutputFormat.setOutputPath(job, new Path(args[1])); //提交job boolean b = job.waitForCompletion(true); if (!b) &#123; System.out.println(&quot;wordcount task fail!&quot;); &#125; &#125;&#125; 编译打包 在idea中打jar包可以参考这里 点击 运行12&lt;!-- 一些命令与worcount命令相同不再重复 --&gt;hadoop jar hadoop-demo.jar WordCountMapReduce /wordcount/input /wordcount/output 参考 在centos7上搭建hadoop集群CentOS 7搭建Apache Hadoop 3.1.1集群Linux上安装Hadoop集群(CentOS7+hadoop-2.8.0)Centos7虚拟机 搭建 Hadoop3.1.1 教程CentOS 7下安装集群HBase1.2.4windows下idea编写WordCount程序，并打jar包上传到hadoop集群运行 推荐 使用 Docker 搭建 Hadoop 集群","categories":[{"name":"大数据","slug":"大数据","permalink":"http://yoursite.com/categories/大数据/"},{"name":"Hadoop Hbase MapReduce编程","slug":"大数据/Hadoop-Hbase-MapReduce编程","permalink":"http://yoursite.com/categories/大数据/Hadoop-Hbase-MapReduce编程/"}],"tags":[{"name":"大数据","slug":"大数据","permalink":"http://yoursite.com/tags/大数据/"},{"name":"Hadoop Hbase MapReduce编程","slug":"Hadoop-Hbase-MapReduce编程","permalink":"http://yoursite.com/tags/Hadoop-Hbase-MapReduce编程/"}]},{"title":"bugzilla","slug":"buzilla","date":"2019-05-26T03:54:06.886Z","updated":"2019-05-22T11:11:34.904Z","comments":true,"path":"2019/05/26/buzilla/","link":"","permalink":"http://yoursite.com/2019/05/26/buzilla/","excerpt":"bugzilla准备 系统：Windows 7 MySql 5.5.62及以上 Bugzilla 4.2及以上 ActivePerl 5.24.3.2404及以上 XAMPP 7.1.29及以上","text":"bugzilla准备 系统：Windows 7 MySql 5.5.62及以上 Bugzilla 4.2及以上 ActivePerl 5.24.3.2404及以上 XAMPP 7.1.29及以上 下载MySql 5.5.62下载地址：MySql 5.5.62 Bugzilla 4.2下载地址：Bugzilla 4.2 ActivePerl 5.24.3.2404下载地址：ActivePerl 5.24.3.2404 XAMPP 7.1.29下载地址：XAMPP 7.1.29 安装XAMPP 7.1.29参考：https://www.jianshu.com/p/07455416d68c ActivePerl 5.24.3.2404双击activeperl安装界面，一直点击next直至完成安装，activeperl的选项都是默认的选项，依照默认安装即可。 验证perl是否安装成功cmd界面运行perl -v，出现版本号即为成功。如下图： MySql 5.5.62步骤大致如下图： 路径设置为C:\\MySql,因为Bugzilla默认的引导路径为这个。 Bugzilla 4.2 解压Bugzilla 4.2文件，将解压后的内容复制到C:\\xampp\\htdocs\\bugzilla文件夹下，若没有则先建一个文件夹。 win+R 打开cmd窗口，同时进入到C:\\xampp\\htdocs\\bugzilla目录下。 输入checksetup.pl命令。如下图： 安装perl模块，使用perl install XXX进行安装未安装的perl模块。如下图所示： 可能会有一些模块无法安装，可以直接忽略。再次运行checksetup.pl命令，可能会需要安装DDB-MySql这个模块，安装之后再次运行checksetup.pl命令，出现下图则未成功。 编辑C:\\xampp\\htdocs\\bugzilla下的localconfig文件。 打开localconfig文件，将其中的$db_port = 0;改为$db_port = 3306; $index_html = 0;改为$index_html = 1。 打开MySQL 5.5 Command Line Client。下面在MySQL服务器中创建一个bugs数据库，和一个bugs用户，以及为该用户授予相应的权限，命令如下：create database bugs; 创建一个数据库bugscreate user bugs@localhost; 创建一个用户bugsgrant all on bugs.* to bugs@’localhost’; 为用户bugs授权flush privileges; 刷新用户权限 在命令行下再次运行checksetup.pl将会生成和数据库有关的数据表。但是可能会出现报错，显示的是无法找到什么什么的表，这时候只需要把上一步创建的数据库bugs删除再重新创建即可，若无法解决自行查找资料。生成数据表后会要求填入主机的地址服务器地址，管理员名字和账号（该账号是一个email地址）以及管理员登陆的密码。（自由发挥） 将C:\\xampp\\htdocs\\bugzilla下的后缀名为.cgi的文件中的 #!/usr/bin/perl 改为#!”C:\\Perl64\\bin\\perl.exe”。 运行打开XAMPP界面的Apache,在浏览器中输入http://localhost/bugzilla。","categories":[{"name":"软件缺陷","slug":"软件缺陷","permalink":"http://yoursite.com/categories/软件缺陷/"},{"name":"bugzilla","slug":"软件缺陷/bugzilla","permalink":"http://yoursite.com/categories/软件缺陷/bugzilla/"}],"tags":[{"name":"软件缺陷","slug":"软件缺陷","permalink":"http://yoursite.com/tags/软件缺陷/"},{"name":"bugzilla","slug":"bugzilla","permalink":"http://yoursite.com/tags/bugzilla/"}]},{"title":"BugFree安装","slug":"BugFree","date":"2019-05-26T03:54:06.865Z","updated":"2019-04-22T14:06:59.994Z","comments":true,"path":"2019/05/26/BugFree/","link":"","permalink":"http://yoursite.com/2019/05/26/BugFree/","excerpt":"BugFree准备工作：（Windows环境下） XAMPP 版本在5.x.x bugfree_v3.0.1 不要用最新版本的XAMPP，切记。","text":"BugFree准备工作：（Windows环境下） XAMPP 版本在5.x.x bugfree_v3.0.1 不要用最新版本的XAMPP，切记。 下载XAMPP bugfree提取码: ff5d XAMPP 安装双击exe文件傻瓜式安装。 安装 bugfree1.在上一步安装XAMPP时路径C:\\xampp\\htdocs\\下新建文件夹bugfree,将下载bugfree文件解压后的内容复制进去。同时在新建一个BugFile文件夹，用于下一步操作。2.打开XAMPP主界面上的前两个start按钮。3.打开浏览器输入localhost/bugfree,如下图： 4.上图中的全部为绿色的勾勾仅为成功。然后点击继续。5.按照下图中进行配置。 6.然后修改C:\\xampp\\htdocs\\bugfree\\protected\\config中的main.php。全部替换即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104&lt;?phpreturn array ( &apos;basePath&apos; =&gt; &apos;C:\\\\xampp\\\\htdocs\\\\bugfree\\\\protected\\\\config\\\\..&apos;, &apos;name&apos; =&gt; &apos;BugFree 3.0.1&apos;, &apos;preload&apos; =&gt; array ( 0 =&gt; &apos;log&apos;, ), &apos;language&apos; =&gt; &apos;zh_cn&apos;, &apos;theme&apos; =&gt; &apos;classic&apos;, &apos;defaultController&apos; =&gt; &apos;site&apos;, &apos;timeZone&apos; =&gt; &apos;Asia/Shanghai&apos;, &apos;import&apos; =&gt; array ( 0 =&gt; &apos;application.models.*&apos;, 1 =&gt; &apos;application.components.*&apos;, 2 =&gt; &apos;application.service.*&apos;, ), &apos;modules&apos; =&gt; array ( &apos;gii&apos; =&gt; array ( &apos;class&apos; =&gt; &apos;system.gii.GiiModule&apos;, &apos;password&apos; =&gt; &apos;123456&apos;, &apos;ipFilters&apos; =&gt; array ( 0 =&gt; &apos;127.0.0.1&apos;, 1 =&gt; &apos;::1&apos;, ), ), ), &apos;components&apos; =&gt; array ( &apos;user&apos; =&gt; array ( &apos;allowAutoLogin&apos; =&gt; true, ), &apos;request&apos; =&gt; array ( &apos;enableCookieValidation&apos; =&gt; true, ), &apos;cache&apos; =&gt; array ( &apos;class&apos; =&gt; &apos;CDbCache&apos;, &apos;connectionID&apos; =&gt; &apos;db&apos;, ), &apos;db&apos; =&gt; array ( &apos;pdoClass&apos; =&gt; &apos;NestedPDO&apos;, &apos;connectionString&apos; =&gt; &apos;mysql:host=localhost;dbname=bugfree;port=3306&apos;, &apos;emulatePrepare&apos; =&gt; true, &apos;username&apos; =&gt; &apos;root&apos;, &apos;password&apos; =&gt; &apos;&apos;, &apos;charset&apos; =&gt; &apos;utf8&apos;, &apos;tablePrefix&apos; =&gt; &apos;bf_&apos;, ), &apos;errorHandler&apos; =&gt; array ( &apos;errorAction&apos; =&gt; &apos;site/error&apos;, ), &apos;log&apos; =&gt; array ( &apos;class&apos; =&gt; &apos;CLogRouter&apos;, &apos;routes&apos; =&gt; array ( 0 =&gt; array ( &apos;class&apos; =&gt; &apos;CFileLogRoute&apos;, &apos;levels&apos; =&gt; &apos;info, error, warning&apos;, &apos;categories&apos; =&gt; &apos;bugfree.*&apos;, ), ), ), ), &apos;params&apos; =&gt; array ( &apos;uploadPath&apos; =&gt; &apos;../BugFile&apos;, &apos;picPreviewApp&apos; =&gt; &apos;http://::1/BugFile&apos;, &apos;allUserGroupId&apos; =&gt; 1, &apos;ldap&apos; =&gt; array ( &apos;host&apos; =&gt; &apos;&apos;, &apos;port&apos; =&gt; &apos;&apos;, &apos;base&apos; =&gt; &apos;&apos;, &apos;user&apos; =&gt; &apos;&apos;, &apos;pass&apos; =&gt; &apos;&apos;, ), &apos;mail&apos; =&gt; array ( &apos;on&apos; =&gt; &apos;1&apos;, &apos;from_address&apos; =&gt; &apos;bugfree-noreply@test.com&apos;, &apos;from_name&apos; =&gt; &apos;BugFree&apos;, &apos;send_method&apos; =&gt; &apos;SMTP&apos;, &apos;send_params&apos; =&gt; array ( &apos;host&apos; =&gt; &apos;&apos;, &apos;smtp_auth&apos; =&gt; false, &apos;username&apos; =&gt; &apos;&apos;, &apos;password&apos; =&gt; &apos;&apos;, ), ), ),)?&gt; 7.刷新之后就会出现登录界面。","categories":[{"name":"软件缺陷","slug":"软件缺陷","permalink":"http://yoursite.com/categories/软件缺陷/"},{"name":"BugFree","slug":"软件缺陷/BugFree","permalink":"http://yoursite.com/categories/软件缺陷/BugFree/"}],"tags":[{"name":"软件缺陷","slug":"软件缺陷","permalink":"http://yoursite.com/tags/软件缺陷/"},{"name":"BugFree","slug":"BugFree","permalink":"http://yoursite.com/tags/BugFree/"}]},{"title":"Android studio-AVD","slug":"AVD","date":"2019-05-26T03:54:06.850Z","updated":"2019-04-08T14:33:58.931Z","comments":true,"path":"2019/05/26/AVD/","link":"","permalink":"http://yoursite.com/2019/05/26/AVD/","excerpt":"AVD","text":"AVD 点击上图红圈中的图标后，在出现的界面中点击Create Virtual Device… 之后会出现以下情况 选择自己喜欢的系统进行下载。 可以参考以下链接： 创建和管理虚拟设备","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"Android studio-AVD","slug":"Android/Android-studio-AVD","permalink":"http://yoursite.com/categories/Android/Android-studio-AVD/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Android studio-AVD","slug":"Android-studio-AVD","permalink":"http://yoursite.com/tags/Android-studio-AVD/"}]},{"title":"Android 简介","slug":"Android 简介","date":"2019-05-26T03:54:06.837Z","updated":"2018-11-05T04:32:39.000Z","comments":true,"path":"2019/05/26/Android 简介/","link":"","permalink":"http://yoursite.com/2019/05/26/Android 简介/","excerpt":"了解全貌Android发展史&emsp;&emsp;2003年10月，Andy Rubin等人一起创办了Android公司。2005年8月谷歌收购这家仅仅成立了22月的公司，并让Andy Rubin继续负责Android项目。在2008年推出第一个Android系统版本。之后遭到重重阻挠，但是再多的困难也阻挡不了Android快速前进的步伐。现在Android系统是目前世界上市场上占有率最高的移动操作系统。","text":"了解全貌Android发展史&emsp;&emsp;2003年10月，Andy Rubin等人一起创办了Android公司。2005年8月谷歌收购这家仅仅成立了22月的公司，并让Andy Rubin继续负责Android项目。在2008年推出第一个Android系统版本。之后遭到重重阻挠，但是再多的困难也阻挡不了Android快速前进的步伐。现在Android系统是目前世界上市场上占有率最高的移动操作系统。 Android系统架构1.Linux内核层&emsp;&emsp;Android 系统是基于 Linux 内核的，这一层为 Android 设备的各种硬件提供了底层的驱动，如显示驱动、音频驱动、照相机驱动、蓝牙驱动等等。 2.系统运行库&emsp;&emsp;这一层通过一些 C/C++ 库来为 Android 系统提供了主要的特性支持。同时这一层还有 Android 运行时库，主要提供一些核心库，能够允许开发者使用 Java 语言来编写 Android 应用。 Android 运行时库中还包括了 Dalvik 虚拟机（5.0系统之后改为 ART 运行环境）,它使得每一个 Android 应用都能运行在独立的进程中，并且拥有一个自己的 Dalvik 虚拟机实力。相比较于 Java 虚拟机，Dalvik 是专门为移动设备定制的，它针对手机内存、CPU性能有限等情况做了优化处理。 3.应用框架层&emsp;&emsp;这一层主要提供了构建应用程序时可能用到的各种 API ，Android 自带的一些核心应用就是使用这些 API 完成的，开发者也可以通过这些 API 构建自己的应用程序。 4.应用层&emsp;&emsp;手机上的所有应用程序就属于这一层，如系统自带的程序或第三方软件。 Android 已发布的版本Android系统版本及其代号 版本号 系统代号 1.0 无 1.1 Petit Four 1.5 Cupcake 1.6 Donut 2.0/2.1 Éclair 2.2 Froyo 2.3 Gingerbread 3.0/3.1/3.2 Honeycomb 4.0 Ice Cream Sandwich 4.1/4.2/4.3 Jelly Bean 4.4 KitKat 5.0/5.1 Lollipop 6.0 Marshmallow 7.0 Nougat（Android N） 8.0 Oreo（Android O） 9.0 Pie （Android P） Android 应用开发特色1.四大组件&emsp;&emsp;Android系统四大组件分别为活动（Activity）、服务（Service）、广播接收器（Broadcast Receiver)和内容提供器（Content Provider)。 2.丰富的系统控件&emsp;&emsp;为开发者提供了丰富的系统控件，使得开发者更轻松地编写出漂亮的界面。 3.SQLLite 数据库&emsp;&emsp;Android系统自带了轻量级、运算速度极快的嵌入式关系型数据库。不仅支持标准的SQL语法，还可以通过Android封装好的API进行操作，让存储和读取数据变得更为方便。 4.强大的多媒体&emsp;&emsp;Android提供了丰富的多媒体服务。可以在程序中通过代码进行控制。 5.地理位置定位&emsp;&emsp;内置GPS，随时随地提供位置服务。 参考书籍第一行代码（第二版） 郭霖*著","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"简介","slug":"Android/简介","permalink":"http://yoursite.com/categories/Android/简介/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"简介","slug":"简介","permalink":"http://yoursite.com/tags/简介/"}]},{"title":"Android studio安装","slug":"Android studio安装","date":"2019-05-26T03:54:06.827Z","updated":"2018-11-07T09:47:10.000Z","comments":true,"path":"2019/05/26/Android studio安装/","link":"","permalink":"http://yoursite.com/2019/05/26/Android studio安装/","excerpt":"准备 1.配置环境变量 2.安装 3.创建HelloWorld","text":"准备 1.配置环境变量 2.安装 3.创建HelloWorld 配置环境变量 为什么首先要配置环境变量呢？配置环境变量可以防止之后Android studio安装SDK时安装到默认位置，减少C盘的占用空间。 新建 变量名 ANDROID_HOME ，值为 自己创建的放置SDK的路径 安装 首先下载 Android studio &gt;下载完成直接打开。 如果不想安装到C盘也可以选择其他的。 等待一段时间。 点击 cancle 选择喜欢的主题 之后就是漫长的等待… 等待总会有结果的。 创建第一个 Android 程序 HelloWorld 点击上图中的 Start a new Android Studio project Application name 填写 HelloWorldCompany domain 按照系统默认的就行Project location 存放自己代码的位置，可自定义。 系统默认即可 一般选择 Empty Activity 点击 Finish。 等待红线部分加载完毕。加载完成后点击工具栏-Bulid—Bulid Bundle(s)/APK(s)-Bulid APK(s)。之后可以选择自己手机运行自己的程序。也可以选择下图中的自行安装模拟器运行。 之后再补充…","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"Android studio安装","slug":"Android/Android-studio安装","permalink":"http://yoursite.com/categories/Android/Android-studio安装/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Android studio安装","slug":"Android-studio安装","permalink":"http://yoursite.com/tags/Android-studio安装/"}]},{"title":"AlertDialog","slug":"AlertDialog","date":"2019-05-26T03:54:06.813Z","updated":"2019-04-19T08:14:01.319Z","comments":true,"path":"2019/05/26/AlertDialog/","link":"","permalink":"http://yoursite.com/2019/05/26/AlertDialog/","excerpt":"AlertDialogAlertDialog可以在当前的界面弹出一个对话框，这个对话框是置顶于所有界面元素之上的，能够屏蔽掉其他空间的交互能力，因此AlertDialog一般都是用于提示一些非常重要的内容或者警告信息。比如为了防止用户误删重要内容，在删除前弹出一个确认对话框。","text":"AlertDialogAlertDialog可以在当前的界面弹出一个对话框，这个对话框是置顶于所有界面元素之上的，能够屏蔽掉其他空间的交互能力，因此AlertDialog一般都是用于提示一些非常重要的内容或者警告信息。比如为了防止用户误删重要内容，在删除前弹出一个确认对话框。 创建布局activity_main.xml 123456789101112&lt;LinearLayout android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;Button android:id=&quot;@+id/button&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;button&quot;/&gt; &lt;/LinearLayout&gt; 为Button添加事件MainActivity 12345678910111213141516171819202122232425262728293031323334353637public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button = findViewById(R.id.button); button.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.button: AlertDialog.Builder dialog = new AlertDialog.Builder(MainActivity.this); dialog.setTitle(&quot;This is Dialog&quot;); //设置标题 dialog.setMessage(&quot;Something important.&quot;); //设置内容 dialog.setCancelable(false); //设置是否可以取消 dialog.setPositiveButton(&quot;OK&quot;, new DialogInterface.OnClickListener() &#123; //设置点击确定按钮的事件 @Override public void onClick(DialogInterface dialog, int which) &#123; &#125; &#125;); dialog.setNegativeButton(&quot;Cancle&quot;, new DialogInterface.OnClickListener() &#123; //设置取消按钮的事件 @Override public void onClick(DialogInterface dialog, int which) &#123; &#125; &#125;); dialog.show(); break; default: break; &#125; &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"AlertDialog","slug":"Android/AlertDialog","permalink":"http://yoursite.com/categories/Android/AlertDialog/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"AlertDialog","slug":"AlertDialog","permalink":"http://yoursite.com/tags/AlertDialog/"}]},{"title":"AJAX 简介","slug":"AJAX简介","date":"2019-05-26T03:54:06.788Z","updated":"2018-12-19T12:11:57.000Z","comments":true,"path":"2019/05/26/AJAX简介/","link":"","permalink":"http://yoursite.com/2019/05/26/AJAX简介/","excerpt":"AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。","text":"AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 什么是AJAXAJAX=异步 JavaScript 和 XML。AJAX 是一种用于创建快速动态网页的技术。通过在后台与服务器进行少量数据交换，AJAX可以是网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用AJAX）如果需要更新内容，必须要重新加载整个页面。AJAX的应用实例：Google地图等。 AJAX是基于现有的Internet标准AJAX是基于现有的Internet标准，并且联合使用它们： XMLHttpRequest 对象 (异步的与服务器交换数据) JavaScript/DOM (信息显示/交互) CSS (给数据定义样式) XML (作为转换数据的格式) AJAX应用程序与浏览器和平台无关的！ 参考AJAX 简介AJAX 简介","categories":[{"name":"AJAX","slug":"AJAX","permalink":"http://yoursite.com/categories/AJAX/"},{"name":"AJAX基础","slug":"AJAX/AJAX基础","permalink":"http://yoursite.com/categories/AJAX/AJAX基础/"},{"name":"简介","slug":"AJAX/AJAX基础/简介","permalink":"http://yoursite.com/categories/AJAX/AJAX基础/简介/"}],"tags":[{"name":"AJAX","slug":"AJAX","permalink":"http://yoursite.com/tags/AJAX/"},{"name":"简介","slug":"简介","permalink":"http://yoursite.com/tags/简介/"}]},{"title":"AJAX 实例","slug":"AJAX实例","date":"2019-05-26T03:54:06.780Z","updated":"2019-02-25T11:58:00.000Z","comments":true,"path":"2019/05/26/AJAX实例/","link":"","permalink":"http://yoursite.com/2019/05/26/AJAX实例/","excerpt":"通过实例来了解AJAX的工作原理。","text":"通过实例来了解AJAX的工作原理。 AJAX的工作原理 AJAX的工作原理 手动尝试 实例解释上面的 AJAX 应用程序包含一个 div 和一个按钮。 div 部分用于显示来自服务器的信息。当按钮被点击时，它负责调用名为 loadXMLDoc() 的函数： 12345678html&gt;&lt;body&gt;&lt;div id=&quot;myDiv&quot;&gt;&lt;h3&gt;Let AJAX change this text&lt;/h3&gt;&lt;/div&gt;&lt;button type=&quot;button&quot; onclick=&quot;loadXMLDoc()&quot;&gt;Change Content&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 接下来，在页面的 head 部分添加一个&lt; script &gt;标签。该标签中包含了这个 loadXMLDoc() 函数： 12345678&lt;head&gt;&lt;script type=&quot;text/javascript&quot;&gt;function loadXMLDoc()&#123;.... AJAX script goes here ...&#125;&lt;/script&gt;&lt;/head&gt; 参考AJAX 实例","categories":[{"name":"AJAX","slug":"AJAX","permalink":"http://yoursite.com/categories/AJAX/"},{"name":"AJAX基础","slug":"AJAX/AJAX基础","permalink":"http://yoursite.com/categories/AJAX/AJAX基础/"},{"name":"实例","slug":"AJAX/AJAX基础/实例","permalink":"http://yoursite.com/categories/AJAX/AJAX基础/实例/"}],"tags":[{"name":"AJAX","slug":"AJAX","permalink":"http://yoursite.com/tags/AJAX/"},{"name":"实例","slug":"实例","permalink":"http://yoursite.com/tags/实例/"}]}]}