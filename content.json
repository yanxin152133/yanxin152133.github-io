{"meta":{"title":"Yan's blog","subtitle":null,"description":null,"author":"Yan","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2019-05-02T03:51:18.000Z","updated":"2019-05-02T03:52:19.545Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-05-02T03:51:26.000Z","updated":"2019-05-02T03:52:17.154Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"个人觉得比较好的一些插件","slug":"插件","date":"2019-10-10T16:00:00.000Z","updated":"2019-10-11T00:05:14.536Z","comments":true,"path":"2019/10/11/插件/","link":"","permalink":"http://yoursite.com/2019/10/11/插件/","excerpt":"Visual Studio CodeChinese (Simplified) Language Pack for Visual Studio Code适用于 VS Code 的中文（简体）语言包。","text":"Visual Studio CodeChinese (Simplified) Language Pack for Visual Studio Code适用于 VS Code 的中文（简体）语言包。 Markdown Preview EnhancedMarkdown Preview Enhanced 是一款为 Atom 以及 Visual Studio Code 编辑器编写的超级强大的 Markdown 插件。 这款插件意在让你拥有飘逸的 Markdown 写作体验。 City Lights Icon package一个美化 Visual Studio Code 图标的插件。 浏览器插件广告净化器免费高效的广告过滤工具：可以过滤烦人的视频广告、弹窗广告、大横幅广告等网页广告，让你清爽浏览网页。 下载地址：谷歌浏览器 火狐浏览器 Convertio一个文件转换器。网址：https://convertio.co/zh/ 适用于Chrome的Web服务器Web Server for Chrome适用于Chrome的Web服务器使用HTTP通过网络从本地文件夹提供网页。可离线运行。","categories":[{"name":"插件","slug":"插件","permalink":"http://yoursite.com/categories/插件/"}],"tags":[{"name":"插件","slug":"插件","permalink":"http://yoursite.com/tags/插件/"}]},{"title":"Ubuntu18.04安装与升级nodejs和npm","slug":"Ubuntu18.04安装与升级nodejs和npm","date":"2019-10-10T14:54:56.000Z","updated":"2019-10-11T00:14:43.439Z","comments":true,"path":"2019/10/10/Ubuntu18.04安装与升级nodejs和npm/","link":"","permalink":"http://yoursite.com/2019/10/10/Ubuntu18.04安装与升级nodejs和npm/","excerpt":"升级npm 命令sudo npm install npm -g","text":"升级npm 命令sudo npm install npm -g 升级node.js命令步骤sudo npm cache clean -f #----- 先清除 npm cache npm install -g n #----- 安装 n 模块 sudo n stable #----- 安装最新的 node.js 稳定版 查看版本node -v # 查看node.js版本 npm -v # 查看npm版本","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://yoursite.com/categories/Ubuntu/"},{"name":"Ubuntu18.04安装与升级nodejs和npm","slug":"Ubuntu/Ubuntu18-04安装与升级nodejs和npm","permalink":"http://yoursite.com/categories/Ubuntu/Ubuntu18-04安装与升级nodejs和npm/"}],"tags":[{"name":"Ubuntu18.04安装与升级nodejs和npm","slug":"Ubuntu18-04安装与升级nodejs和npm","permalink":"http://yoursite.com/tags/Ubuntu18-04安装与升级nodejs和npm/"}]},{"title":"mysql","slug":"mysql","date":"2019-09-05T16:00:00.000Z","updated":"2019-10-11T00:12:14.677Z","comments":true,"path":"2019/09/06/mysql/","link":"","permalink":"http://yoursite.com/2019/09/06/mysql/","excerpt":"环境 Linux/Ubuntu18.04 docker mysql 5.6 代码仓库 GitHub 视频地址参考： 链接: https://pan.baidu.com/s/1oxqVH8_GH94bhbpmQ4b-8Q 提取码: wsfd","text":"环境 Linux/Ubuntu18.04 docker mysql 5.6 代码仓库 GitHub 视频地址参考： 链接: https://pan.baidu.com/s/1oxqVH8_GH94bhbpmQ4b-8Q 提取码: wsfd 数据库概念 数据库（Database）是按照数据结构来阻止、存储和管理数据的建立再计算机存储设备上的仓库。 数据库:存储数据的仓库。 数据库分类网络数据库 网络数据库是指把数据库技术引入到计算机网络系统中，借助于网络技术将存储与数据库中的大量信息及时发布出去；而计算机网络借助于成熟的数据库技术对网络中的各种数据进行有效管理，并实现用户与网络中的数据库进行实时动态数据交互。 层级数据库 层次结构模型实质上是一种有根结点的定向有序树（在数学中“树”被定义为一个无回的连通图）。 关系数据库 关系数据库，是建立在关系模型基础上的数据库，借助于几何代数等数学概念和方法来处理数据库中的数据。 数据库的另一种区分方式：基于存储介质。 存储介质分为两种：磁盘和内存。 关系型数据库：存储在磁盘中。 非关系型数据库：存储在内存中。 关系型数据库基本概念 关系数据库，是建立在关系模型基础上的数据库，借助于几何代数等数学概念和方法来处理数据库中的数据。现实世界中的各种实体以及实体之间的各种练习均用关系模型来表示。关系模型是由埃德加·科德于1970年首先提出的，并配合“科德十二定律”。现如今虽然对此模型有一些批评意见，但它还是数据存储的传统标准。关系模型由关系数据结构、关系操作集合、关系完整性约束三部分组成。 关系数据结构：指的是数据以什么方式来存储，是一种二维表的形式存储。 本质：二维表 关系操作集合:如何来关联和管理对应的存储数据，SQL指令 关系完整性约束：数据内部有对应的关联关系，以及数据与数据之间也有对应的关联关系。 表内约束：对应的具体列只能放对应的数据（不能乱放） 表间约束：自然界各实体都是有着对应的关联关系（外键） 典型关系型数据库 小型关系型数据库Microsoft Access、SQLite 中型关系型数据库：Microsoft SQL Server、MySQL 大型关系型数据库：Oracle、DB2 SQL介绍SQL基本介绍 结构化查询语言（Structured Query Language）简称SQL，是一种特殊目的的编程语言，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统；同时也是数据库脚本文件的扩展名。 SQL就是专门为关系型数据库而设计出来的。 SQL分类 数据查询语言（DQL：Data Query Language）:其语句，也称为“数据检索语句”，用以从表中获取数据，确定数据怎样在应用程序给出。保留字SELETE是DQL（也是所有SQL）用的最多的动词i，其它DQL常用的保留字有WHERE，ORDER BY，GROUP BY和HAVING。这些DQL保留字常与其他类型的SQL语句一起使用。专门用于查询数据：代表指令为selete/show 数据操作语言（DML：Data Manipulation Language）:其语句包括动词INSERT，UPDATE和DELETE。它们分别用于添加、修改和删除表中的行。也称为动作查询语言。专门用于写数据：代表指令：insert,update和delete 事务处理语言（TPL）：它的语句能确保被DML语句影响的表的所有行即使得以更新。TPL语句包括BEGIN、TRANSACTIOIN、COMMIT和ROLLBACK。（不是所有的关系型数据库都提供事务安全处理）专门用于事务安全处理：transation 数据控制语言（DCL）：它的语句通过GRANT和REVOKE获取许可，确定单个用户和用户组对数据库对象的访问。某些RDBMS可用GRANT或REVOKE控制对表单个列的访问。专门用于权限管理：代表指令为grant和revoke 数据定义语言（DDL）：其语句包括动词CREATE和DROP。在数据库中创建新表或删除表（CREATE TABLE或DROP TABLE）；为表加入索引等。DDL包括许多与数据库目录中获得数据有关的保留字。它也是动作查询的一部分。专门用于结构管理：代表指令create和drop(alter) MySQL基本介绍 MySQL是一个关系型数据库关系系统，由瑞典MySQL AB公司开发，目前属于Oracle旗下产品。MySQL是最流行的关系型数据库管理系统之一，在WEB应用方面，MySQL是最好的RDBMS（Relational Database Management System,关系数据库管理系统）应用软件。 启动和停止MySQL MySQL是一种C/S结构：客户端和服务端。 命令行方式通过Windows下打开cmd控制器，然后使用命令进行管理。 net start 服务（mysql）：开启服务 net stop mysql：关闭服务 系统服务方式前提：在安装的MySQL的时候将MySQL添加到Windows的服务中去。 登录和退出MySQL通过客户端与服务器进行连接认证，就可以进行操作。通常服务端与客户端不在同一台电脑上。 登录 找到相关程序 输入对应的服务器地址 输入服务器中MySQL监听的端口 输入用户名：-u:username 输入密码：-p:password 注意事项 通常端口都可以默认，MySQL监听的端口通常是3306 密码的输入可以先输入-p，直接换行，然后再以密文方式输入密码 退出断开与服务器的连接：通常MySQL提供的服务器数量有限，一旦客户端用完，建议就应该断开连接。建议方式：使用SQL提供的指令 exit; \\q quit MySQL服务端架构 MySQL服务端架构有以下几层构成： 数据库管理系统（最外层）：DBMS，专门管理服务器端的所有内容 数据库（第二层）：DB，专门用于存储数据的仓库（可以有很多个） 二维数据表（第三层）：Table，专门用于存储具体实体的数据 字段（第四层）：Field，具体存储某种类型的数据（实际存储单元） 数据库中常用的几个关键字： row：行 Column：列（field） 数据库基本操作 数据库是数据存储的最外层（最大单元） 库操作创建数据库基本语法： create database 数据库名字 [库选项]; ## 示例代码 create database mydatabase; 库选项：数据库的相关属性。 字符集：charset字符集，代表着当前数据库下的所有表存储的数据默认指定的字符集（如果当前不指定，那么采用DBMS默认的）。 校对集：collate校对集 基本语法： create database 数据库名字 charset 字符集名称; ## 示例代码 create database mydatabase2 charset gbk; 显示数据库 每当用户通过SQL指令创建一个数据库，那么系统就会产生一个对应的存储数据的文件夹（data） 显示全部基本语法： show databases; 显示部分基本语法： show databases like &#39;匹配模式&#39;; _：匹配当前位置单个字符 %：匹配指定位置多个字符 获取以my开头的全部数据库：&#39;my%&#39;; 获取m开头，后面第一个字母不确定，最后为database的数据库：&#39;m_database&#39;; 获取以database结尾的数据库：&#39;%database&#39;; ## 示例代码 show databases like &#39;my%&#39;; 显示数据库创建语句基本语法： show create database 数据库名字 ## 示例代码 show create database mydatabase; 选择数据库 为什么要选择数据库？因为数据是存储到数据表，表存在数据库下。如果要操作数据，那么必须进入到对应的数据库才行 基本语法： use 数据库名字; ## 示例代码 use mydatabase; 修改数据库 修改数据库字符集（库选项）：字符集和校对集。在5.5之前是可以通过rename命令进行修改数据库名字，但是之后的版本是不可以的。 基本语法： alter database 数据库名字 charset = 字符集; ## 示例代码 alter database mydatabase charset gbk; 删除数据库基本语法： drop database 数据库名字 ## 示例代码 drop database mydatabase; show databases; 删除虽简单，但是切记要做好安全操作：确保里面数据没有问题。 删除数据库之后，对应的存储数据的文件也会被删除。 表操作创建数据表 普通创建表基本语法： create table 表名(字段名 字段类型[字段属性],...) [表选项]; - 表选项：与数据库选项类似。 - engine：存储引擎，MySQL提供的具体存储数据的方式，默认有一个innodb（5.5以前默认是myisam） - charse：字符集，只对当前自己表有效（级别比数据库高） - collate：校对集 ## 示例代码 # 创建数据表 use mydatabase2; create table class ( name varchar(10) ); # 创建数据表 create table mydatabase2.class2 ( name varchar(10) ); # 使用表选项 create table mydatabase2.student ( name varchar(10) ) charset utf8; 复制已有表结构从已经存在的表复制一份（只复制结构，如果表中有数据不复制）基本语法： create table 表明 like 表名; //只要使用数据库.表名，就可以在任何数据库下访问其他数据库的表名 ## 示例代码 # 在test数据库下创建一个与student一样的表 use test; create table student like mydatabase2.student; show tables; 显示数据表 显示所有表基本语法： show tables; 匹配显示表基本语法： show tables like &#39;匹配模式&#39; 显示表结构本质含义：显示表中所包含的字段信息（名字，类型，属性等） describe 表名 desc 表名 show columns from 表名 ## 示例代码 # 显示表结构 use mydatabase2; describe class; desc student; show columns from student; 显示表创建语句查看数据表创建时的语句：此语句看到的结果已经不是用户之前自己输入的。 基本语法： show create table 表名; MySQL中有多种语句结束符 ;与\\g所表示的效果是一样的，都是字段在上排横着，下面跟对应的数据 \\G字段在左侧竖着，数据在右侧横着 设置表属性表属性指的就是表选项：engine，charset和collate。 基本语法： alter table 表名 表选项 [=] 值; ## 示例代码 alter table mydatabase2.student charset gbk; show create table mydatabase2.student; 注意：如果数据库已经确定了，里面有很多数据了，不要轻易修改表选项（字符集影响不大） 修改表结构 修改表名基本语法： rename table 旧表名 to 新表名; 修改表选项基本语法： alter table 表名 表选项 [=] 新值; 新增字段基本语法： alter table 表名 add [column] 新字段名 列类型 [列属性] [位置first/after 字段名]; 字段位置：字段想要存放的位置。 First：在某某之前（最前面），第一个字段 after 字段名：放在某个具体的字段之后 修改字段名基本语法： alter table 表名 change 旧字段名 新字段名 字段类型 [列属性] [新位置]; 修改字段类型（属性）基本语法： alter table 表名 modify 字段名 新类型 [新属性] [新位置]; 删除字段基本语法： alter table 表名 drop 字段名; ## 示例代码 # 数据库中数据表名字通常有前缀：取数据库的前两个字母加上下划线 rename table mydatabase2.student to my_student; show tables; # 给学生表增加age字段 alter table my_student add column age int; desc my_student; # 增加字段：放在第一个字段 alter table my_student add id int first; # 修改字段名 alter table my_student change age nj int; # 修改字段类型 alter table my_student modify name varchar(20); # 删除字段 alter table my_student drop nj; 删除表结构基本语法： drop table 表名[,表名2]...; //可以同时删除多个数据表 ## 示例代码 # 删除表名 drop table class; show tables; drop table class2,my_student; 数据操作插入操作本质含义：将数据以SQL的形式存储到指定的数据表（字段）里面 基本语法： insert into 表名 [(字段列表)] values (对应字段列表); # 插入数据到数据表 create table my_teacher ( name varchar(10), age int ); insert into my_teacher (name, age) values (&#39;Jaca&#39;, 30); insert into my_teacher (age, name) values (40, &#39;Tom&#39;); insert into my_teacher (name) values (&#39;Li&#39;); insert into my_teacher values (&#39;Zhang&#39;,22); 查询操作 查询表中全部数据基本语法： select * from 表名; //*表示匹配所有的字段 查询表中部分字段基本语法： select 字段列表 from 表名; //字段列表使用逗号隔开 简单条件查询数据基本语法： select 字段列表/* from 表名 where 字段名=值; # 获取所有数据 select * from my_teacher; # 获取指定字段数据 select name from my_teacher; # 获取年龄为30岁的人的名字 select name from my_teacher where age=30; 删除操作基本语法： delete from 表名 [where 条件]; //如果没有where条件：意味着系统会自动删除该表所有数据 ## 示例代码 # 删除年龄为30岁的人 delete from my_teacher where age = 30; 更新操作更新：将数据进行修改（通常是修改部分字段数据） 基本语法： update 表名 set 字段名=新值 [where 条件]; //如果没有where条件，那么所有的表中对应的那个字段都会被修改成同一值 ## 示例代码 # 更新年龄 update my_teacher set age=28 where name=&#39;Li&#39;; 字符集字符编码概念 字符（character）是各种文字和符号的总称，包括各国家文字、标点符号、图形符号、数据等。字符编码（character code）是计算机针对各种符号，在计算机中的一种二进制存储代号。 字符集概念 字符集（character set）是多个字符的集合，字符集种类较多，每个字符集包含的字符个数不同。 常见字符集名称：ASCII字符集，GB2312字符集，BIG5字符集，GB18030字符集，Unicode字符集等。计算机要准确的处理各种字符集文字，需要进行字符集编码，以便计算机能够识别和存储各种文字。中文文字数目大，而且还分为简体中文和繁体中文两种不同书写规则的文字，而计算机最初是按英文单字节字符设计的，因此，对中文字符进行编码，是中文信息交流的技术基础。 设置客户端所有字符集快捷方式： set names 字符集; # 查看系统保存的三种关系处理字符集 show variables like &#39;character_set%&#39;; 列类型整数类型tinyint 迷你整型：系统采用一个字节来保存整型，一个字节=8位，最大能表示的数值的0-255 smallint 小整型：系统采用两个字节来保存的整形：能表示0-65535之间 mediumint 中整型：系统采用三个字节保存数据 int 整型（标准整型）：采用四个字节保存数据 bigint 大整型：采用八个字节来保存数据 -- 示例代码 # 创建数据表 create table my_int ( int_1 tinyint, int_2 smallint, int_3 mediumint, int_4 int, int_5 bigint ); # 插入数据 insert into my_int values (10,10000,100000,1000000,1000000000); # 插入错误数据（超出对应的数据范围） insert into my_int values (255,255,255,255,255); # 上面的错误原因 insert into my_int values (-128,255,255,255,255); insert into my_int values (127,255,255,255,255); 无符号表示设定 无符号，表示存储的数据在当前字段中，没有负数（只有正数，区间为0-255） 基本语法：在类型之后加上一个unsigned # 无符号表示设定 alter table my_int add int_6 tinyint unsigned first; insert into my_int values (255,100,255,255,255,255); insert into my_int values (-100,100,255,255,255,255); 显示长度 显示长度：指数据（整型）在数据显示的时候，到底可以显示多长位。如tinyint(3),表示最长可以显示3位，显示长度只是代表了数据是否可以达到指定的长度，但是不会自动满足到指定长度：如果想要数据显示的时候，保持最高位（显示长度），那么还需要给字段增加一个zerofill属性才可以。同时显示长度可以自己设定，超出长度（但是不超出范围）不会影响，只会对不够长度的进行补充（显示长度）。 -- 示例代码 # 显示长度 alter table my_int add int_7 tinyint zerofill first; insert into my_int values (1,1,1,1,1,1,1); alter table my_int add int_8 tinyint(2) zerofill first; insert into my_int values (100,1,1,1,1,1,1,1); insert into my_int values (1,1,1,1,1,1,1,1); 小数类型 专门用来存储小数的。在MySQL中将小数类型又分为两类：浮点型和定点型。 浮点型 浮点型又称之为精度类型，是一种有可能丢失精度的数据类型，数据有可能不那么准确（尤其是在超出范围的时候）。浮点型之所以能够存储较大的数值（不精确），原因就是利用存储数据的位来存储指数。 float float又称之为单精度类型，系统提供4个字节用来存储数据，但是能表示的数据范围比整型大得多，大概是10^38。只能保证大概7个左右的精度（如果数据在7位数以内，那么基本是准确的，但是如果超过7位数，那么就是不准确的）。 基本语法float：表示不指定小数位的浮点数float(M,D)：表示一共存储M个有效数字，其中小数部分占D位float(10,2)：整数部分为8位，小数部分为2位 -- 示例代码 # 创建表 create table my_float( f1 float, f2 float(10,2) ); # 插入数据 insert into my_float values (123.123,123456789.90); insert into my_float values (123.1234567,123456789.00); insert into my_float values (123.1234567,99999999.99); # 用户不能插入数据直接超过指定的整数部分长度，但是如果是系统自动进位导致的，系统可以承担 insert into my_float values (123.123,10e5); # 浮点数可以采用科学计数法来存储数据 浮点数的应用：通常是用来保存一些数量特别大的，大到可以不用那么精确的数据。 double double又称之为双精度，系统用8个字节来存储数据，表示的范围更大，10^308次方，但是精度也只有15位左右。 定点数 定点数：能够保证数据精确的小数（小数部分可能不精确，超出长度会四舍五入），整数部分一定精确。 decimal decimal定点数：系统自动根据存储的数据来分配存储空间，每大概9个数就会分配四个字节进行存储，同时小数和整数部分是分开的。 基本语法：decimal(M,D)：M表示在那个长度，最大值不能超过65，D表示小数部分长度，最长不能超过30。 -- 示例代码 # 创建表 create table my_decimal( f1 float(10,2), f2 decimal(10,2) ); # 插入数据 insert into my_decimal values (12345678.90,12345678.90); insert into my_decimal values (99999999.99,99999999.99); insert into my_decimal values (99999999.99,99999999.999); # 定点数如果整数部分进位超出长度也会报错 定点数的应用：如果涉及到钱的时候有可能使用定点数。 时间日期型date 日期类型：系统使用三个字节来存储数据，对应的格式位YYYY-mm-dd，能表示的范围是从1000-01-01到9999-12-12，初始值位0000-00-00 time 时间类型：能够表示某个指定的时间，但是系统同样是提供三个字节来存储，对应的格式为HH:ii:ss，但是MySQL中time类型能够表示时间范围要大得多，能表示从-838:59:59-838:59:59，在MySQL中具体的用处是用来描述时间段。 datetime 日期时间类型：就是将前面的date和time合并起来，表示的时间，使用8个字节存储数据，格式为YYYY-mm-dd HH:ii:ss，能表示的区间1000-01-01 00:00:00到9999-12-12 23:59:59，其可以为0值：0000-00-00 00:00:00。 timestamp 时间戳类型：MySQL中的时间戳只是表示从格林威治事件开始，但是其格式依然是YYYY-mm-dd HH:ii:ss。 year 年类型：占用一个字节来保存，能表示1900-2188年，但是year有两种数据插入方式：0-99和四位数的具体年。 -- 示例代码 # 创建表 create table my_date( d1 date, d2 time, d3 datetime, d4 timestamp, d5 year ); # 插入数据 insert into my_date values (&#39;1900-01-01&#39;,&#39;12:12:12&#39;,&#39;1900-01-01 12:12:12&#39;,&#39;1999-01-01 12:12:12&#39;,69); # year的特殊性：可以采用两位数的数据插入，也可以四位数的年份插入 insert into my_date values (&#39;1900-01-01&#39;,&#39;12:12:12&#39;,&#39;1900-01-01 12:12:12&#39;,&#39;1999-01-01 12:12:12&#39;,2020); # year进行两位数插入的时候，有一个区间划分，零界点为69和70，当输入69以下，那么系统时间为20+数字，如果是70以上。那么系统时间为19+数字 insert into my_date values (&#39;1900-01-01&#39;,&#39;12:12:12&#39;,&#39;1900-01-01 12:12:12&#39;,&#39;1999-01-01 12:12:12&#39;,70); # timestamp update my_date set d1=&#39;2000-01-01&#39; where d5=2069; # time类型的特殊性，本质是用来表示时间区间，能表示的范围比较大 insert into my_date values (&#39;1900-01-01&#39;,&#39;512:12:12&#39;,&#39;1900-01-01 12:12:12&#39;,&#39;1999-01-01 12:12:12&#39;,70); # 在进行时间类型录入的时候（time）还可以使用一个简单的日期代替时间，在时间格式之前加一个空格，然后指定一个数字（可以是负数），系统会自动将该数字转换成天数*24小时，再加上后面的时间 insert into my_date values (&#39;1900-01-01&#39;,&#39;5 12:12:12&#39;,&#39;1900-01-01 12:12:12&#39;,&#39;1999-01-01 12:12:12&#39;,70); mysql&gt; desc my_date; +-------+-----------+------+-----+-------------------+-----------------------------+ | Field | Type | Null | Key | Default | Extra | +-------+-----------+------+-----+-------------------+-----------------------------+ | d1 | date | YES | | NULL | | | d2 | time | YES | | NULL | | | d3 | datetime | YES | | NULL | | | d4 | timestamp | NO | | CURRENT_TIMESTAMP | on update CURRENT_TIMESTAMP | | d5 | year(4) | YES | | NULL | | +-------+-----------+------+-----+-------------------+-----------------------------+ 5 rows in set (0.00 sec) ## d4一行 时间戳类型不能为空，有默认值，为当前时间戳对应的时间，当数据被更新的时候，这个字段更新为当前最新的时间。 字符串型char 定长字符：指定长度之后，系统一定会分配指定的空间用于存储数据。 基本语法：char(L):L代表字符数（中文与英文字母一样），L长度为0到255 varchar 变长字符：指定长度之后，系统会根据实际存储的数据来计算长度，分配合适的长度（数据没有超出长度） 基本语法：varchar(L):L代表字符数，L的长度理论值为0到65535 因为varchar要记录数据长度（系统根据数据长度自动分配空间），所以每个varchar数据产生后，系统都会在数据后面增加1-2个字节的额外开销，是用来保存数据所占用的空间长度，如果数据本身小于127个字节，额外开销一个字节；如果大于127个，就开销两个字节。 char和varchar数据存储对比（utf8，一个字符都会占用3个字节） 存储数据 char(2) varchar(2) char所占字节 varchar所占字节 A A A 2x3=6 1x3+1=4 AB AB AB 2x3=6 2x3+1=7 char和varchar的区别 char一定会使用指定的空间，varchar是根据数据来定空间 char的数据查询效率比varchar高，varchar是需要通过后面的记录数来计算 如果确定数据一定是占指定长度，那么使用char类型如果不确定数据到底有多少，那么使用varchar类型如果数据长度超过255个字符，不论是否固定长度，都会使用text，不再使用char和varchar。 text 文本类型：本质上MySQL提供了两种文本类型text：存储普通的字符文本blob：存储二进制文本（图片，文件），一般都不会使用blob来存储文件本身，通常是使用一个链接来指向对应的文件本身。 text系统中提供的四种text tinytext:系统使用一个字节来保存，实际能够存储的数据为2^8+1 text:使用两个字节保存，实际存储：2^16+2 mediumtext:使用三个字节保存，实际存储：2^24+3 longtext:使用四个字节保存，实际存储为2^32+4 注意： 在选择对应的存储文本的时候，不用刻意去选择text类型，系统会自动根据存储的数据长度来选择合适的文本类型。 在选择字符存储的时候，如果数据超过255个字符，那么一定选择text存储 enum 枚举类型：在数据插入之前，先设定几个项，这几个项就是可能最终出现的数据结果。 如果确定某个字段的数据只有那么几个值：如性别，男，女，保密，系统就可以在设定字段的时候规定当前字段只能存放固定的几个值，使用枚举。 基本语法：enum(数据值1，数据值2,…)系统提供了1到2个字节来存储枚举数据：通过计算enum列举的具体值来选择实际的存储空间，如果数据值列表在255个以内，那么一个字节就够；如果超过255但是小于65535，那么系统采用两个字节保存。 枚举的意义： 规范数据本身，限定只能插入规定的数据项 节省存储空间 -- 示例代码 # 创建表 create table my_enum( gender enum(&#39;男&#39;,&#39;女&#39;,&#39;保密&#39;) ); desc my_enum; # 插入数据 insert into my_enum values (&#39;男&#39;); insert into my_enum values (&#39;女&#39;); insert into my_enum values (&#39;男&#39;); # enum字段存储的结果是数值 # 将字段按照数值输出 select gender + 0 from my_enum; insert into my_enum values (3); set 集合：是一种将多个数据选项可以同时保存的数据类型，本质是将指定的项按照对应的二进制位来进行控制：1表示该选项被选中，0表示该选项没有被选中 基本语法：set(‘值1’,’值2’,’值3’,…) 系统为set提供了多个字节进行保存，但是系统会自动计算来选择具体的存储单元。 1个字节：set只能由8个选项 2个字节：set只能有16个选项 3个字节：set只能有24个选项 8个字节：set可以表示64个选项 set和enum一样，最终存储到数据字段中的依然是数字而不是真实的字符串。 # 创建表 create table my_set( hobby set(&#39;篮球&#39;,&#39;足球&#39;,&#39;羽毛球&#39;,&#39;乒乓球&#39;,&#39;网球&#39;,&#39;橄榄球&#39;,&#39;冰球&#39;,&#39;跳高&#39;) ); # 插入数据 insert into my_set values (&#39;篮球,乒乓球,足球&#39;); insert into my_set values (&#39;橄榄球,跳高,篮球,乒乓球,足球&#39;); # 排序顺序为创建表时的顺序 # 查看数据:以数值方式查看 select hobby + 0 from my_set; insert into my_set values (255); set集合的意义： 规范数据 节省存储空间 enum:单选框 set:复选框 MySQL记录长度在MySQL中，有一项规定，MySQL的记录长度（record==行row）总长度不能超过65535个字节。varchar能够存储的理论值为65535个字符，字符在不同的字符集下不可能占用多个字节。 # 创建表(证明varchar在MySQL中能够达到的理论值 utf8和gbk) create table my_varchar( name varchar(65535) )charset utf8; # 计算在utf8和gbk下对应的varchar能够存储的长度 # utf8 65535/3=21845 如果采用varchar存储，需要两个额外的字节来保存长度 # gbk 65535/2=32767 | 1 如果采用varchar存储，需要额外的2个字节 create table my_utf( name varchar(21844) )charset utf8; create table my_gbk( name varchar(32766) )charset gbk; 列属性 列属性又称之为字段属性，在MySQL中一共有6个属性：null，默认值，列描述，主键，唯一键，自动增长。 null属性 NULL属性：代表字段为空 +-------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+-------------+------+-----+---------+-------+ | name | varchar(10) | YES | | NULL | | | age | int(11) | YES | | NULL | | +-------+-------------+------+-----+---------+-------+ 2 rows in set (0.00 sec) 如果对应的值为YES表示该字段可以为NULL。 注意 在设计表的时候，尽量不要让数据为空。 MySQL的记录长度为65535个字节，如果一个表中有字段允许为NULL，那么系统就会设计保留一个字节来存储NULL，最终有效存储长度为65534个字节。 默认值 default：默认值，当字段被设计的时候，如果允许默认条件下，用户不进行数据的插入，那么就可以使用事先准备好的数据来填充，通常填充的是NULL。 # 创建表 create table my_default( name varchar(10) NOT NULL, -- 不能为空 age int default 18 -- 表示，如果当前字段在进行数据插入的时候没有提供，那么就使用18 ); # 测试插入数据 insert into my_default(name) values(&#39;Tom&#39;); # default关键字的另外一层使用：显示的告知字段使用默认值，在进行数据插入的时候，对字段值直接使用default insert into my_default values (&#39;Jack&#39;,default); 列描述 列描述：comment，是专门用于开发人员进行维护的一个注释说明。 基本语法：comment ‘字段描述’; # 创建表，增加字段描述 create table my_comment( name varchar(10) not null comment &#39;当前是用户名，不能为空。&#39;, pass varchar(50) not null comment &#39;密码不能为空&#39; ); # 查看效果(查看表创建语句) show create table my_comment; 主键 顾名思义，主要的键，primarykey，在一张表中，有且只有一个字段，里面的值具有唯一性。 创建主键随表主键系统提供了两种增加主键的方式 方案1：直接在需要当作主键的字段之后，增加primarykey属性来确定主键 方案2：在所有字段之后增加primarykey选项：primarykey(字段信息) 表后增加基本语法：alter table 表名 add primary key(字段); 查看主键方案1：查看表结构。desc 表名方案2：查看表的创建语句。show create table 表名 删除主键基本语法：alter table 表名 drop primary key # 随表主键 # 方案1 # 创建表，在字段后增加主键属性 create table my_pri1( username varchar(10) primary key ); # 方案2 create table my_pri2( username varchar(10), primary key(username) ); # 表后增加 create table my_pri3( username varchar(10) ); # 增加主键 alter table my_pri3 add primary key(username); # 删除主键 alter table my_pri3 drop primary key; 复合主键案例：有一张学生选修课表，一个学生可以选修多个选修课，一个选修课也可以由多个学生来选，但是一个学生在一个选修课中只有一个成绩。 # 创建表 create table my_score( student_no char(10), course_no char(10), score tinyint not null, primary key (student_no,course_no) ); 主键约束主键一旦增加，那么对对应的字段有数据要求。 当前字段对应的数据不能为空 当前字段对应的数据不能有任何重复 -- 以上面的my_score表为例 # 创建表 create table my_score( student_no char(10), course_no char(10), score tinyint not null, primary key (student_no,course_no) ); # 主键约束 insert into my_score values (&#39;000000001&#39;,&#39;course001&#39;,&#39;100&#39;); insert into my_score values (&#39;000000002&#39;,&#39;course001&#39;,&#39;90&#39;); insert into my_score values (&#39;000000001&#39;,&#39;course002&#39;,&#39;95&#39;); insert into my_score values (&#39;000000002&#39;,&#39;course001&#39;,&#39;95&#39;); 主键分类 主键分类采用的是主键所对应的字段的业务意义分类。业务主键：主键所在的字段具有业务意义（学生ID，课程ID）逻辑主键：自然增长的整型（应用广泛） 自动增长 自动增长：auto_increment，当给定某个字段该属性之后，该列的数据在没有提供确定数据的时候，系统会根据之前已经存在的数据进行自动增加后，填充数据。 通常自动增长用于逻辑主键。 原理自动增长的原理： 在系统中有维护一组数据，用来保存当前使用了自动增长属性的字段，记住当前对应的数据值，再给定一个指定的步长。 当用户进行数据插入的时候，如果没有给定值，系统在原始值上再加上步长变成新的数据。 自动增长的触发，给定属性的字段没有提供值。 自动只适用于数值。 使用自动增长基本语法：在字段之后增加一个属性auto_increment # 创建一个带自动增长的表 create table my_auto( id int primary key auto_increment, name varchar(10) not null comment &#39;用户名&#39;, pass varchar(50) not null comment &#39;密码&#39; ); # 插入数据，触发自动增长，不能给定具体值 insert into my_auto values (null,&#39;Tom&#39;,&#39;123456&#39;); 修改自动增长 查看自增长：自增长一旦触发使用之后，会自动的在表选项中增加一个选项（一张表最多只能拥有一个自增长）。 -- 实例 +---------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ | Table | Create Table | +---------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ | my_auto | CREATE TABLE `my_auto` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(10) COLLATE utf8_unicode_ci NOT NULL COMMENT &#39;用户名&#39;, `pass` varchar(50) COLLATE utf8_unicode_ci NOT NULL COMMENT &#39;密码&#39;, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci | +---------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ 1 row in set (0.00 sec) 表选项可以通过修改表结构来实现。 alter table 表名 auto_increment = 值; 删除自动增长删除自增长，就是在字段属性之后不再保留auto_increment，当用户修改自增长所在字段时，如果没有看到auto_increment属性，系统送会自动清除该自增长。 -- 实例代码 alter table my_auto modify id int; # 切记不要再次增加primary key 初始设置 在系统中有一组变量维护自增长的初始值和步长 show variables like &#39;auto_increment%&#39;; +--------------------------+-------+ | Variable_name | Value | +--------------------------+-------+ | auto_increment_increment | 1 | | auto_increment_offset | 1 | +--------------------------+-------+ 2 rows in set (0.00 sec) -- auto_increment_increment 步长 -- auto_increment_offset 初始值 细节问题 一张表只有一个自增长，自增长会上升到表选项中 如果数据插入中没有触发自增长（给定了数据），那么自增长不会表现 自增长在修改的时候，值可以较大，但是不能比当前已有的自增长的字段值小 唯一键 唯一键：unique key，用来保证对应的字段中的数据唯一的。主键也可以用来保证字段数据唯一性，但是一张表只有一个主键 唯一键在一张表中可以有多个 唯一键允许字段数据为NULL，NULL可以有多个（NULL不参与比较） 创建唯一键创建唯一键与创建主键非常类似。 直接在表字段之后增加唯一键标识符：unique[key] 在所有的字段之后使用unique key(字段列表) 在创建完表之后也可以增加唯一键。alter table 表名 add unique key(字段列表); # 创建表，唯一键 create table my_unique1( id int primary key auto_increment, usernmae varchar(10) unique ); create table my_unique2( id int primary key auto_increment, usernmae varchar(10), unique key (usernmae) ); create table my_unique3( id int primary key auto_increment, usernmae varchar(10) ); alter table my_unique3 add unique key (usernmae); 查看唯一键 唯一键是属性，可以通过查看表结构来实现。 mysql&gt; desc my_unique1; +----------+-------------+------+-----+---------+----------------+ | Field | Type | Null | Key | Default | Extra | +----------+-------------+------+-----+---------+----------------+ | id | int(11) | NO | PRI | NULL | auto_increment | | usernmae | varchar(10) | YES | UNI | NULL | | +----------+-------------+------+-----+---------+----------------+ 2 rows in set (0.00 sec) 唯一键的效果：在不为空的情况下不允许重复 -- 实例 # 唯一键效果 insert into my_unique1 values (null,default); insert into my_unique1 values (null,default); insert into my_unique1 values (null,default); insert into my_unique1 values (null,&#39;army&#39;); insert into my_unique1 values (null,&#39;army&#39;); # 非空不允许重复 在查看表创建语句的时候，会看到与主键不同的一点，多出一个“名字” +------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ | Table | Create Table | +------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ | my_unique1 | CREATE TABLE `my_unique1` ( `id` int(11) NOT NULL AUTO_INCREMENT, `usernmae` varchar(10) COLLATE utf8_unicode_ci DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `usernmae` (`usernmae`) ) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci | +------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ 1 row in set (0.00 sec) -- UNIQUE KEY `usernmae` (`usernmae`) 中的username是系统为唯一键自动创建一个名字（默认是字段名） 删除唯一键一个表中允许存在多个唯一键，删除的基本语法与主键不一样。 删除唯一键的基本语法： alter table 表名 drop index 唯一键名字（上面UNIQUE KEY `usernmae` (`usernmae`) 的username） index关键字：索引，唯一键是索引的一种（提升查询效率） 修改唯一键：先删除后增加 复合唯一键 唯一键与主键一样可以使用多个字段来共同保证唯一性。一般主键都是单一字段（逻辑主键），而其他需要唯一性的内容都是由唯一键来处理。 表关系 表关系：表与表之间（实体）有什么样的关系，每种关系应该如何设计表结构。 一对一 一对一：一张表中的一条记录与另外一张表中最多有一条明确的关系，通常，此设计方案保证两张表中使用同样的主键即可。 示例 学生表 学生ID（主键） 姓名 年龄 性别 籍贯 婚否 住址 表的使用过程中，常用的信息会经常去查询，而不常用的信息会偶尔才会用到 解决方案：将两张表拆分，常见放一张表，不常见的放一张表。 常见表 学生ID（主键） 姓名 年龄 性别 不常用表 学生ID（主键） 籍贯 婚否 住址 一对多 一对多，通常也叫做多对一的关系。通常一对多的关系设计的方案，在“多”关系的表中去维护一个字段，这个字段是“一”关系的主键。 实例 母亲表 母亲ID（主键） 姓名 年龄 身高 M1 M2 孩子表 孩子ID（主键） 姓名 年龄 身高 母亲ID K1 M1 K2 M2 多对多 多对多，一张表中的一条记录在另外一张表中可以匹配到多条记录，反过来也一样。多对多的关系如果按照多对一的关系维护，就会出现一个字段中有多个其他表的主键，在访问的时候就会带来不便。既然通过两张表自己增加字段解决不了问题，那么就通过第三张表来解决 实例 师生关系 一个老师交过多个班级的学生 一个学生听过多个老师讲的课 解决方案： 多对多的解决方案：增加一个中间表，让中间表与对应的其他表形成两个多对一的关系，多对一的解决方案是在“多”表中增加“一”表对应的主键字段。 高级数据操作新增数据多数据插入 只要写一次insert指令，但是可以直接插入多条记录。 基本语法： insert into 表名 [(字段列表)] values(值列表),(值列表)...; -- 示例代码 # 创建表(多数据插入) create table my_insert( name varchar(10) ); # 多数据插入 insert into my_insert values (&#39;张三&#39;),(&#39;李四&#39;),(&#39;王五&#39;); 主键冲突 主键冲突：在有的表中，使用的是业务主键（字段有业务含义），但是往往在数据插入的时候，又不确定数据表中是否已经存在对应的主键。 主键冲突的解决方案： 主键冲突更新：类似插入数据语法，如果插入的过程中主键冲突，那么采用更新方法。 insert into 表名 [(字段列表)] values (值列表) on duplicate key update 字段 = 新值; 主键冲突替换：当主键冲突之后，干掉原来的数据，重新插入进去。 replace into 表名 values [(字段列表)](值列表); # 创建表（主键冲突） create table my_student( stu_id varchar(10) primary key comment &#39;主键，学生ID&#39;, stu_name varchar(10) not null comment &#39;学生姓名&#39; ); # 插入数据 insert into my_student values (&#39;stu0001&#39;, &#39;张三&#39;), (&#39;stu0002&#39;, &#39;张四&#39;), (&#39;stu0003&#39;, &#39;张五&#39;), (&#39;stu0004&#39;, &#39;张六&#39;); insert into my_student values (&#39;stu0004&#39;,&#39;小明&#39;); # 结果无法插入 # 冲突更新 insert into my_student values (&#39;stu0004&#39;,&#39;小明&#39;) on duplicate key update stu_name =&#39;小明&#39;; replace into my_student values (&#39;stu0001&#39;,&#39;小张&#39;); 蠕虫复制 蠕虫复制：一分为二，成倍的增加。从已有的数据中获取数据，并且将获取到的数据插入到数据表中。 基本语法： insert into 表名 [(字段列表)] select */字段列表 from 表; # 创建表（蠕虫复制） create table my_simple( name char(1) not null ); # 插入数据 insert into my_simple values (&#39;a&#39;),(&#39;b&#39;),(&#39;c&#39;),(&#39;d&#39;); # 蠕虫复制 insert into my_simple (name) select name from my_simple; 注意 蠕虫复制的确通常是重复数据，没有太大也无意义，可以在短期内快速增加表的数据量，从而可以测试表的压力，还可以通过大量数据来测试表的效率（索引） 蠕虫复制虽好，但是要注意主键冲突 更新数据 在更新数据的时候，特别注意，通常一定是跟随条件更新。 update 表名 set 字段名 = 新值 where 判断条件; 如果没有条件，是全表更新数据。但是可以使用limit来显示更新的数量 update 表名 set 字段名 = 新值 [where 判断条件] limit 数量; -- 示例代码 # 更新数据 update my_simple set name=&#39;e&#39; where name=&#39;a&#39; limit 2; 删除数据 删除数据的时候尽量不要全部删除，应该使用where进行判定。 删除数据的时候可以使用limit来限制要删除的具体数量 delete删除数据的时候无法重置auto_increment MySQL有一个能够重置表选项中的自增长的语法。 truncate 表名; -- 示例代码 select * from my_auto; # 删除整个表的数据 delete from my_auto; # 插入数据 insert into my_auto values (null,&#39;ceshi&#39;,&#39;123456&#39;); # auto_increment是无法进行重置的 # 重置表选项中的自增长 truncate my_auto; # 插入数据 insert into my_auto values (null,&#39;ceshi&#39;,&#39;123456&#39;); # auto_increment是无法进行重置的 查询数据 完整的查询指令：select select选项 字段列表 from 数据源 where 条件 group by 分组 having 条件 order by 排序 limit 限制; select选项：系统该如何对待查询得到的数据 all：默认的，表示保存所有的记录 distinct：去重，去除重复的记录，只保留一条（所有的字段都相同） # select选项 select all * from my_simple; -- select * select distinct * from my_simple; 字段列表：有的时候需要从多张表获取数据，在获取数据的时候，可能存在不同表中有同名的字段，需要将同名的字段命名成不同名的（别名）。基本语法如下： 字段名 [as] 别名 # 字段别名 select distinct name as name1,name name2 from my_simple; from数据源 from是为前面的查询提供数据，数据源只要是一个符合二维表结构的数据即可。 单表数据from 表名 多表数据从多张表中获取数据，基本语法：from 表1，表2... select * from my_int,my_set; 上面的结果为： +-------+-------+-------+-------+-------+--------+---------+------------+------------------------------------------------------------------+ | int_8 | int_7 | int_6 | int_1 | int_2 | int_3 | int_4 | int_5 | hobby | +-------+-------+-------+-------+-------+--------+---------+------------+------------------------------------------------------------------+ | NULL | NULL | NULL | 10 | 10000 | 100000 | 1000000 | 1000000000 | 篮球,足球,乒乓球 | | NULL | NULL | NULL | 10 | 10000 | 100000 | 1000000 | 1000000000 | 篮球,足球,乒乓球,橄榄球,跳高 | | NULL | NULL | NULL | 10 | 10000 | 100000 | 1000000 | 1000000000 | 篮球,足球,羽毛球,乒乓球,网球,橄榄球,冰球,跳高 | | NULL | NULL | NULL | -128 | 255 | 255 | 255 | 255 | 篮球,足球,乒乓球 | | NULL | NULL | NULL | -128 | 255 | 255 | 255 | 255 | 篮球,足球,乒乓球,橄榄球,跳高 | | NULL | NULL | NULL | -128 | 255 | 255 | 255 | 255 | 篮球,足球,羽毛球,乒乓球,网球,橄榄球,冰球,跳高 | | NULL | NULL | NULL | 127 | 255 | 255 | 255 | 255 | 篮球,足球,乒乓球 | | NULL | NULL | NULL | 127 | 255 | 255 | 255 | 255 | 篮球,足球,乒乓球,橄榄球,跳高 | | NULL | NULL | NULL | 127 | 255 | 255 | 255 | 255 | 篮球,足球,羽毛球,乒乓球,网球,橄榄球,冰球,跳高 | | NULL | NULL | 255 | 100 | 255 | 255 | 255 | 255 | 篮球,足球,乒乓球 | | NULL | NULL | 255 | 100 | 255 | 255 | 255 | 255 | 篮球,足球,乒乓球,橄榄球,跳高 | | NULL | NULL | 255 | 100 | 255 | 255 | 255 | 255 | 篮球,足球,羽毛球,乒乓球,网球,橄榄球,冰球,跳高 | | NULL | 001 | 1 | 1 | 1 | 1 | 1 | 1 | 篮球,足球,乒乓球 | | NULL | 001 | 1 | 1 | 1 | 1 | 1 | 1 | 篮球,足球,乒乓球,橄榄球,跳高 | | NULL | 001 | 1 | 1 | 1 | 1 | 1 | 1 | 篮球,足球,羽毛球,乒乓球,网球,橄榄球,冰球,跳高 | | 100 | 001 | 1 | 1 | 1 | 1 | 1 | 1 | 篮球,足球,乒乓球 | | 100 | 001 | 1 | 1 | 1 | 1 | 1 | 1 | 篮球,足球,乒乓球,橄榄球,跳高 | | 100 | 001 | 1 | 1 | 1 | 1 | 1 | 1 | 篮球,足球,羽毛球,乒乓球,网球,橄榄球,冰球,跳高 | | 01 | 001 | 1 | 1 | 1 | 1 | 1 | 1 | 篮球,足球,乒乓球 | | 01 | 001 | 1 | 1 | 1 | 1 | 1 | 1 | 篮球,足球,乒乓球,橄榄球,跳高 | | 01 | 001 | 1 | 1 | 1 | 1 | 1 | 1 | 篮球,足球,羽毛球,乒乓球,网球,橄榄球,冰球,跳高 | +-------+-------+-------+-------+-------+--------+---------+------------+------------------------------------------------------------------+ 21 rows in set (0.00 sec) 结果：两张表的记录数相乘，字段数拼接。本质：从第一张表去除一条记录。去拼凑第二张表中的所有记录，保留所有记录。在数学上有一个专业的说法：笛卡尔积，这个结果除了给数据库造成压力，没有其他意义。应该避免出现笛卡尔积。 动态数据from后面跟的数据不是一个实体表，而是一个从表中查询出来得到的二维结果表（子查询）。 基本语法：from (select 字段列表 from 表) as 别名; # 动态数据 select * from (select int_1,int_8 from my_int) as int_my; where字句 where子句：用来从数据表获取数据的时候，然后进行条件筛选。数据获取原理：针对表去对应的磁盘出获取所有的记录（一条条），where的作用就是在拿到一条结果就开始进行判断，判断是否符合条件，如果符合就保存下来，如过上不符合直接舍弃（不放到内存中）where是通过运算符进行结果比较来判断数据。 group by 子句 group by表示分组的含义，根据指定的字段，将数据进行分组，分组的目标是为了统计。 分组统计基本语法：group by 字段名 # 分组统计 alter table my_student add class_id int; # 插入数据处理 # 进行分组 select * from my_student group by class_id; -- 根据班级id进行分组 group by 是为了分组后进行数据统计，如果只是想看数据显示，那么group by没有什么含义，group by将数据按照指定的字段分组之后，只会保留每组的第一条记录。 利用一些统计函数： count()：统计每组中的数量，如果统计的目标是字段，那么不统计为空NULL字段，如果为*，那么代表统计记录。 avg()：求平均值 sum()：求和 max()：求最大值 min()：求最小值 group_concat()：为了将分组中指定的字段进行合并（字符串拼接） # 使用聚合函数 alter table my_student add stu_age tinyint unsigned; alter table my_student add stu_height tinyint unsigned; # 自行处理插入数据 # 按照班级统计每班人数，最大年龄，最矮身高，平均年龄 select class_id,count(*),max(stu_age),min(stu_height),avg(stu_age) from my_student group by class_id; select class_id,group_concat(stu_name),count(*),max(stu_age),min(stu_height),avg(stu_age) from my_student group by class_id; 结果为： +----------+------------------------+----------+--------------+-----------------+--------------+ | class_id | group_concat(stu_name) | count(*) | max(stu_age) | min(stu_height) | avg(stu_age) | +----------+------------------------+----------+--------------+-----------------+--------------+ | 1 | 小张,张四 | 2 | 28 | 165 | 23.0000 | | 2 | 张五,小明 | 2 | 25 | 187 | 23.5000 | +----------+------------------------+----------+--------------+-----------------+--------------+ 2 rows in set (0.00 sec) 多分组 将数据按照某个字段进行分组之后，对已经分组的数据进行再次分组。 基本语法：group by 字段1,字段2; //先按照字段1进行排序，之后将结果在按照字段2进行排序，以此类推 # 多分组 alter table my_student add gender enum(&#39;男&#39;,&#39;女&#39;,&#39;保密&#39;); # 插入数据自行处理 # 进行多分组 select class_id,gender,count(*),group_concat(stu_name) from my_student group by class_id, gender; 上面结果为： +----------+--------+----------+------------------------+ | class_id | gender | count(*) | group_concat(stu_name) | +----------+--------+----------+------------------------+ | 1 | 男 | 1 | 小张 | | 1 | 女 | 2 | 张四,小猪 | | 2 | 男 | 2 | 张五,小狗 | | 2 | 女 | 1 | 小明 | +----------+--------+----------+------------------------+ 4 rows in set (0.00 sec) 分组排序 MySQL中，分钟默认有排序的功能，按照分组字段进行排序，默认是升序。 基本语法：group by 字段 [asc|desc], 字段 [asc|desc] 回溯统计 当分组进行多分组之后，往上统计的过程中，需要进行层层上报，将这种层层上报统计的过程称之为回溯统计，每一次分组向上统计的过程都会产生一次新的统计数据，而且当前数据对应的分组字段为NULL。 基本语法：group by 字段 [asc|desc] with rollup; select class_id,count(*) from my_student group by class_id with rollup; 结果为： +----------+----------+ | class_id | count(*) | +----------+----------+ | 1 | 3 | | 2 | 3 | | NULL | 6 | +----------+----------+ 3 rows in set (0.00 sec) select class_id,gender,count(*) from my_student group by class_id,gender with rollup; 结果为： +----------+--------+----------+ | class_id | gender | count(*) | +----------+--------+----------+ | 1 | 男 | 1 | | 1 | 女 | 2 | | 1 | NULL | 3 | | 2 | 男 | 2 | | 2 | 女 | 1 | | 2 | NULL | 3 | | NULL | NULL | 6 | +----------+--------+----------+ 7 rows in set (0.00 sec) having子句 having的本质和where一样，是用来进行数据条件筛选。 having是在group by子句之后，可以针对分组数据进行统计筛选，但是where不行（having在group by分组之后，可以使用聚合函数或者字段别名，where是从表中取出数据，别名是在数据进入到内存才有的） # having子句 # 插入数据自行处理 # 查询班级人数大于等于4个以上的班级 select class_id,count(*) as number from my_student group by class_id having number &gt;= 4; 结果为： +----------+--------+ | class_id | number | +----------+--------+ | 1 | 4 | +----------+--------+ 1 row in set (0.06 sec) 强调：having是在group by之后，group by 是在where之后，where的时候表示将数据从磁盘拿到内存，where之后的所有操作都是内存操作。 order by 子句 order by排序：根据校对规则对数据进行排序。 基本语法：order by字段 [asc|desc]; //asc升序,默认的 # order by 子句 # 班级学生按照身高排序 select * from my_student order by stu_height asc ; 结果为： +---------+----------+----------+---------+------------+--------+ | stu_id | stu_name | class_id | stu_age | stu_height | gender | +---------+----------+----------+---------+------------+--------+ | stu0002 | 张四 | 1 | 28 | 165 | 女 | | stu0006 | 小狗 | 2 | 18 | 170 | 男 | | stu0005 | 小猪 | 1 | 30 | 173 | 女 | | stu0007 | 小江 | 1 | 25 | 178 | 女 | | stu0001 | 小张 | 1 | 18 | 185 | 男 | | stu0003 | 张五 | 2 | 22 | 187 | 男 | | stu0004 | 小明 | 2 | 25 | 189 | 女 | +---------+----------+----------+---------+------------+--------+ 7 rows in set (0.00 sec) order by 也可以向group by 一样进行多字段排序，先按照第一个字段进行排序，然后再按照第二个字段进行排序。 基本语法：order by 字段1 规则,字段2 规则; 多字段排序： # 按照班级、身高排序 select * from my_student order by class_id desc ,stu_height; 结果为： +---------+----------+----------+---------+------------+--------+ | stu_id | stu_name | class_id | stu_age | stu_height | gender | +---------+----------+----------+---------+------------+--------+ | stu0006 | 小狗 | 2 | 18 | 170 | 男 | | stu0003 | 张五 | 2 | 22 | 187 | 男 | | stu0004 | 小明 | 2 | 25 | 189 | 女 | | stu0002 | 张四 | 1 | 28 | 165 | 女 | | stu0005 | 小猪 | 1 | 30 | 173 | 女 | | stu0007 | 小江 | 1 | 25 | 178 | 女 | | stu0001 | 小张 | 1 | 18 | 185 | 男 | +---------+----------+----------+---------+------------+--------+ 7 rows in set (0.00 sec) limit 子句 limit限制子句：主要是用来限制记录数量获取。 记录数据限制 纯粹的限制获取的数量：从第一条到指定的数量 基本语法：limit 数量; # limit 子句 select * from my_student limit 2; 结果为： +---------+----------+----------+---------+------------+--------+ | stu_id | stu_name | class_id | stu_age | stu_height | gender | +---------+----------+----------+---------+------------+--------+ | stu0001 | 小张 | 1 | 18 | 185 | 男 | | stu0002 | 张四 | 1 | 28 | 165 | 女 | +---------+----------+----------+---------+------------+--------+ 2 rows in set (0.00 sec) limit通常在查询的时候如果限定为一条记录的时候，使用的比较多，有时候获取多条记录并不能解决业务问题，但是会增加服务器的压力。 分页 利用limit来限制获取指定区间的数据。 基本语法：limit offset,length; //offset 偏移量,从哪里开始，length，就是具体 的获取多少条记录` 如：MySQL中记录的数量从0开始，limit 0,2; //表示获取前两条数据 mysql&gt; select * from my_student limit 0,2; +---------+----------+----------+---------+------------+--------+ | stu_id | stu_name | class_id | stu_age | stu_height | gender | +---------+----------+----------+---------+------------+--------+ | stu0001 | 小张 | 1 | 18 | 185 | 男 | | stu0002 | 张四 | 1 | 28 | 165 | 女 | +---------+----------+----------+---------+------------+--------+ 2 rows in set (0.00 sec) mysql&gt; select * from my_student limit 2,2; +---------+----------+----------+---------+------------+--------+ | stu_id | stu_name | class_id | stu_age | stu_height | gender | +---------+----------+----------+---------+------------+--------+ | stu0003 | 张五 | 2 | 22 | 187 | 男 | | stu0004 | 小明 | 2 | 25 | 189 | 女 | +---------+----------+----------+---------+------------+--------+ 2 rows in set (0.00 sec) 注意：limit后面的length表示最多获取对应数量，但是如果数量不够，系统不会强求 聚合函数参考10.4.3节。 count()：统计每组中的数量，如果统计的目标是字段，那么不统计为空NULL字段，如果为*，那么代表统计记录。 avg()：求平均值 sum()：求和 max()：求最大值 min()：求最小值 查询中的运算符算数运算符+ - * / % 基本算数运算：通常不在条件中使用，而是用于结果运算（select 字段中） # 创建表 create table ysf1( int_1 int, int_2 int, int_3 int, int_4 int ); insert into ysf1 values (100,-100,0,default); # 算术运算 select int_1+int_2,int_1-int_2,int_1*int_2,int_1/int_2,int_2/int_3,int_2%2,int_4%5 from ysf1; 结果为： +-------------+-------------+-------------+-------------+-------------+---------+---------+ | int_1+int_2 | int_1-int_2 | int_1*int_2 | int_1/int_2 | int_2/int_3 | int_2%2 | int_4%5 | +-------------+-------------+-------------+-------------+-------------+---------+---------+ | 0 | 200 | -10000 | -1.0000 | NULL | 0 | NULL | +-------------+-------------+-------------+-------------+-------------+---------+---------+ 1 row in set (0.00 sec) 比较运算符&gt; &gt;= &lt; &lt;= = &lt;&gt; 通常是用来在条件中进行限定结果。 =：在MySQL中没有对应==比较符号，就是使用=来进行相等判断 &lt;=&gt;：相等比较 # 比较运算符 select * from my_student where stu_age&gt;=20; 结果为： +---------+----------+----------+---------+------------+--------+ | stu_id | stu_name | class_id | stu_age | stu_height | gender | +---------+----------+----------+---------+------------+--------+ | stu0002 | 张四 | 1 | 28 | 165 | 女 | | stu0003 | 张五 | 2 | 22 | 187 | 男 | | stu0004 | 小明 | 2 | 25 | 189 | 女 | | stu0005 | 小猪 | 1 | 30 | 173 | 女 | | stu0007 | 小江 | 1 | 25 | 178 | 女 | +---------+----------+----------+---------+------------+--------+ 5 rows in set (0.00 sec) 特殊应用：就是在字段中进行比较运算。 # MySQL中没有规定select必须有数据表 select &#39;1&#39; &lt;=&gt; 1,0.02 &lt;=&gt; 0,0.02 &lt;&gt; 0; 结果为： +-----------+------------+-----------+ | &#39;1&#39; &lt;=&gt; 1 | 0.02 &lt;=&gt; 0 | 0.02 &lt;&gt; 0 | +-----------+------------+-----------+ | 1 | 0 | 1 | +-----------+------------+-----------+ 1 row in set (0.00 sec) 在条件判断的时候，还有对应的比较运算符，计算区间。between 条件1 and 条件2。 # 查找年龄区间 select * from my_student where stu_age between 20 and 30; 结果为： +---------+----------+----------+---------+------------+--------+ | stu_id | stu_name | class_id | stu_age | stu_height | gender | +---------+----------+----------+---------+------------+--------+ | stu0002 | 张四 | 1 | 28 | 165 | 女 | | stu0003 | 张五 | 2 | 22 | 187 | 男 | | stu0004 | 小明 | 2 | 25 | 189 | 女 | | stu0005 | 小猪 | 1 | 30 | 173 | 女 | | stu0007 | 小江 | 1 | 25 | 178 | 女 | +---------+----------+----------+---------+------------+--------+ 5 rows in set (0.00 sec) between中条件1必须小于条件2，反过来不可以。 逻辑运算符and or not and：逻辑与 # 逻辑运算符 # 与 select * from my_student where stu_age &gt;= 20 and stu_age &lt;= 30; 结果为： +---------+----------+----------+---------+------------+--------+ | stu_id | stu_name | class_id | stu_age | stu_height | gender | +---------+----------+----------+---------+------------+--------+ | stu0002 | 张四 | 1 | 28 | 165 | 女 | | stu0003 | 张五 | 2 | 22 | 187 | 男 | | stu0004 | 小明 | 2 | 25 | 189 | 女 | | stu0005 | 小猪 | 1 | 30 | 173 | 女 | | stu0007 | 小江 | 1 | 25 | 178 | 女 | +---------+----------+----------+---------+------------+--------+ 5 rows in set (0.00 sec) or：逻辑或 # 或 # 查找身高高于170的或者年龄大于20岁的学生 select * from my_student where stu_height &gt;= 170 or stu_age &gt;= 20; 结果为： +---------+----------+----------+---------+------------+--------+ | stu_id | stu_name | class_id | stu_age | stu_height | gender | +---------+----------+----------+---------+------------+--------+ | stu0001 | 小张 | 1 | 18 | 185 | 男 | | stu0002 | 张四 | 1 | 28 | 165 | 女 | | stu0003 | 张五 | 2 | 22 | 187 | 男 | | stu0004 | 小明 | 2 | 25 | 189 | 女 | | stu0005 | 小猪 | 1 | 30 | 173 | 女 | | stu0006 | 小狗 | 2 | 18 | 170 | 男 | | stu0007 | 小江 | 1 | 25 | 178 | 女 | +---------+----------+----------+---------+------------+--------+ 7 rows in set (0.00 sec) not：逻辑非 in运算符 in：在什么里面，是用来替代=，当结果不是一个值，而是一个结果集的时候。 基本语法：in (结果1，结果2，结果3,...) //只要是当前条件在结果集中出现过，那么就成立 # in运算符 # 知道学生信息 select * from my_student where stu_id in (&#39;stu0001&#39;,&#39;stu0004&#39;,&#39;stu0007&#39;); 结果为： +---------+----------+----------+---------+------------+--------+ | stu_id | stu_name | class_id | stu_age | stu_height | gender | +---------+----------+----------+---------+------------+--------+ | stu0001 | 小张 | 1 | 18 | 185 | 男 | | stu0004 | 小明 | 2 | 25 | 189 | 女 | | stu0007 | 小江 | 1 | 25 | 178 | 女 | +---------+----------+----------+---------+------------+--------+ 3 rows in set (0.08 sec) is运算符 is是专门用来判断字段是否为null的运算符。 基本语法：is null/is not null # is运算符 # 查询不为空数据 select * from my_int where int_6 is null; 结果为： +-------+-------+-------+-------+-------+--------+---------+------------+ | int_8 | int_7 | int_6 | int_1 | int_2 | int_3 | int_4 | int_5 | +-------+-------+-------+-------+-------+--------+---------+------------+ | NULL | NULL | NULL | 10 | 10000 | 100000 | 1000000 | 1000000000 | | NULL | NULL | NULL | -128 | 255 | 255 | 255 | 255 | | NULL | NULL | NULL | 127 | 255 | 255 | 255 | 255 | +-------+-------+-------+-------+-------+--------+---------+------------+ 3 rows in set (0.00 sec) like运算符 like运算符：是用来进行模糊匹配（匹配字符串） 基本语法：like &#39;匹配模式&#39; 匹配模式中，用两种占位符： _：匹配对应的单个字符 %：匹配多个字符 # like运算符 # 获取所有姓小的同学 select * from my_student where stu_name like &#39;小%&#39;; select * from my_student where stu_name like &#39;小_&#39;; 结果为： +---------+----------+----------+---------+------------+--------+ | stu_id | stu_name | class_id | stu_age | stu_height | gender | +---------+----------+----------+---------+------------+--------+ | stu0001 | 小张 | 1 | 18 | 185 | 男 | | stu0004 | 小明 | 2 | 25 | 189 | 女 | | stu0005 | 小猪 | 1 | 30 | 173 | 女 | | stu0006 | 小狗 | 2 | 18 | 170 | 男 | | stu0007 | 小江 | 1 | 25 | 178 | 女 | +---------+----------+----------+---------+------------+--------+ 5 rows in set (0.00 sec) +---------+----------+----------+---------+------------+--------+ | stu_id | stu_name | class_id | stu_age | stu_height | gender | +---------+----------+----------+---------+------------+--------+ | stu0001 | 小张 | 1 | 18 | 185 | 男 | | stu0004 | 小明 | 2 | 25 | 189 | 女 | | stu0005 | 小猪 | 1 | 30 | 173 | 女 | | stu0006 | 小狗 | 2 | 18 | 170 | 男 | | stu0007 | 小江 | 1 | 25 | 178 | 女 | +---------+----------+----------+---------+------------+--------+ 5 rows in set (0.00 sec) 联合查询基本概念 联合查询是可合并多个相似的选择查询的结果集，等同于将一个表追加到另一个表，从而实现将两个表的查询组合到一起，使用为此为UNION或UNION ALL。 联合查询：将多个查询的结果合并到一起（纵向合并），字段数不变，多个查询的记录数合并。 应用场景 将同一张表中不同的结果（需要对应多条的查询语句来实现），合并到一起展示数据。 最常见，在数据量大的情况下，会对表进行分表操作，需要对每张表进行部分数据统计，使用联合查询来将数据存放到一起显示。 基本语法基本语法：select 语句 union [union选项] select 语句 union选项：与select选项基本一样 distinct：去重，去掉完全重复的数据（默认的） all：保存所有的数据 select * from my_student union select * from my_student; 结果为： +---------+----------+----------+---------+------------+--------+ | stu_id | stu_name | class_id | stu_age | stu_height | gender | +---------+----------+----------+---------+------------+--------+ | stu0001 | 小张 | 1 | 18 | 185 | 男 | | stu0002 | 张四 | 1 | 28 | 165 | 女 | | stu0003 | 张五 | 2 | 22 | 187 | 男 | | stu0004 | 小明 | 2 | 25 | 189 | 女 | | stu0005 | 小猪 | 1 | 30 | 173 | 女 | | stu0006 | 小狗 | 2 | 18 | 170 | 男 | | stu0007 | 小江 | 1 | 25 | 178 | 女 | +---------+----------+----------+---------+------------+--------+ 7 rows in set (0.00 sec) select * from my_student union all select * from my_student; 结果为： +---------+----------+----------+---------+------------+--------+ | stu_id | stu_name | class_id | stu_age | stu_height | gender | +---------+----------+----------+---------+------------+--------+ | stu0001 | 小张 | 1 | 18 | 185 | 男 | | stu0002 | 张四 | 1 | 28 | 165 | 女 | | stu0003 | 张五 | 2 | 22 | 187 | 男 | | stu0004 | 小明 | 2 | 25 | 189 | 女 | | stu0005 | 小猪 | 1 | 30 | 173 | 女 | | stu0006 | 小狗 | 2 | 18 | 170 | 男 | | stu0007 | 小江 | 1 | 25 | 178 | 女 | | stu0001 | 小张 | 1 | 18 | 185 | 男 | | stu0002 | 张四 | 1 | 28 | 165 | 女 | | stu0003 | 张五 | 2 | 22 | 187 | 男 | | stu0004 | 小明 | 2 | 25 | 189 | 女 | | stu0005 | 小猪 | 1 | 30 | 173 | 女 | | stu0006 | 小狗 | 2 | 18 | 170 | 男 | | stu0007 | 小江 | 1 | 25 | 178 | 女 | +---------+----------+----------+---------+------------+--------+ 14 rows in set (0.00 sec) 注意细节：union理论上只要保证字段数一样，不要每次拿到的数据对应的字段类型一致.永远只保留第一个select语句对应的字段名字。 select stu_id,stu_name,stu_height from my_student union all select stu_height,stu_name,stu_id from my_student; 结果为： +---------+----------+------------+ | stu_id | stu_name | stu_height | +---------+----------+------------+ | stu0001 | 小张 | 185 | | stu0002 | 张四 | 165 | | stu0003 | 张五 | 187 | | stu0004 | 小明 | 189 | | stu0005 | 小猪 | 173 | | stu0006 | 小狗 | 170 | | stu0007 | 小江 | 178 | | 185 | 小张 | stu0001 | | 165 | 张四 | stu0002 | | 187 | 张五 | stu0003 | | 189 | 小明 | stu0004 | | 173 | 小猪 | stu0005 | | 170 | 小狗 | stu0006 | | 178 | 小江 | stu0007 | +---------+----------+------------+ 14 rows in set (0.00 sec) order by的使用 在联合查询中，如果要使用order by，那么对应的select语句必须使用括号括起来 # 获取男生身高升序，女生身高降序 (select * from my_student where gender=&#39;男&#39; order by stu_height asc) union (select * from my_student where gender=&#39;女&#39; order by stu_height desc) ; 结果为： +---------+----------+----------+---------+------------+--------+ | stu_id | stu_name | class_id | stu_age | stu_height | gender | +---------+----------+----------+---------+------------+--------+ | stu0001 | 小张 | 1 | 18 | 185 | 男 | | stu0003 | 张五 | 2 | 22 | 187 | 男 | | stu0006 | 小狗 | 2 | 18 | 170 | 男 | | stu0002 | 张四 | 1 | 28 | 165 | 女 | | stu0004 | 小明 | 2 | 25 | 189 | 女 | | stu0005 | 小猪 | 1 | 30 | 173 | 女 | | stu0007 | 小江 | 1 | 25 | 178 | 女 | +---------+----------+----------+---------+------------+--------+ 7 rows in set (0.00 sec) order by在联合查询中若要生效，必须配合使用limit。而limit后面必须跟对应的限制数量（通常可以使用一个较大的之，大于对应表的记录数） # 获取男生身高升序，女生身高降序 (select * from my_student where gender=&#39;男&#39; order by stu_height asc limit 10) union (select * from my_student where gender=&#39;女&#39; order by stu_height desc limit 10) ; 结果为： +---------+----------+----------+---------+------------+--------+ | stu_id | stu_name | class_id | stu_age | stu_height | gender | +---------+----------+----------+---------+------------+--------+ | stu0006 | 小狗 | 2 | 18 | 170 | 男 | | stu0001 | 小张 | 1 | 18 | 185 | 男 | | stu0003 | 张五 | 2 | 22 | 187 | 男 | | stu0004 | 小明 | 2 | 25 | 189 | 女 | | stu0007 | 小江 | 1 | 25 | 178 | 女 | | stu0005 | 小猪 | 1 | 30 | 173 | 女 | | stu0002 | 张四 | 1 | 28 | 165 | 女 | +---------+----------+----------+---------+------------+--------+ 7 rows in set (0.00 sec) 连接查询交叉连接 交叉连接：将两张表的数据与另外一张表彼此交叉 原理 从第一张表依次取出每一条记录 取出每一条记录之后，与另外一张表的全部记录挨个匹配 没有任何匹配条件，所有的结果都会进行保留 记录数=第一张表记录数*第二张表记录数，字段数=第一张表字段数+第二张表字段数（笛卡尔积） 语法基本语法：表1 cross join 表2 select * from my_student cross join my_int; 结果为： +---------+----------+----------+---------+------------+--------+-------+-------+-------+-------+-------+--------+---------+------------+ | stu_id | stu_name | class_id | stu_age | stu_height | gender | int_8 | int_7 | int_6 | int_1 | int_2 | int_3 | int_4 | int_5 | +---------+----------+----------+---------+------------+--------+-------+-------+-------+-------+-------+--------+---------+------------+ | stu0001 | 小张 | 1 | 18 | 185 | 男 | NULL | NULL | NULL | 10 | 10000 | 100000 | 1000000 | 1000000000 | | stu0002 | 张四 | 1 | 28 | 165 | 女 | NULL | NULL | NULL | 10 | 10000 | 100000 | 1000000 | 1000000000 | | stu0003 | 张五 | 2 | 22 | 187 | 男 | NULL | NULL | NULL | 10 | 10000 | 100000 | 1000000 | 1000000000 | | stu0004 | 小明 | 2 | 25 | 189 | 女 | NULL | NULL | NULL | 10 | 10000 | 100000 | 1000000 | 1000000000 | | stu0005 | 小猪 | 1 | 30 | 173 | 女 | NULL | NULL | NULL | 10 | 10000 | 100000 | 1000000 | 1000000000 | | stu0006 | 小狗 | 2 | 18 | 170 | 男 | NULL | NULL | NULL | 10 | 10000 | 100000 | 1000000 | 1000000000 | . . . . . . 应用交叉连接产生的结果是笛卡尔积，没有实际应用。 连接查询 连接查询：将多张表连到一起进行查询（会导致记录数和字段数列发生改变） 连接查询的意义在关系型数据库设计过程中，实体（表）与实体之间是存在很多联系的。在关系型数据库表的设计过程中，遵循这关系来设计：一对一，一对多和多对多，通常在实际操作的过程中，需要利用这层关系来保证数据的完整性。 连接查询分类连接查询一共有以下几类： 交叉连接 内连接 外连接：左外连接（左连接）和右外连接（右连接） 自然连接 内连接 内连接：inner join，从一张表中取出所有的记录去另外一张表中匹配，利用匹配条件进行匹配，成功了则保留，失败则放弃。 原理 从第一张表中取出一条记录，然后去另外一张表中进行匹配 利用匹配条件进行匹配2.1. 匹配到，保留，然后继续向下匹配2.2. 匹配失败，向下匹配，如果全表匹配失败，结束 语法基本语法：表1 [inner] join 表2 on 匹配条件 如果内连接没有条件（可以允许），那么其实就是交叉连接（避免发生） 使用匹配条件进行匹配 因为表的设计通常容易产生同名字段，尤其是ID，所以为了避免重名出现错误，通常使用表名.字段名，来确保唯一性 通常如果条件中使用到独赢的表名，而表名通常比较长。所以可以通过表别名来简化 内连接匹配的时候，必须保证匹配到才会保存 内连接因为不强制必须使用匹配条件（on），因此可以在数据匹配完成之后，使用where条件来限制，效果与on一样（建议使用on） # 内连接 create table my_class( id int primary key auto_increment, name varchar(10) not null unique ); # 插入数据 insert into my_class values(null,&#39;1班&#39;),(null,&#39;2班&#39;),(null,&#39;3班&#39;); # 内连接 select * from my_student inner join my_class; select * from my_student inner join my_class on class_id=id; select * from my_student inner join my_class on my_student.class_id=my_class.id; select * from my_student as s inner join my_class as c on s.class_id=c.id; select * from my_class as c inner join my_student as s on s.class_id=c.id; select * from my_class as c inner join my_student as s where s.class_id=c.id; 应用内连接通常是对数据有精确要求的地方使用，必须保证两种表中都能进行数据匹配 外连接原理语法应用","categories":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"Docker搭建PHP、apache环境","slug":"Docker搭建PHP、apache环境","date":"2019-09-05T16:00:00.000Z","updated":"2019-10-11T00:08:30.250Z","comments":true,"path":"2019/09/06/Docker搭建PHP、apache环境/","link":"","permalink":"http://yoursite.com/2019/09/06/Docker搭建PHP、apache环境/","excerpt":"拉取Ubuntu镜像输入命令： $ docker pull ubuntu","text":"拉取Ubuntu镜像输入命令： $ docker pull ubuntu 运行Ubuntu容器 确认是否已下载好镜像，输入命令： $ docker images 上述命令之后如果出现以下情况，即为下载好了。 REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu latest 3556258649b2 2 weeks ago 64.2MB 运行，输入命令： $ docker run -it -d --name ubuntu -p 80:80 ubuntu –name自定义容器名，-p指定端口映射，前者为虚拟机端口，后者为容器端口,成功后返回id查看所有启动的容器。 查看所有容器。 $ docker ps -a 如果是以下情况，则为运行成功。 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES d5d8952f48b2 ubuntu &quot;/bin/bash&quot; About a minute ago Up About a minute 0.0.0.0:8088-&gt;80/tcp ubuntu 进入容器输入以下命令： $ docker exec -it ubuntu /bin/bash 安装Apache2和PHP7.2配置软件源输入以下命令： # sed -i &#39;s/archive.ubuntu.com/mirrors.ustc.edu.cn/g&#39; /etc/apt/sources.list # apt update 检查PHP和Apache模块输入以下命令： # apt list | grep libapache2-mod-php* 结果为以下情况即为可以安装Apache2和PHP7.2 WARNING: apt does not have a stable CLI interface. Use with caution in scripts. libapache2-mod-php/bionic,bionic 1:7.2+60ubuntu1 all libapache2-mod-php7.2/bionic-updates,bionic-security 7.2.19-0ubuntu0.18.04.1 amd64 安装Apache2和PHP7.2 安装 # apt install php7.2 libapache2-mod-php7.2 在安装过程需要设置php的时区，输入相对应的号码即可。 验证是否安装成功。 root@dd29dc7f7771:/# php -v PHP 7.2.19-0ubuntu0.18.04.1 (cli) (built: Jun 4 2019 14:48:12) ( NTS ) Copyright (c) 1997-2018 The PHP Group Zend Engine v3.2.0, Copyright (c) 1998-2018 Zend Technologies with Zend OPcache v7.2.19-0ubuntu0.18.04.1, Copyright (c) 1999-2018, by Zend Technologies root@dd29dc7f7771:/# apache2 -v Server version: Apache/2.4.29 (Ubuntu) Server built: 2019-07-16T18:14:45 配置 ServerName # vi /etc/apache2/apache2.conf ## 添加一行 ServerName localhost 启动 # service apache2 start 查看PHP环境信息以及相关模块在 /var/www/html 目录下新建文件phpinfo.php并添加如下代码： &lt;?php phpinfo(); ?&gt; 通过浏览器输入IP/phpinfo.php访问。 Demo 安装php-mysqli模块 安装 # apt install php-mysqli 使用命令打开vi /etc/php/7.2/apache2/php.ini去掉extension=mysqli.dll前面的；号，保存退出。 重新启动apache # service apache2 restart 扩展phpmyadmin命令如下： # apt install wget ## 如果已有可忽略 # cd /avr/www/html # wget https://files.phpmyadmin.net/phpMyAdmin/4.9.0.1/phpMyAdmin-4.9.0.1-all-languages.zip ## 下载phpmyadmin # apt install zip ## 如果已有可忽略 # unzip phpMyAdmin-4.9.0.1-all-languages.zip ##解压 # mv phpMyAdmin-4.9.0.1-all-languages phpmyadmin ##重命名 ## 配置phpmyadmin连接远程数据库 # vim /phpMyAdmin/libraries/config.default.php ## 将 $cfg[&#39;Servers&#39;][$i][&#39;host&#39;] = ‘localhost’ 中的loaclhost改为自己的远程数据库IP 在浏览器输入IP/phpmyadmin即可查看。Demo 使用模板## 首先需要创建一个目录作为映射目录 # mkdir www ## 拉取镜像 # docker pull yancccccc/php-apache ## 运行 # docker run -it -d --name php-apache -p 80:80 -v $PWD/www:/var/www/html yancccccc/php-apache ## 启动apache # docker exec -it php-apache /bin/bash # service apache2 start # exit ## 安装phpmyadmin则将目录改为刚才创建的映射目录即可，其它步骤不需要改变。","categories":[{"name":"Docker","slug":"Docker","permalink":"http://yoursite.com/categories/Docker/"},{"name":"PHP、apache","slug":"Docker/PHP、apache","permalink":"http://yoursite.com/categories/Docker/PHP、apache/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://yoursite.com/tags/Docker/"},{"name":"PHP、apache","slug":"PHP、apache","permalink":"http://yoursite.com/tags/PHP、apache/"}]},{"title":"PHP入门","slug":"PHP入门","date":"2019-08-23T16:00:00.000Z","updated":"2019-10-11T00:12:32.770Z","comments":true,"path":"2019/08/24/PHP入门/","link":"","permalink":"http://yoursite.com/2019/08/24/PHP入门/","excerpt":"代码仓库仓库地址：GitHub 环境： Apache/2.4.39 (Win64) PHP 7.3.6 PhpStorm 2019.2 MySQL 5.6 软件安装路径 Apache D:\\server\\apache PHP D:\\server\\php7 演示地址Demo 视频地址参考： 链接: https://pan.baidu.com/s/1oxqVH8_GH94bhbpmQ4b-8Q 提取码: wsfd PHP手册文件名为php_manual_zh.chm即为PHP手册。 打不开参考下面链接： 解决win10中无法打开CHM文件的方法 搭建环境（Windows）较早版本Apache 下载下载地址：Apache msi","text":"代码仓库仓库地址：GitHub 环境： Apache/2.4.39 (Win64) PHP 7.3.6 PhpStorm 2019.2 MySQL 5.6 软件安装路径 Apache D:\\server\\apache PHP D:\\server\\php7 演示地址Demo 视频地址参考： 链接: https://pan.baidu.com/s/1oxqVH8_GH94bhbpmQ4b-8Q 提取码: wsfd PHP手册文件名为php_manual_zh.chm即为PHP手册。 打不开参考下面链接： 解决win10中无法打开CHM文件的方法 搭建环境（Windows）较早版本Apache 下载下载地址：Apache msi 较早版本Apache 安装 双击下载的文件。 相关配置。 选择自定义安装模式 Apache 目录结构说明 Apache-httpd.exe介绍Httpd.exe的详细应用 服务器进程：运行之后才能够使用。 用来查看Apache具有哪些功能以及配置文件是否有错：httpd或者httpd.exe（文件所在目录） 查看使用的模块：httpd -M 验证配置文件是否有效：httpd -t Apache/2.4.39 (Win64)下载与安装下载下载地址： Apache/2.4.39 (Win64) 点击之后以Apache Lounge为例进行下载 之后根据自己安装的是哪个vc对应进行下载 安装、运行、卸载 对下载的文件进行解压，选择自己需要安装的地方。 打开conf\\httpd.conf，将所有的c:/Apache24 替换为自己的安装目录。 以管理员身份运行CMD，进入\\bin 目录（httpd.exe所在目录）。 输入 httpd.exe -k install -n “Apache24” 进行安装。 至此，安装基本完成。到安装目录下的bin目录中找到 ApacheMonitor.exe ,双击运行,启动apache服务。 如果要卸载这个服务 先要停止这个服务，然后输入httpd.exe -k uninstall –n “Apache24”进行卸载。 PHP 安装下载下载地址：PHP 7.3 (7.3.7) 关于php下载时VC各版本的区别和Non Thread Safe、Thread safe的简单辨析 参考：php下载时VC各版本的区别和Non Thread Safe、Thread safe的简单辨析 安装 解压缩 将压缩包放到E:/server/,同时重命名为PHP7 配置 Apache 加载 PHP 模块需改内容之后都需要重启apache Apache 加载 PHP 模块：在Apache的主配置文件中加载对应的PHP提供的模块 在apache安装目录的conf目录下对httpd.conf进行添加一下内容： #加载PHP LoadModule php7_module &#39;D:/server/php7/php7apache2_4.dll&#39; 验证 需改内容之后都需要重启apache Microsoft Windows [版本 10.0.17763.615] (c) 2018 Microsoft Corporation。保留所有权利。 C:\\Users\\Yan&gt;D: D:\\&gt;cd server\\apache\\bin D:\\server\\apache\\bin&gt;httpd.exe -t AH00558: httpd.exe: Could not reliably determine the server&#39;s fully qualified domain name, using fe80::3993:9c4f:39af:664d. Set the &#39;ServerName&#39; directive globally to suppress this message Syntax OK D:\\server\\apache\\bin&gt;httpd.exe -M AH00558: httpd.exe: Could not reliably determine the server&#39;s fully qualified domain name, using fe80::3993:9c4f:39af:664d. Set the &#39;ServerName&#39; directive globally to suppress this message Loaded Modules: core_module (static) win32_module (static) mpm_winnt_module (static) http_module (static) so_module (static) actions_module (shared) alias_module (shared) allowmethods_module (shared) asis_module (shared) auth_basic_module (shared) authn_core_module (shared) authn_file_module (shared) authz_core_module (shared) authz_groupfile_module (shared) authz_host_module (shared) authz_user_module (shared) autoindex_module (shared) cgi_module (shared) dir_module (shared) env_module (shared) include_module (shared) isapi_module (shared) log_config_module (shared) mime_module (shared) negotiation_module (shared) setenvif_module (shared) php7_module (shared) ##需要出现这个即可 Apache 分配工作给PHP模块：如果是PHP代码就交给PHP处理（通过文件后缀名.php进行识别） 在apache安装目录的conf目录下对httpd.conf进行添加一下内容： # 分配给PHP AddType application/x-httpd-php .php 需改内容之后都需要重启apache 将PHP的配置文件加载到Apache配置文件中，使之共同生效。 在Apache中指定PHP配置文件所在路径 httpd.conf中添加： #加载PHP配置文件 PHPIniDir &#39;D:/server/php7&#39; php.ini 文件是默认不存在的，是以development和production格式存在，需要格式化。 将php安装目录中的php.ini-development文件复制一个副本并重名为php.ini,然后重启Apache。 说明：PHP的配置文件已经加入到Apache的配置项中，意味着php.ini的修改需要Apache重启才会生效。 httpd.conf#加载PHP LoadModule php7_module &#39;D:/server/php7/php7apache2_4.dll&#39; #加载PHP配置文件 PHPIniDir &#39;D:/server/php7&#39; # 分配给PHP AddType application/x-httpd-php .php 配置PhpStorm首先使用PhpStorm打开自己的项目，然后File | Settings | Build, Execution, Deployment | Deployment。 配置如下图： Folder为apache的资源文件部署位置。 Local path为自己项目的位置，Deployment path为部署到apache中的映射文件名称，Web path为自己运行项目后需要输入到浏览器的路径名。多练习练习总会找到自己无法解决的关键。 这一步是将自己的代码同步到apache的htdocs文件夹下，只需点击一次即可之后会自动同步。 同步自己的代码到远程服务器 搭建自己的远程服务器环境 参考以下文章： docker搭建php、apache 配置phpstorm 首先使用PhpStorm打开自己的项目，然后File | Settings | Build, Execution, Deployment | Deployment。 点击+ 其他步骤如下图所示 这个时候上传的选项就要选择远程服务器那个选项，而不是图中的本地的选项。上图只是展示与本地不一样的地方 安装MySQL为了方便安装，使用docker来搭建MySQL环境。没有条件的可以百度自行安装MySQL。 安装Docker参考： Ubuntu18.04 安装 Docker 安装MySQL输入以下命令： ## 拉取官方的镜像,标签为5.6 docker pull mysql:5.6 ## 运行 docker run --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.6 --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci ## -p 3306:3306：将容器的 3306 端口映射到主机的 3306 端口。 ## e MYSQL_ROOT_PASSWORD=123456：初始化 root 用户的密码。 ## --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci：解决中文问题 ## 进入MySQL docker exec -it mysql bash ## 登录MySQL mysql -u root -p ## 然后输入密码 MySQL的目录结构说明（Windows） bin目录 软件设计结构：C/S和B/SC/S:Client客户端/Server服务端，用户需要安装客户端产品才能访问服务器，而且只能访问一种软件（当前自己）B/S:Browser浏览器和/Server服务端，用户只需要安装浏览器，就可以访问所有的服务器（B/S架构服务） MySQL的访问流程 MySQL是一款C/S架构的软件，需要通过客户端来访问服务（MySQL其实也提供了其他模式的访问：通过一些插件扩展来充当客户端） 启用MySQL客户端：mysql.exe,该软件本身可以通过CMD控制台运行。 MySQL客户端访问服务端需要进行寻找匹配：连接认证连接：ip和端口确认，如果是本地都可以省略。 -h 主机地址—-》 -hlocalhost(可以是IP) -P 端口—》-P3306 认证：通过用户名和密码进入服务器 -u 用户名—》-uroot,不可以省略（匿名用户除外） -p 密码—》-proot 退出命令：\\q 注意：通常连接认证的时候密码不建议明文，可以在输入-p之后回车，系统会再次让输入密码，这个时候就是密文 PHP连接MySQL数据库PHP7正式移除了mysql 扩展，推荐使用mysqli或者pdo_mysql php7配置mysqli或者pdo_mysql和使用mysqli或者pdo_mysql连接MySQL我是该用 MySQLi ，还是 PDO? 如果你需要一个简短的回答，即 “你习惯哪个就用哪个”。MySQLi 和 PDO 有它们自己的优势：PDO 应用在 12 种不同数据库中， MySQLi 只针对 MySQL 数据库。所以，如果你的项目需要在多种数据库中切换，建议使用 PDO ，这样你只需要修改连接字符串和部分查询语句即可。 使用 MySQLi, 如果不同数据库，你需要重新编写所有代码，包括查询。两者都是面向对象, 但 MySQLi 还提供了 API 接口。两者都支持预处理语句。 预处理语句可以防止 SQL 注入，对于 web 项目的安全性是非常重要的。 首先配置php.ini文件 编辑php.ini 将 ;extension=mysqli 改为extension=mysqli。有的版本中会是 ;extension=php_mysqli.dll，原理都是将前面的 ; 去掉 将 ;extension=pdo_mysql 改为extension=pdo_mysql。有的版本中会是 ;extension=php_pdo.dll，原理都是将前面的 ; 去掉 再次编辑php.ini 将 extension_dir = “ext”改为 extension_dir = “D:/server/php7/ext”，D:/server/php7/ext为自己安装php的绝对路径 重启apache服务 编辑index.php &lt;?php phpinfo(); ?&gt; 浏览器输入：http://localhost:80/index.php 验证 数据库连接（三种方式） MySQLi - 面向对象 &lt;?php $servername = &quot;localhost&quot;; $username = &quot;username&quot;; $password = &quot;password&quot;; // 创建连接 $conn = new mysqli($servername, $username, $password); // 检测连接 if ($conn-&gt;connect_error) { die(&quot;连接失败: &quot; . $conn-&gt;connect_error); } echo &quot;连接成功&quot;; ?&gt; MySQLi - 面向过程 &lt;?php $servername = &quot;localhost&quot;; $username = &quot;username&quot;; $password = &quot;password&quot;; // 创建连接 $conn = mysqli_connect($servername, $username, $password); // 检测连接 if (!$conn) { die(&quot;Connection failed: &quot; . mysqli_connect_error()); } echo &quot;连接成功&quot;; ?&gt; PDO &lt;?php $servername = &quot;localhost&quot;; $username = &quot;username&quot;; $password = &quot;password&quot;; try { $conn = new PDO(&quot;mysql:host=$servername;&quot;, $username, $password); echo &quot;连接成功&quot;; } catch(PDOException $e) { echo $e-&gt;getMessage(); } ?&gt; 参考链接： PHP 连接 MySQL 设定PHP的系统时区 编辑php.ini 修改为以下内容 date.timezone = PRC 重启Apache服务 PHP标记与注释PHP语法初步PHP是一种运行在服务器端的脚本语言，可以嵌入到HTML中。 PHP代码标记在PHP历史发展中，可以使用多种标记来区分PHP脚本。 ASP标记：&lt;% php 代码 %&gt; 短标记：&lt;? php代码 ?&gt; 以上两种基本弃用，如果需要使用则需要在配置文件中开启。 脚本标记：&lt; script language=”php”&gt;php代码&lt;/ script &gt; &lt;html&gt; &lt;body&gt; &lt;b&gt; &lt;script language=&quot;php&quot;&gt; &lt;!--脚本标记--&gt; echo &#39;hello world&#39;; &lt;/script&gt; &lt;/b&gt; &lt;/body&gt; &lt;/html&gt; 注：移除了 ASP 和 script PHP 标签 标准标记（常用）：&lt;?php php代码?&gt; &lt;html&gt; &lt;body&gt; &lt;b&gt; &lt;?php echo &#39;hello world&#39;; ?&gt; &lt;/b&gt; &lt;/body&gt; &lt;/html&gt; PHP注释 习惯：所有的代码在写的过程中都必须进行注释。 PHP注释分为两种：行注释和块注释。 行注释：一次注释一行 //：后面跟的所有内容都是注释 #：与//一样 块注释：一次注释多行 /**/:**之间的全部都是注释。 代码示例： &lt;?php // 在脚本开始前：会对脚本功能进行简单阐述 // 注释的内容会在PHP解析的过程中忽略 // 块注释 /* * @功能说明：注释说明 * @作者：XXX * @版本：Version01 */ echo &#39;hello world&#39;; ?&gt; PHP语句分隔符语句分隔符：在PHP中，代码是以行为单位，系统需要通过判断行的结束，该结束通常都是一个符号：分号”;“(英文状态下的分号)。 代码示例： &lt;?php /** * Create by PhpStorm * Date: 2019/8/6 * Time: 21:38 * Features: 语句分隔符 */ // 语句结束符 // 动手试一下前一个语句不加语句结束符的概况和后一个语句不加语句结束符的概况 // echo &#39;hello world&#39; echo &#39;hello world&#39;; ?&gt; 特殊说明： PHP标记结束符?&gt;有自带语句结束符的效果，最后一行PHP代码可以没有语句结束符”;“。 PHP中其实很多代码的书写并不是嵌入到HTML中，而是单独存在，通常书写习惯中就不建议使用标记结束符?&gt;，PHP会自动从开始到最后全部认为是PHP代码，从而解析。 变量 PHP是一种动态网站开发的脚本语言,动态语言特点是交互性，会有数据的传递，而PHP作为”中间人“，需要进行数据的传递，传递的前提就是PHP能自己存储数据（临时存储）。 变量的基本概念 变量来源于数学，是计算机语言中能储存计算结果或能表示值抽象概念。变量可以通过变量名访问。在指令式语言中，变量通常是可变的。 变量是用来存储数据的。 变量是存在名字的。 变量是通过名字来访问的：数据 变量是可以改变的：数据。 变量的使用 PHP中的所有变量都必须使用”$“符号。 定义：在系统中增加对应的变量名字（内存中） 赋值：可以将数据赋值给变量名（可以在定义的同时完成） 可以通过变量名访问存储的数据 可以将变量从内存中删除 代码示例： &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/6 * Time: 22:03 * Features: 定义变量 * */ // 变量 // 定义变量：在PHP中不需要任何关键字诋毁能够以变量（赋值） $var1; //定义变量 $var1=1; $var2=1; //定义同时赋值 // 访问变量 echo $var2; //通过var2变量名字找到存储的内容1，然后输出 //修改变量 $var2=2; echo &#39;&lt;hr/&gt;&#39;,$var2; // 删除变量：使用unset(变量名字) unset($var2); echo $var2; // 第一，文件末尾的 ? &gt;可以省略 // 第二，该脚本若被其他脚本包含，所以该脚本不需要结束，否则会报错，因为是要和其他脚本衔接，只有在php代码后面需要写html的才使用闭合标签。 ?&gt; 变量命名规则 在PHP中变量名必须以“$”符号开始； 名字由字母、数字和下划线“_”构成，但是不能以数字开头； 在PHP中本身还允许中文变量（不建议） 代码示例： // 变量命名规则 $var_1;$var_var_1;$_var1; //正确格式 $1var; //不正确格式 // 中文变量 $中国=‘china’; 预定义变量 预定义变量：提前定义的变量，系统定义的变量，存储许多需要用到的数据（预定义变量都是数组）。 $_GET：获取所有表单以get方式提交的数据 $_POST：POST提交的数据都会保存在此 $_REQUEST：GET和POST提交的都会保存 $GLOBALS：PHP中所有的全局变量 $_SERVER：服务器信息 $_SESSION：session会话数据 $_COOKIE：cookie会话数据 $_ENV：环境信息 $_FILES：用户上传的文件信息 可变变量 可变变量：如果 一个变量保存的值 刚好是另外一个变量的名字，那么可以直接通过访问一个变量得到另外一个变量的值：在变量前面在多加一个$符号。 代码示例： &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/7 * Time: 15:15 * Features: 可变变量 */ // 可变变量 // 定义两个变量 $a = &#39;b&#39;; $b = &#39;bb&#39;; echo $$a; // 1、找到$a，解析结果：b // 2、将前面的$符号与结果 b绑定：$b // 3、解析 ?&gt; 变量传值 将一个变量赋值给另外一个变量：变量传值。 变量传值一共有两个方式：值传递 ，引用传递。 值传递：将变量保存的值赋值一份，然后将新的值给另外一个变量保存。（两个变量没有关系） 引用传递：将变量保存的值所在的内存地址，传递给另外一个变量：两个变量指向同一块内存空间。（两个变量是同一个值） 在内存中，通常有以下几个分区： 栈区：程序可以操作的内存部分（不存数据，运行程序代码），少但是快 代码段：存储程序的内部部分（不执行） 数据段：存储普通数据 （全局区和静态区） 堆区：存储复杂数据，大但是效率低 代码示例： &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/7 * Time: 16:04 * Features: 变量传值 */ // 变量传值 // 值传递 $a=10; $b=$a; $b=5; echo $a,$b,&#39;&lt;/br&gt;&#39;; //引用传递 $c=10; $d=&amp;$c; $c=5; echo $c,$d,&#39;&lt;/br&gt;&#39;; ?&gt; 常量 常量与变量 一样，都是用来保存数据的。 常量基本概念 常量：const/constant，是一种在程序运行当中，不可改变的量（数据）。常量一旦定义，通常数据不可改变（用户级别）。 常量定义形式在PHP中常量有两种定义方式（5.3之后才有两种）： 使用定义常量的函数:define(&#39;常量名&#39;,常量值); 5.3之后才有的：const 常量名=值; 代码示例： &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/7 * Time: 16:27 * Features: 常量 */ // 常量 // 使用函数定义常量:define define(&#39;PI&#39;,3.14); // 使用const关键字定义 const PII=3; ?&gt; 常量名字的命名规则： 常量不需要使用“$”符号，一旦使用系统就会认为是变量 常量的名字组成由字母、数字和下划线组成，不能以数字开头 常量的名字通常是以大写字母为主（与变量以示区别） 常量命名的规则比变量要松散，可以使用一些特殊字符，该方式只能使用define定义 代码示例： &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/7 * Time: 16:27 * Features: 常量 */ // 常量 // 使用函数定义常量:define define(&#39;PI&#39;,3.14); // 使用const关键字定义 const PII=3; // 定义特使常量 define(&#39;-_-&#39;,&#39;small&#39;); // const -_-=&#39;smali&#39;; //错误 ?&gt; 注意细节： define和const定义的常量是由区别的：在于访问权限区别。 定义常量通常不区分大写写，但是可以区分，可以参照define函数的第三个参数。 常量使用形式 常量的使用与变量一样：不可改变值（在定义的时候必须赋值）。 有的时候还需要使用另外一种形式来访问（针对的是特殊名字的常量），需要用到另外一个访问常量的函数：constant(&#39;常量名&#39;)。 说明：常量和变量的使用 凡是数据会可能变化的，那么肯定使用变量 数据不一定会变，可以使用常量或者变量（变量居多） 数据不允许被修改的，一定用常量 代码示例： &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/7 * Time: 16:27 * Features: 常量 */ // 常量 // 使用函数定义常量:define define(&#39;PI&#39;,3.14); // 使用const关键字定义 const PII=3; // 定义特使常量 define(&#39;-_-&#39;,&#39;small&#39;); // const -_-=&#39;smali&#39;; //错误 // 使用常量 echo PI; // echo -_-; //特殊符号不能直接使用 echo constant(&#39;-_-&#39;); ?&gt; 系统常量 系统常量：系统帮助用户定义的常量，用户可以直接使用。 常用的几个系统常量 PHP_VERSION:PHP版本号PHP_INT_SIZE:整型大小PHP_INT_MAX:整型能表示的最大值(PHP中整型是允许出现负数的：带符号) 代码示例： &lt;?php // 系统常量 echo &#39;&lt;/br&gt;&#39;,PHP_VERSION,&#39;&lt;/br&gt;&#39;,PHP_INT_SIZE,&#39;&lt;/br&gt;&#39;,PHP_INT_MAX; ?&gt; 在PHP中还有一些特殊的常量，他们由双下划线开始+常量名+双下划线结束，这种常量称之为系统魔术常量：魔术常量的值通常会跟着环境变化，但是用户改变不了。 __DIR__:当前被执行的脚本所在电脑的绝对路径__FILE__:当前被执行的脚本所在的电脑的绝对路径（带自己文件的名字）___LINE__:当前所属的行数_NAMESPACE__:当前所属的命名空间__CLASS__:当前所属的类__METHOD__:当前所属的方法 代码示例： &lt;?php // 魔术常量 echo &#39;&lt;hr/&gt;&#39;; echo __DIR__,&#39;&lt;br/&gt;&#39;,__FILE__,&#39;&lt;br/&gt;&#39;,__LINE__,&#39;&lt;br/&gt;&#39;; echo __LINE__; ?&gt; 数据类型 数据类型：data type,在PHP中指的是存储的数据本身的类型，而不是变量的类型。PHP是一种弱类型语言，变量本身没有数据类型。 PHP的八种数据类型 在PHP中将数据分为三大类八小类： 简单（基本）数据类型:4个小类 整型：int/integer，系统分配4个字节存储，表示整数类型（有前提） 浮点型：float/double，系统分配8个字节存储，表示小数或者整型存不下的整数 字符串型：string，系统根据实际长度分配，表示字符串（引号） 布尔类型：bool/boolean，表示布尔类型，只有两个值：true和false 复合数据类型：2个小类 对象类型：object，存放对象（面向对象） 数组类型：array，存储多个数据（一次性） 特殊数据类型：2个小类 资源类型：resource，存放资源数据（PHP外部数据，如数据库、文件） 空类型：NULL，只有一个值就是NULL（不能运算） 类型转换 类型转换：在很多的条件下，需要指定的数据类型，需要外部数据（当前PHP取得的数据），转换成目标数据类型。 在PHP中有两种类型转换方式： 自动转换：系统根据需求自己判定，自己转换（用的比较多，效率偏低） 强制（手动）转换：认为 根据需要的目标类型转换 强制转换规则：在变量之前增加一个括号()，然后在里面写上对应类型：int/integer….其中NULL类型用到unset()。 在转换过程中，用的比较多的就是转布尔类型（判断）和转数值类型（算术运算）。 其他类型转布尔类型：true或者false，在PHP中比较少类型换变成false 其他类型转数值的说明 布尔true为1，false为0 字符串转数值有自己的规则2.1 以字母开头的字符串，永远为02.2 以数字开头的字符串，取到碰到字符串为止（不会同时包含两个小数点） 代码示例： &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/8 * Time: 15:06 * Features: 数据类型 */ // 数据类型 // 创建数据 $a=&#39;abc1.1.1&#39;; $b=&#39;1.1.1.abc&#39;; // 自动转换 echo $a+$b; //算术运算，系统先转换成数值类型（整型和浮点型），然后运算 //强制转换 echo &#39;&lt;br/&gt;&#39;,(float)$a,(float)$b; ?&gt; 类型判断 通过一组类型判断函数，来判断变量，最终返回这个变量所保存数据的数据类型（相同结果为true，失败为false）：是一组以is_开头后面跟类型名字的函数：is_XXX(变量名) bool类型不能用echo来查看，可以使用 var_dump结构来查看 var_dump(变量1，变量2....) 还有一组函数可以用来获取以及设定数据（变量）的类型 gettype(变量名)：获取类型，得到的是该类型对应的字符串settype(变量名,类型)：设定数据类型：与强制转换不同 强制转换（类型）变量名，是对数据值复制的内容进行处理（不会处理实际存储的内容） settype会直接改变数据本身 代码示例： &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/8 * Time: 15:06 * Features: 数据类型 */ // 数据类型 // 创建数据 $a=&#39;abc1.1.1&#39;; $b=&#39;1.1.1.abc&#39;; // 自动转换 echo $a+$b; //算术运算，系统先转换成数值类型（整型和浮点型），然后运算 //强制转换 echo &#39;&lt;br/&gt;&#39;,(float)$a,(float)$b; // 判断数据类型 echo &#39;&lt;hr/&gt;&#39;; var_dump(is_int($a)); //false var_dump(is_string($a)); //true echo &#39;&lt;hr/&gt;&#39;; echo gettype($a); // 设置类型 echo &#39;&lt;hr/&gt;&#39;; var_dump(settype($b,&#39;int&#39;)); echo gettype($b),$b; ?&gt; 整数类型 整数类型：保存整数数值（范围限制），4个字节存储数据，最大就是32位：42亿多。但是在PHP中默认是有符号类型（区分正负数） 在PHP中提供了四种整型的定义方式：十进制定义，二进制定义，八进制定义，十六进制定义。 $a=120; //十进制 $b=0b110; //二进制 $c=0120; //八进制 $d=0x120; //十六进制 代码示例： &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/8 * Time: 19:58 * Features: 简单数据类型：整型、浮点型和布尔型 */ // 定义四种整形数据 $a1=110; $a2=0b110; $a3=0110; $a4=0x110; echo $a1,&#39;~&#39;,$a2,&#39;~&#39;,$a3,&#39;~&#39;,$a4,&#39;&lt;hr/&gt;&#39;; //默认的PHP输出数值都会自动转换成十进制输出 ?&gt; 十进制：逢十进一，能够出现的数字是0-9； 二进制：逢二进一，能够出现的数字是0-1； 八进制：逢八进一，能够出现的数字是0-7； 十六进制：逢十六进一，能够出现的数字是0-9以及a-f，a表示10，依次类推。 进制转换：手动转换 十进制转二进制：除2倒取余。十进制转二进制：取出最大的2的N次方，直到结果为0。二进制到十进制之间的转换：从右侧开始，将对应的第几位作为2的指数，然后将所有的结果相加。 PHP中不需要用户这么复杂的去计算，提供了很多的函数进行转换 decbin():十进制转二进制 decoct():十进制转八进制 dechex():十进制转十六进制 代码示例： &lt;?php // 利用进制函数运算 var_dump(decbin(107)); ?&gt; 浮点类型 浮点型：小数类型以及超过整型所能存储范围的整数（不保证精度），精度范围大概在15个有效数字左右。 浮点型定义有两种方式： $f=1.23; $f=1.23e10; //科学计数法，其中e表示底10，1.23x10^10 代码示例： &lt;?php // 浮点数 $f1=1.23; $f2=1.23e10; $f3=PHP_INT_MAX+1; //整型超过自身存储的大小之后会用浮点型存储。 echo &#39;&lt;hr/&gt;&#39;; var_dump($f1,$f2,$f3); ?&gt; 简单说明浮点数为什么同样的字节数存储数据，但是却能表示更大的数据呢？ 00000000 00000000 00000000 00000000 -&gt;11111111 11111111 11111111 11111111(整型最大值：所有位都是有效数据) 浮点数:**中的七位算的结果都是10的指数，后面三个字节存储表示具体数值 00000000 00000000 00000000 00000000 -&gt;1*1111111* 11111111 11111111 11111111 尽量不要用浮点数做精确判断：浮点数保存的数据不够精确，而且在计算机中 凡是小数基本存的都不准确。 代码示例： &lt;?php //浮点数判断 $f4=0.7; $f5=2.1; $f6=$f5/3; echo &#39;&lt;hr/&gt;&#39;; var_dump($f4==$f6); ?&gt; 布尔类型 布尔类型：两个值true和false，通常是用于判断比较 代码示例： &lt;?php // 布尔类型 echo &#39;&lt;hr/&gt;&#39;; $b1=true; $b2=false; var_dump($b1,$b2); ?&gt; 在进行某些数据判断的时候，需要特别注意类型转换 empty():判断数据的值是否为空“”，不是NULL，如果为空返回true，不为空返回false isset():判断数据存储的变量本身是否存在，存在变量返回true，不存在返回false 运算符 运算符：operator,是一种将数据进行运算的特殊符号，在PHP中一共有十种运算符之多。 赋值运算符赋值运算 ：符号是“=”,表示将右边的结果（可以是变量、数据、常量和其他匀速出来的结果），保存道内存的某个位置，然后将位置的内存地址赋值给左侧的变量（常量）。 算术运算符算术运算：基本算术操作 +:执行数据累加 -:数据相减 *:键盘上没有乘法符号，使用*代替，两个数相乘 /:正斜杠代替，表示两个数相除 %:取余（模）运算，两个数（整数）相除，保留余数 在进行除法运算或者取余运算的时候，对应的被除数（第二个数）不能为0。 代码示例： &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/9 * Time: 13:54 * Features: 运算符 */ // 运算符 // 算术运算符 $a=$b=10; //连贯赋值运算：两个不同变量 $c=0; var_dump($a/0); //错误，被除数不能为0 ?&gt; 比较运算符比较运算：比较两个数据的大小，或者两个内容是否相同。返回的结果都是 布尔类型：满足返回true，不满足返回false。 &gt;:左边大于右边，返回结果 true &gt;=:左边大于或者等于右边 &lt;:左边小于右边 &lt;=:左边小于或者等于右边 ==:左边的与右边的相同（大小相同） !=:左边的与右边的不同（大小不同） ===:全等于，左边与右边相同：大小以及数据的类型都要相同 !==:不全等于，只要大小或者类型不同 代码示例： &lt;?php //比较运算符 $a=&#39;123&#39;; //字符串 $b=123; //整型 //判断相等 var_dump($a==$b); echo &#39;&lt;hr/&gt;&#39;; // 全等判断 var_dump($a===$b); ?&gt; 逻辑运算符 逻辑运算：针对不同的结果进行匹配，满足条件返回true，不满足返回false &amp;&amp;:逻辑与，左边的条件与右边的条件同时成立（两边的结果都为true） ||:逻辑或，左边的条件或者右边的条件只要 有一个 满足即可 !:逻辑非，对已有条件进行取反，本身为true，取反结果就是false 代码示例： &lt;?php // 逻辑运算符 echo &#39;&lt;hr/&gt;&#39;; $a = &#39;weekend&#39;; $b = &#39;goods&#39;; // 逻辑与 var_dump($a == &#39;weekend&#39; &amp;&amp; $b == &#39;good&#39;); echo &#39;&lt;hr/&gt;&#39;; // 逻辑或 var_dump($a == &#39;weekend&#39; || $b == &#39;good&#39;); echo &#39;&lt;hr/&gt;&#39;; // 逻辑非 var_dump($b==&#39;good&#39;); var_dump(!($b==&#39;good&#39;)); ?&gt; 逻辑非和逻辑或又称为短路运算：如果第一个表达式结果已经满足条件了，那么就不会运行逻辑运算符后的表达式：在书写代码的时候，尽量将出现概率最高的（能够直接判断出结果）的表达式放到第一位。 连接运算符 连接运算：是PHP中将多个字符串拼接的一种符号。 .:将两个字符串拼接到一起 .=:符合运算，将左边的内容与右边的内容连接起来，然后重新赋值给左边变量，如A.=b -----&gt; A=A.b 代码示例： &lt;?php // 连接运算符 $a=&#39;hello&#39;; $b=123; echo $a.$b; //将a变量和b变量连接起来 echo &#39;&lt;hr/&gt;&#39;; $a.=$b; // $a=$a.$b echo $a; ?&gt; 错误抑制符 在PHP中有一些错误可以提前预知 ，但是这些错误可能无法避免，但是又比希望报错给用户看，可以使用错误抑制符处理。 @:在可能出错的表达式前面使用@符号即可。 错误抑制符通常在生产环境（上线 ）会用到，在开发的时候不会用：系统本身 最好没有任何错误。 代码示例： &lt;?php // 错误抑制符 $a = 10; $b = 0; $a / $b; @($a / $b); ?&gt; 三目运算符 三目运算：有三个表达式参与的运算（简单的分支结构缩写） 语法格式： 表达式1?表达式2:表达式3; 运算：如果表达式1成立，那么执行表达式2，否则执行表达式3； 注意：如果表达式本身比较复杂，建议使用括号包起来 代码示例： &lt;?php //三木运算符 $a = 10; $b = $a &gt; 10 ? 100 : 0; echo $b; ?&gt; 三木运算可以进行符合三木运算：三木运算中的表达式2和3都可以是另外一个三目运算。 表达式1?(表达式2?表达式4:表达式5):(表达式3?表达式6:表达式7); 自操作运算符 自操作：自己操作自己的运算符 ++:在原来的值上+1 --:在原来的值上-1 在PHP中自操作符是可以放到变量前或者后：前置自操作和后自操作。 后置自操作（a++）：先把自己所保存的值留下来，然后改变自己，自己给别人的值是原来的值。 前置自操作(++a)：先把自己改变，然后把改变后的值给别人。 代码示例： &lt;?php // 自操作符 $a=$b=1; $a++; //独立操作，不参与其他运算 ++$b; //独立操作，不参与其他运算 echo $a,$b; echo &#39;&lt;hr/&gt;&#39;; echo $a++,++$b; //$a和$b不只是独立运算，还参与了输出操作 ?&gt; 衍生符号：类似自操作。 +=:左边的结果与右边的结果相加，然后赋值给左边 -=:左边的减去右边的结果，然后赋值给左边 *=:乘法操作 /=:除法操作 %=:模操作 注意：右边是一个整体，如$a+=$b; =====&gt; $a=$a+($b); 代码示例： &lt;?php $a = 10; $b = 5; $a += $b; //$a=$a+$b=15; $a-=$b-1; //$a=$a-($b-1) echo $a,&#39;&lt;br/&gt;&#39;,$b; ?&gt; 如果进行除法或者取余运算，那么要考虑右边表达式的结果是否为0（为0出错）。 计算机码 计算机码：计算机在实际存储数据的时候，采用的编码规则（二进制规则）计算机码：原码、反码和补码，数值本身最左边一位是用来充当符号位：正数为0，负数为1 原码：数据本身从二进制转换成二进制得到的结果 正数：左边符号位为0（正数的原码、反码、补码就是原码本身） 负数：左边符号位为1 反码：针对负数，符号位不变，其他位取反 补码：针对负数，反码+1 系统中存在两个0：+0和-0+0：00000000-0：10000000 原码取反 11111111补码 00000000 位运算符 位运算：取出计算机中最小的单位（位bit）进行计算 &amp;:按位与，两个位都为1，结果为1，否则为0 |:按位或，两个有一个为1，结果为1 代码示例： &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/9 * Time: 22:22 * Features: 位运算 */ // 位运算 $a = 5; $b = -5; /* * 5原码：00000101 * * * -5原码：10000101 * 取反：11111010 反码：符号位不变，其他位取反 * 求补：11111011 补码：反码+1 */ // 按位与 var_dump($a &amp; $b); /* * 取出系统存储的结果进行与操作 * 5 00000101 * -5 11111011 * &amp; 00000001 //最终结果 * 转换：判断符号位，0表示正数，1表示负数（补码） */ ?&gt; 注意1. 系统进行任何位运算的时候都是使用的补码2. 运算结束之后都必须转换成原码才是最终要显示的数据 ~:按位非，一个位如果为1则变成0，否则反之 代码示例： &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/9 * Time: 22:22 * Features: 位运算 */ // 位运算 $a = 5; $b = -5; /* * 5原码：00000101 * * * -5原码：10000101 * 取反：11111010 反码：符号位不变，其他位取反 * 求补：11111011 补码：反码+1 */ echo &#39;&lt;hr/&gt;&#39;; // 按位非 var_dump(~$b); /* * -5 11111011 补码 * 取反 00000100 * 原码 00000100 */ ?&gt; ^:按位异或，两个相同则为0，不同则为1 &lt;&lt;:按位左移，整个位（32位），向左移动一位，右边补0 &gt;&gt;:按位右移，整个位（32位）向右移动一位，左边补符号位对应内容（正数补0，负数补1） 代码示例： &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/9 * Time: 22:22 * Features: 位运算 */ // 位运算 $a = 5; $b = -5; /* * 5原码：00000101 * * * -5原码：10000101 * 取反：11111010 反码：符号位不变，其他位取反 * 求补：11111011 补码：反码+1 */ echo &#39;&lt;hr/&gt;&#39;; // 按位右移 var_dump($b &gt;&gt; 1); var_dump($b &gt;&gt; 2); /* * -5 11111011 补码 * &gt;&gt;2 11111110 //运算结果：补码 * -1 11111101 //反码 * 取反 1000010 //原码：-2 */ ?&gt; 按位左移：乘以2的操作按位右移：除以2的操作（不完全正确）：整数除2会出现小数 运算符优先级 运算符优先级：在多种运算符同时存在的时候，如何结合运算。 流程控制 流程控制：代码执行的方向。 控制分类 顺序结构：代码从上往下，顺序执行。（代码执行的最基本结构） 分支结构：给定一个条件，同时有多种可执行代码（块），然后会根据条件执行某一段代码。 循环结构：在某个条件控制范围内，指定的代码（块）可以重复执行。 顺序结构 顺序结构：最基本结构，所有代码默认是从上往下依次执行 分支结构 在PHP中 ，分支结构主要有两种：if分支和switch分支 if分支 if：如果的意思，给定一个条件，同时为该条件设置多种（两种 ）情况，然后通过条件判断来实现具体的执行段。 基本语法：if分支PHP也是提供多种方式来实现。 最简if：只有一段代码，但是可以选择是否执行。 if(条件表达式){ //满足条件所要执行的内容; //顺序结构 } 基础if：有两面性，满足条件或者不满足条件都有对应的执行代码。 if(条件表达式){ //满足条件后执行的代码段 }else{ //不满足条件执行的代码段 } 复杂if结构：在判断条件之后，通常就有两种结果：满足或者不满足，在不满足之后还可以再次进行条件判断。 if(条件表示式1){ //满足条件表达式1的代码段 }elseif(条件表达式2){ //不满足表达式1条件，但是满足表达式2的代码 }...//可以使用多个elseif来进行再次条件筛选 else{ //全部不满足要执行的代码 } 注意： 如果条件特别多才会采用复合if形式 如果条件比较单一（同一条件），会采用elseif复合方式 如果判断条件不一致，建议使用嵌套语法（不宜有太多层嵌套：影响代码美观） if分支，适用于所有的条件判断（分支结构）。 代码示例： &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/10 * Time: 23:09 * Features: if分支 */ // 分支结构：if分支 //最简if $day = &#39;weekend&#39;; // 如果是星期天就出去玩 if ($day == &#39;sunday&#39;) { echo &#39;go out&#39;; } // 基本if判断 // 如果是星期天就出去玩，否则上班 if ($day == &#39;sunday&#39;) { echo &#39;go out play&#39;; } else { // 不满足条件 echo &#39;work&#39;; } // 复合if结构 // 如果是星期天就出去玩，否则不能，但是如果是星期六，那么可以在家玩 echo &#39;&lt;hr/&gt;&#39;; $day = &#39;saturday&#39;; if ($day == &#39;sunday&#39;) { echo &#39;go out&#39;; } else { // 包含全部不满足情况 // 重新进行判断 if ($day == &#39;saturday&#39;) { echo &#39;play at home&#39;; } else { echo &#39;work&#39;; } } echo &#39;&lt;hr/&gt;&#39;; if ($day == &#39;sunday&#39;) { echo &#39;go out&#39;; } elseif ($day == &#39;saturday&#39;) { echo &#39;play at home&#39;; } else { echo &#39;work&#39;; } ?&gt; switch分支 switch分支：有一组情形存在，同过一条件，通常有多个值，但是每一个值都会有对应不同的代码执行。 switch判断方式：是将条件放到分支结构内部判断 switch基本语法： switch(条件表达式){ // 所有条件判断：逐个进行 case 值1: //当前条件表达式的结果与值1相等（==） 要执行的代码段; break; //在switch中，如果条件匹配成功，那么系统就不会再次匹配条件，会自动顺序执行向下的所有代码（case代码除外），需要中断执行：break表示中断switch（结束） case 值2: 要执行的代码段; break; .... //可以使用类似else的语法：都不匹配 default: //匹配失败的代码 break; } 代码示例： &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/10 * Time: 23:30 * Features: switch 分支 */ //switch分支 // 根据日期做不同的事情 $day=1; //从1到7做不同的事情 switch ($day){ //$day条件一定是个具体的值 case 1: //$day==1 echo &#39;1&#39;; break; case 2: echo &#39;2&#39;; break; case 3: echo &#39;3&#39;; break; case 4: echo &#39;4&#39;; break; case 5: echo &#39;5&#39;; break; default: echo &#39;error&#39;; break; } ?&gt; if和switch的选择 if能做所有的分支结构事情 switch处理的是条件比较多，同时比较单一，而且是固定值匹配的分支结构 循环结构 循环结构：代码段在一定的控制下，可以多次执行。 在PHP中循环结构有以下几种： for循环：通过条件、起始和终止判断执行 while循环：通过判断条件终止 do-while循环：跟while差不多 foreach循环：专门针对数组 for循环for循环基本语法 for(条件表达式1;条件表达式2;条件表达式3){ // 条件表达式1：定义初始化条件，可以有多种赋值语句存在，使用逗号分隔即可 // 条件表达式2：边界判定，限定循环执行的次数 // 条件表达式3：用来执行条件变化 // 循环体 } for循环执行原理： 执行条件表达式1：定义初始化条件（执行依次）。 执行条件表达式2：判断条件（N次）。2.1. 满足条件：执行循环体。2.2. 不满足条件：循环结束。 执行循环体：（N次）。 执行条件表达式3：循环变量变化（N次）。 执行条件表达式2：判断条件（N次）。 重复执行3-4-2步骤：直到第2步不满足条件结束循环。 for循环中条件表达式1的多变量定义： 代码示例： &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/11 * Time: 15:07 * Features: for循环 */ // 循环结构：for循环 // 从1到10输出：初始为1，结果为10 for ($i = 1; $i &lt;= 10; $i++) { // 输出 echo $i,&#39;&lt;br/&gt;&#39;; } // 最后：$i=11 echo $i; &lt;?php echo &#39;&lt;hr&gt;&#39;; // 从1到10输出（10通常是动态得到的） for ($i = 1, $end = 10; $i &lt;= $end; $i++) { // 输出 echo $i, &#39;&lt;br/&gt;&#39;; } ?&gt; for循环特殊使用：for循环中对应的括号（条件）可以一个都没有—》(死循环)。一定要避免出现 代码示例： &lt;?php // 无条件for循环 for (;;){ echo &#39;hello world&#39;,&#39;&lt;br/&gt;&#39;; } ?&gt; while循环while循环基本语法： 条件初始化 while(条件表达式){ // 条件表达式就是判断边界条件 循环体; //循环条件的变化 } for与while的选择： 如果是基于固定已知条件（数值而且有规律的变化），使用for循环 while可以做灵活的条件判定（while用的比较多） 代码示例： &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/11 * Time: 15:30 * Features: while循环 */ // while循环 //定义条件 $i=1; // 循环判定执行 while ($i&lt;=10){ //循环体 echo $i++,&#39;&lt;br/&gt;&#39;; // 循环条件变更 // $i++; } ?&gt; do-while循环 do-while：看着很像while，while首先进行条件判定然后执行循环体，有可能出现第一次就条件不满足，那么就会直接失败（循环体一次都不执行）。do-while就是先干了再说（执行循环体），后判断条件。（至少会执行一次循环体） do-while基本语法： do{ // 循环体 }while(条件表达式); 代码示例： &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/11 * Time: 15:37 * Features: do-while循环 */ // do-while循环结构 // 输出1到10之间的偶数（条件判定加入） // 定义基础条件 $i = 1; // 循环判定 do { // 执行输出 if ($i % 2 != 1){ // 是偶数 echo $i,&#39;&lt;br/&gt;&#39;; //条件变更 } //条件变更 $i++; }while($i&lt;=10); ?&gt; 循环控制 循环控制：在循环内部对循环本身进行控制 中断控制：重新开始循环，循环体中还有其他内容，也再执行 continue层级； //默认是1（循环可以多层嵌套） 终止控制：循环直接结束 break层级； //默认是1 代码示例： &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/11 * Time: 15:50 * Features: 循环控制 */ // 循环控制 // 需求：输出1到100之间5的倍数 $i=1; while ($i&lt;=100){ // 判断:是否是5的倍数 if ($i%5!=0){ // 说明当前$i不是5的倍数 //重新循环 $i++; //重新循环 // continue; //系统重新跳到循环开始处 //终止循环 break; } // 输出数值 echo $i++,&#39;&lt;br/&gt;&#39;; } echo $i; ?&gt; 因为循环经常性会碰到嵌套（循环中间包含循环），如果再循环内部有些条件下，明确可以直到当前循环（或者说外部循环）不需要继续执行了，那么就是可以使用循环控制来实现：其中内部循环也可以控制到外部，就是通过使用层级参数。 continue 2; //当前自己循环后面内部不再执行，同时外部循环如果还有循环体也不再执行，重新来过； break2; //当前自己循环结束，同时外部也结束（如果还有外部影响，继续执行） 流程控制替代语法 流程控制替代语法：分支和循环结构的替代语法 PHP本身是嵌入到HTML中的脚本语言，需要再HTML中书写一些关于判断或者循环的结构语法，必须符合PHP标签规范，需要HTML与PHP进行混搭，如果使用原始的PHP代码那么会非常不美观。 需求：打印一个九九乘法表，使用表格展示。 在PHP书写到HTML中的这些大括号{}非常不美观，所以PHP提供了一种替代机制，让其可以不用书写大括号： for(;;){ } ----&gt;for(;;): endfor 代码示例： &lt;table border=1&gt; &lt;?php for ($i = 1; $i &lt; 10; $i++) { ?&gt; &lt;tr&gt; &lt;?php for ($j = 1; $j &lt;= $i; $j++) { ?&gt; &lt;td&gt; &lt;?php echo $i . &#39;*&#39; . $j . &#39;=&#39; . $i * $j; ?&gt; &lt;/td&gt; &lt;?php } ?&gt; &lt;/tr&gt; &lt;?php } ?&gt; &lt;/table&gt; &lt;table border=1&gt; &lt;?php for ($i = 1; $i &lt; 10; $i++) :?&gt; &lt;tr&gt; &lt;?php for ($j = 1; $j &lt;= $i; $j++) : ?&gt; &lt;td&gt; &lt;?php echo $i . &#39;*&#39; . $j . &#39;=&#39; . $i * $j; ?&gt; &lt;/td&gt; &lt;?php endfor; ?&gt; &lt;/tr&gt; &lt;?php endfor ?&gt; &lt;/table&gt; PHP中具体有哪些替代语法呢？PHP应该在HTML中只做数据输出，输出通常伴有条件判断和循环操作，因此PHP提供了对应分支结构和循环结构的替代方法：全部都是对应的一个模式： 左大括号{使用冒号代替； 右大括号}使用end+对应的其实标记替代； if:if(): endif; switch:switch(): endswitch; for:fot(): endfor while:while(): endwhile foreach:foreach(): endforeach 文件包含 文件包含：在一个PHP脚本中，去将另外一个文件（PHP）包含进来，去合作完成一件事情。 文件包含的作用文件包含的意义： 要么使用被包含文件中的内容，实现代码的共享（重用）：向上包含（索要） 向上包含：在当前脚本要用某个代码之前包含别的文件 要么自己有东西可以给别的文件使用，实现代码的共享（重用）：向下包含（给予） 向下包含：在自己有某个东西的时候，需要别的脚本来显示（自己代码写完之后包含其他文件） 最大的作用：分工协作，每个脚本做的事情不一样，因此可以使用写作方式，让多个脚本共同完成一件事情。 文件包含四种形式在PHP中问之间的包含有四种形式（两大形式） include:包含文件 include_once:系统会自动判断文件包含过程中，是否已经包含过（一个文件最多被包含一次） require:与include相同 require_once:以include_once相同 包含基本语法： include &#39;文件名字&#39;; include(&#39;文件名字&#39;); //文件名字：路径问题 代码示例： include1.php &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/13 * Time: 20:36 * Features: 文件包含 */ //被包含文件 //定义数据 $a=1; define(&#39;PI&#39;,3.14); ?&gt; include2.php &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/13 * Time: 20:37 * Features: 文件包含 */ //包含文件：使用数据 //包含文件 include &#39;include1.php&#39;; //包含当前文件include2.php所在文件夹下的include1.php echo $a,PI; ?&gt; 以上方式：是先包含文件，后使用文件中的内容（向上包含）。 向下包含：先准备内容，然后包含另外的文件，在另外的文件中，使用当前的内容。 代码示例： include3.php &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/13 * Time: 20:46 * Features: 文件包含 */ //定义数据 $a = 10; const PI = 3.14; //包含文件：为了显示以上数据 include_once &#39;include4.php&#39;; ?&gt; include4.php &lt;table&gt; &lt;tr&gt; &lt;td&gt;&lt;?php echo $a; ?&gt;&lt;/td&gt; &lt;td&gt;&lt;?php echo PI; ?&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 文件加载原理PHP代码的执行流程： 读取代码文件（PHP程序） 编译：将PHP代码转换成字节码（生成opcode） zendengine来解析opcode，按照字节码去进行逻辑运算 转换成对应的HTML代码 文件加载原理： 在文件加载（include或者require）的时候，系统会自动地将被包含文件中的代码相当于嵌入到当前文件中。 加载位置：在哪加载，对应的文件中的代码嵌入的位置就是对应的include位置。 在PHP中被包含的文件是单独进行编译的 PHP文件在编译的过程中如果出现了语法错误，那么会失败（不会执行）：但是如果被包含文件有错误的时候，系统会执行到包含include这条语句的时候才会报错。 include和require区别 include和include_once的区别： include系统会碰到一次，执行一次；如果对同一文件进行多次加载，那么系统会执行多次；include_once：系统碰到多次，也只会执行一次。 require和include的区别： 本质都是包含文件，唯一的区别在于包含不到文件的时候，报错的形式不一样。 include的错误级别比较轻：不会阻止代码执行。require要求较高：如果包含出错代码不再执行（require后面的代码） 文件加载路径文件在加载的时候需要指定文件路径才能保证PHP正确的找到对应的文件。 文件的加载路径包含两大类： 绝对路径 从磁盘的根目录开始（本地绝对路径 ） Windows ：盘符C：/路径/PHP文件 Linux：/路径/PHP文件 从网站根目录开始（网络绝对路径） /：相对于网站主机名字对应的路径 localhost/index.php-&gt;E:/server/apache/htdocs/index.php 相对路径:从当前文件所在目录开始的路径 .|./：当前文件夹 ../：上级目录（当前文件夹的上一层文件夹） 绝对路径和相对路径的加载区别： 绝对路径相对效率偏低，但是相对安全（路径不会出问题） 相对路径相对效率高些，但是容易出错（相对路径会发生改变） 文件嵌套包含 文件嵌套包含 ：一个文件包含另外一个文件，同时被包含的文件又包含了另外一个文件。 代码示例： include3.php &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/13 * Time: 20:46 * Features: 文件包含 */ //定义数据 $a = 10; const PI = 3.14; //包含文件：为了显示以上数据 include_once &#39;include4.php&#39;; ?&gt; include4.php &lt;table&gt; &lt;tr&gt; &lt;td&gt;&lt;?php echo $a; ?&gt;&lt;/td&gt; &lt;td&gt;&lt;?php echo PI; ?&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; include6.php &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/14 * Time: 14:58 * Features: 文件嵌套包含 */ // 文件嵌套包含 // 包含include3.php 文件本身包含了include4.php include &#39;../../chap08/sec02/include3.php&#39;; ?&gt; 嵌套包含的时候就很容易出现相对路径出错的问题：相对路径会因为文件的包含而改变（./和../）：Windows下面，每一个文件夹下都有.和..的文件夹。 函数函数的基本概念 函数：function，是一种语法结构，将实现某一个功能的代码块（多行代码）封装到一个结构中，从而实现代码的重复利用（复用）。 函数定义语法函数有几个对应的关键点：function关键字、函数名、参数（形参和实参）、函数体和返回值。 基本语法如下： function 函数名(参数){ // 参数体 //返回值：return结果 } 定义函数的目的：是为了实现代码的重复利用，一个功能一个函数（简单明了）。 函数的使用：通过访问函数的名字+(),如果函数在定义的过程中有参数，那么在调用的时候就必须传入对应的参数。函数是一种结构不会自动运行，必须通过调用才会执行。 代码示例： &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/14 * Time: 15:31 * Features: 函数 */ // 函数 // 定义函数 function display() { // 函数体 echo &#39;hello world&#39;; //没有返回值 } //调用函数 display(); ?&gt; 函数实在代码执行阶段，碰到函数名字的时候才会调用，不是在编译阶段。 函数的调用特点：只要系统在内存中能够找到对应的函数，就可以执行（函数的调用可以在函数定义之前）。 函数执行的内存分析： 读取代码进入到代码段（编译：将代码变成字节码存储到内存） 根据代码逐行执行 以上原因：编译和执行是分开的（先编译后执行） 函数命名规范 命名规范：由字母、数字和下划线组成，但是不能以数字开头。 函数作为一种常用的结构，一般遵循以下原则：函数通常名字代表着函数的功能，而有些功能会比较复杂，可能一个单词不足以表达，需要多个组合。 驼峰法：除了左边第一个单词外，后面所有的单词首字母都大写。 下划线法：单词之间通过下划线连接，单词都是小写。 函数名字：在一个脚本周期中，不允许出现同名函数（通常在一个系统开发中都不会使用同名函数）。 参数详解函数的参数分为两种：形参和实参 形参形参：形式参数，不具有实际意义的参数，是在函数定义使用的参数。 实参实参：实际参数，具有实际数据意义的参数，是在函数调用时使用的参数。 形参是实参的载体：实参在调用时通常是需要传入到函数内部参与计算（运算），那么需要在函数内部去找到实际数据所在的位置才能找到数据本身：选哟实际调用的时候，将数据以实参的形式传递给形参：给形参赋值，从而使得函数内部可以用到外部数据。 代码示例： &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/14 * Time: 16:23 * Features: 函数参数 */ // 函数参数 // 定义函数 function add($arg1, $arg2) { //形参可以有多个，使用逗号分隔即可 //函数体：可以直接使用形参运算 echo $arg1 + $arg2; } // 调用函数 $num1 = 10; add($num1, 20); //传入得实参，可以是变量或者其他有值地表达式（变量、常量、运算符计算结果） ?&gt; 注意 在PHP中允许实参多余形参（个数）：函数内部不用而已 在PHP中理论上形参个数没有限制（实际开发不会太多） 实参不能少于形参个数 默认值 默认值：default value，指的是形参的默认值，在函数定义的时候，就给形参进行一个初始赋值：如果实际调用传入的参数（实参）没有提供，那么形参就会使用定义时的值来进入函数内部参与运算。 通常默认值是用在一些，一定会有某个数据参与，但是不可能通常是某个我们知道的值。 代码示例： &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/14 * Time: 16:23 * Features: 函数参数 */ // 函数参数 // 定义函数 function add($arg1, $arg2) { //形参可以有多个，使用逗号分隔即可 //函数体：可以直接使用形参运算 echo $arg1 + $arg2; } // 调用函数 $num1 = 10; add($num1, 20); //传入得实参，可以是变量或者其他有值地表达式（变量、常量、运算符计算结果） // 函数的默认值 function jian($num1 = 0, $num2 = 0) //当前$num1是形参，在编译时不执行，即便执行也是在jian函数内部，不会与外部的$num1变量冲突 { echo $num1 - $num2; } // 调用：默认值如果存在，可以不用传入 jian($num1); echo $num1; ?&gt; 注意事项 默认值的定义是放在最右边的（多个），不能左边形参有默认值，但是右边没有 函数外部定义的变量名字与函数定义的形参名字冲突（同名）是没有任何关联关系的，如果多个函数使用同样的形参名字也不冲突。 引用传值实参在调用时会将值赋值给形参，那么实际上使用的方式就是一种简单的值传递：将实参（如果是变量或者常量或者其他表达式）的结果（值）取出来赋值给形参：形参参与外部实际传入的参数本身没有任何关联关系：只是结果一样。 有的时候，希望在函数内部拿到的外部数据，能够在函数内部改变，那么就需要明确告知函数（定义时），函数才会调用的时候去主动获取外部数据的内存地址。以上这种定义形式参数的方式叫做引用传值。 基本语法： function 函数名(形参1，形参2){ //函数体 } 在调用的时候，必须给引用传值的参数位置传入实际参数，而且参数本身必须是变量。（变量才有指向的数据的内存地址） 代码示例： &lt;?php // 引用传值 function display($a, &amp;$b) { //修改形参的值 $a = $a * $a; $b = $b * $b; echo &#39;&lt;hr&gt;&#39;, $a, &#39;&lt;br/&gt;&#39;, $b, &#39;&lt;br/&gt;&#39;; } //定义变量 $a = 10; $b = 5; //调用函数 display($a, $b); echo &#39;&lt;hr&gt;&#39;, $a, &#39;&lt;br/&gt;&#39;, $b, &#39;&lt;br/&gt;&#39;; //错误调用：引用传值直接传入数据本身而不是变量 // display(10, 5); ?&gt; 注意事项：在传入实参的时候，必须传入变量。 函数体 函数体：函数内部（大括号{}里面的）的所有代码都称之为函数体。函数体：基本上所有的代码都可以实现 定义变量 定义常量 使用流程控制（分支、循环） 可以调用函数 函数返回值 返回值：return，指的是将函数实现的结果，通过return关键字，返回给函数外部（函数调用处）：在PHP中所有的函数都有返回值。（如果没有明确return使用，那么系统默认返回NULL） 返回值作用：将计算结果返回给调用处。 代码示例： &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/15 * Time: 14:36 * Features: 函数返回值 */ // 函数返回值 // 定义函数 function display() { //输出 echo __FUNCTION__; //输出当前函数名字 } var_dump(display()); // 加法运算 function add($num1, $num2) { return $num1 + $num2; //返回结果 //输出 echo $num1; } $res = add(10, 20); //外部定义变量接收函数运行结果 echo $res; ?&gt; 注意：函数的返回值可以是任意数据类型。 return关键字： return在函数内部存在的价值：返回当前函数的结果（当前函数运行结束）。 return还可以在文件中直接使用（不在函数里面）：代表文件将结果return后面跟的内容转交给包含当前文件的位置。（通常在系统配置文件中使用较多），在文件中也代表终止文件后面的代码“return之后的内容不会执行了。 作用域 作用域：变量（常量）能够被访问的区域 变量可以在普通代码中定义 变量也可以在函数内部定义 在PHP中作用域严格来说分为两种：但是PHP内部还定义一些在严格意义之外的一种，所以总共算三种： 全局变量：就是用户普通定义的变量（函数外部定义） 所属全局空间：在PHP中只允许在全局空间使用：理论上函数内部不可访问 脚本周期：直到脚本运行结束（最后一行代码执行完） 局部变量：就是在函数内部定义的变量 所属当前函数空间：在PHP中只允许在当前函数自己内部使用 函数周期：函数执行结束（函数是在栈区中开辟独立内存空间运行） 超全局变量：系统定义的变量（预定义变量： $_SERVER、$_POST等） 所属超全局空间：没有访问限制（函数内外都可以访问） 超全局变量会将全局变量自动纳入到$GLOBALS没有作用域限制，所以能够帮助局部变量去访问全局变量：但是必须使用数组方式。 如果想函数内部使用外部变量：除了$GLOBALS之外，通过参数传值（如果要统一战线还可以使用引用传值）。 在PHP中，其实还有一种方式，能够实现全局访问局部，同时局部也可以访问全局：global关键字。 global关键字：是一种在函数里面定义变量的一种方式。 如果使用global定义的变量名外部存在（全局变量），那么系统在函数内部定义的变量直接指向外部全局变量所指向的内存空间（同一个变量）； 如果使用global定义的变量名在外部不存在（全局变量），系统会自动在全局空间（外部）定义一个与局部变量同名的全局变量 本质的形式：在函数的内部和外部，对一个同名变量（全局和局部）使用同一块内存地址保存数据，从而实现共同拥有。 基本语法： global 变量名; //不能赋值 变量名=值; //修改 代码示例： &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/15 * Time: 16:02 * Features: 作用域 */ // PHP中作用域 // 默认的代码空间:全局空间 $global = &#39;global area&#39;; //最终会被系统纳入到超全局空间中:$GLOBALS[]=global area //局部变量(函数内部定义) function display() { //所有的形参都可以理解为局部变量 $inner = __FUNCTION__; //局部变量 //访问全局变量 echo $global; //不能访问 echo &#39;&lt;hr&gt;&#39;; // 访问全局变量 // var_dump($GLOBALS); echo $GLOBALS[&#39;global&#39;]; echo &#39;&lt;hr&gt;&#39;; //定义变量:使用全局变量 global $global; //全局空间存在 echo $global; echo &#39;&lt;hr&gt;&#39;; //定义变量:全局不存在 global $local; $local = &#39;inner&#39;; } // 调用函数 display(); //全局空间访问局部变量 echo $inner; //不能访问 echo &#39;&lt;hr&gt;&#39;; //访问&quot;局部&quot;变量 echo $local; echo &#39;&lt;hr&gt;&#39;; ?&gt; 虽然以上方式可以实现局部与全局的互访，但是通常不会这么使用。一般如果会存在特殊使用，也会使用参数的形式来访问（还可以使用常量：define定义的）。 静态变量 静态变量：static，实在函数内部定义的崇拜能量，使用static关键字修饰，用来实现跨函数共享数据的变量：函数玉兴结束所有局部变量都会清空，如果重新运行函数，所有的局部变量又会重新初始化。 基本语法： function 函数名(){ //定义变量 static $变量名=值; //通常会在定义的时候就直接赋值 } 静态变量的作用是为了跨函数共享数据（同一个函数被多次调用）。 静态变量的原理：系统在进行编译的时候就会对static这一行进行初始化：为静态变量赋值，函数在调用的时候，会自动跳过static关键字这一行。 静态变量的使用： 为了统计：当前函数被调用的次数 为了统筹函数多次调用得到的不同结果（递归思想） 代码示例： &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/15 * Time: 22:14 * Features: 静态变量 */ // 静态变量 // 定义函数 function display() { //定义变量 $local = 1; //局部变量 //定义静态变量 static $count = 1; //静态变量 echo $local++, $count++, &#39;&lt;br/&gt;&#39;; } //调用 display(); display(); display(); display(); ?&gt; 可变函数 可变函数：当前有一个变量所保存的值，刚好是一个函数的名字，那么就可以使用变量+()来充当函数名使用。 代码示例： &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/15 * Time: 22:28 * Features: 可变函数 */ // 可变函数 // 定义函数 function display() { echo __LINE__, __FUNCTION__; } //定义变量 $func = &#39;display&#39;; //可变函数 $func(); ?&gt; 可变函数在系统使用的过程中还是比较多的，尤其是使用很多系统函数的时候：需要用户在外部定义一个自定义函数，但是是需要传入到系统函数内部使用。 代码示例： &lt;?php // 定义系统函数（假设） function sys_function($arg1, $arg2) { // 给指定的函数（第一个参数），求对应的第二个参数值得4次方 //为实际用户输入的数值进行处理 $arg2 = $arg2 + 10; return $arg1($arg2); } //定义一个用户函数：求一个数的四次方 function user_function($num) { //将一个用户定义的函数传入给另外一个函数（函数名）去使用的过程，称之为回调过程，而被传入的函数称之为回调函数 return $num * $num * $num * $num; } // 求10的4次方 echo sys_function(&#39;user_function&#39;,10); ?&gt; 匿名函数基本概念 匿名函数：没有名字的函数 基本语法： 变量名=function(){ 函数体 }; 代码示例： &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/15 * Time: 23:03 * Features: 匿名函数 */ // 匿名函数 // 定义基本匿名函数 $func = function () { //函数体 echo &#39;hello world&#39;; }; // 调用匿名函数：可变函数 $func(); ?&gt; 变量保存匿名函数，本质得到的是一个对象（closure）。 代码示例： &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/15 * Time: 23:03 * Features: 匿名函数 */ // 匿名函数 // 定义基本匿名函数 $func = function () { //函数体 echo &#39;hello world&#39;; }; // 调用匿名函数：可变函数 $func(); // 查看变量内容 var_dump($func); ?&gt; 闭包 闭包：closure，一词来源于以下两者的结合：要执行的代码块（由于自由变量被包含在代码块中，这些自由变量以及他们引用的对象没有被释放）和为自由变量提供绑定的计算环境（作用域）。 简单理解：函数内部有一些局部变量（要执行的代码块）在函数执行之后没有被释放，是因为在函数内部还有对应的函数在引用（函数的内部函数：匿名函数）。 代码示例： &lt;?php // 闭包函数 function display() { // 定义变量：局部变量 $name = __FUNCTION__; // 定义匿名函数 $innerfunction = function () use ($name) { //use就是将外部变量（局部）保留给内部使用（闭包） //函数内部的函数 echo $name; }; // 调用函数 $innerfunction(); } display(); ?&gt; 证明：函数的局部变量在函数使用完之后没有被释放？ 使用内部匿名函数 匿名函数使用局部变量：use 匿名函数被返回给外部使用 代码示例： &lt;?php // 闭包函数 function display() { // 定义变量：局部变量 $name = __FUNCTION__; // 定义匿名函数 $innerfunction = function () use ($name) { //use就是将外部变量（局部）保留给内部使用（闭包） //函数内部的函数 // echo $name; }; // 调用函数 $innerfunction(); } display(); echo &#39;&lt;hr&gt;&#39;; function display1() { // 定义变量：局部变量 $name = __FUNCTION__; // 定义匿名函数 $innerfunction = function () use ($name) { //use就是将外部变量（局部）保留给内部使用（闭包） //函数内部的函数 echo $name; }; // 返回内部匿名函数 return $innerfunction; } $closure = display1(); //到66行位置：display1函数运行结束：理论上局部变量$name应该已经被释放 $closure(); ?&gt; 伪类型 伪类型：假类型，实际上在PHP中不存在的类型。但是通过伪类型可以帮助程序员去更好的查看操作手册从而方便学习。 伪类型主要有两种：在三大类八小类之外。 mixed：混合的，可以是多种给PHP中的数据类型 number：数值的，可以是任意数值类型（整型和浮点型） 常用系统函数有关输出的函数 print():类似于echo输出提供的内容，本质是一种结构（不是函数）,返回1，可以不需要使用括号。 print_r():类似于var_dump，但是比var_dump简单，不会输出数据的类型，只会输出值（数组打印使用比较多）。 代码示例： &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/13 * Time: 15:02 * Features: 系统函数 */ // 系统函数 //输出相关 echo print (&#39;hello world&lt;br/&gt;&#39;); print &#39;hello world&lt;br/&gt;&#39;; $a=&#39;hello world&lt;br/&gt;&#39;; print_r($a); ?&gt; 有关时间的函数date():按照指定格式对应的时间戳（从1970年格林威治时间开始计算的秒数），如果没有指定特定的时间戳，那么就是默认解释当前时间戳。time():获取当前时间对应的时间戳microtime():获取微秒级别的时间strtotime():按照规定格式的字符串转换成时间戳。 代码示例： &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/13 * Time: 15:02 * Features: 系统函数 */ // 系统函数 // 时间函数 echo date(&#39;Y 年 m 月 d 日 H:i:s&#39;, 12345678), &#39;&lt;hr/&gt;&#39;; echo time(), &#39;&lt;hr/&gt;&#39;; echo microtime(), &#39;&lt;hr/&gt;&#39;; echo strtotime(&quot;now&quot;), &quot;\\n&quot;; echo strtotime(&quot;10 September 2000&quot;), &quot;\\n&quot;; echo strtotime(&quot;+1 day&quot;), &quot;\\n&quot;; echo strtotime(&quot;+1 week&quot;), &quot;\\n&quot;; echo strtotime(&quot;+1 week 2 days 4 hours 2 seconds&quot;), &quot;\\n&quot;; echo strtotime(&quot;next Thursday&quot;), &quot;\\n&quot;; echo strtotime(&quot;last Monday&quot;), &quot;\\n&quot;; ?&gt; 有关数学的函数max():指定参数中最大的值min():比较两个数中较小的值rand():得到一个随机数，指定区间的随机整数mt_rand:与rand一样，只是底层结构不一样，效率比rand高（建议使用）round():四舍五入cell():向上取整floor():向下取整pow():求指定数字的指定指数次结果abs():绝对值sqrt():求平方根 代码示例： &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/16 * Time: 13:30 * Features: 有关数学的函数 */ echo max(1, 3, 5, 6, 7); // 7 echo max(array(2, 4, 5)); // 5 // When &#39;hello&#39; is cast as integer it will be 0. Both the parameters are equally // long, so the order they are given in determines the result echo max(0, &#39;hello&#39;); // 0 echo max(&#39;hello&#39;, 0); // hello echo max(&#39;42&#39;, 3); // &#39;42&#39; // Here 0 &gt; -1, so &#39;hello&#39; is the return value. echo max(-1, &#39;hello&#39;); // hello // With multiple arrays of different lengths, max returns the longest $val = max(array(2, 2, 2), array(1, 1, 1, 1)); // array(1, 1, 1, 1) // 对多个数组，max 从左向右比较。 // 因此在本例中：2 == 2，但 4 &lt; 5 $val = max(array(2, 4, 8), array(2, 5, 7)); // array(2, 5, 7) // 如果同时给出数组和非数组作为参数，则总是将数组视为 // 最大值返回 $val = max(&#39;string&#39;, array(2, 5, 7), 42); // array(2, 5, 7) echo &#39;&lt;hr&gt;&#39;; echo min(2, 3, 1, 6, 7); // 1 echo min(array(2, 4, 5)); // 2 echo min(0, &#39;hello&#39;); // 0 echo min(&#39;hello&#39;, 0); // hello echo min(&#39;hello&#39;, -1); // -1 // 对多个数组，min 从左向右比较。 // 因此在本例中：2 == 2，但 4 &lt; 5 $val = min(array(2, 4, 8), array(2, 5, 1)); // array(2, 4, 8) // 如果同时给出数组和非数组作为参数，则不可能返回数组，因为 // 数组被视为最大的 $val = min(&#39;string&#39;, array(2, 5, 7), 42); // string echo &#39;&lt;hr&gt;&#39;; echo rand() . &quot;\\n&quot;; echo rand() . &quot;\\n&quot;; echo rand(5, 15); echo &#39;&lt;hr&gt;&#39;; echo mt_rand() . &quot;\\n&quot;; echo mt_rand() . &quot;\\n&quot;; echo mt_rand(5, 15); echo &#39;&lt;hr&gt;&#39;; echo round(3.4); // 3 echo round(3.5); // 4 echo round(3.6); // 4 echo round(3.6, 0); // 4 echo round(1.95583, 2); // 1.96 echo round(1241757, -3); // 1242000 echo round(5.045, 2); // 5.05 echo round(5.055, 2); // 5.06 echo &#39;&lt;hr&gt;&#39;; echo ceil(4.3); // 5 echo ceil(9.999); // 10 echo ceil(-3.14); // -3 echo &#39;&lt;hr&gt;&#39;; echo floor(4.3); // 4 echo floor(9.999); // 9 echo floor(-3.14); // -4 echo &#39;&lt;hr&gt;&#39;; var_dump(pow(2, 8)); // int(256) echo pow(-1, 20); // 1 echo pow(0, 0); // 1 echo pow(-1, 5.5); // PHP &gt;4.0.6 NAN echo pow(-1, 5.5); // PHP &lt;=4.0.6 1.#IND echo &#39;&lt;hr&gt;&#39;; $abs = abs(-4.2); // $abs = 4.2; (double/float) $abs2 = abs(5); // $abs2 = 5; (integer) $abs3 = abs(-5); // $abs3 = 5; (integer) echo $abs, $abs2, $abs3; echo &#39;&lt;hr&gt;&#39;; // Precision depends on your precision directive echo sqrt(9); // 3 echo sqrt(10); // 3.16227766 ... ?&gt; 有关函数的函数function_exists():判断指定的函数名字是否在内存中存在（帮助用户不去使用一个不存在的函数，让代码安全性更高）func_get_arg():在自定义函数中去获取指定数值对应的参数func_get_args():在自定义函数中获取所有的参数（数组）func_num_args():获取当前自定义函数的参数数量 代码示例： &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/16 * Time: 13:38 * Features: 有关函数的函数 */ //函数相关的函数 echo &#39;&lt;pre&gt;&#39;; function test($a, $b) { //获取指定参数 var_dump(func_get_arg(1)); //获取所有参数 var_dump(func_get_args()); //获取参数数量 var_dump(func_num_args()); } //调用函数 function_exists(&#39;test&#39;) &amp;&amp; test(1, &#39;2&#39;, 3, 4); ?&gt; 错误处理 错误处理：指的是系统（或者用户）在对某些代码执行的时候，发现有错误，就会通过错误处理的形式告知程序员。 错误分类 语法错误：用户书写的代码不符合PHP的语法规范，语法错误会导致代码在编译过程中不通过，所以代码不会执行（Parse error） 运行时错误：代码编译通过，但是代码在执行的过程中会出现一些条件不满足导致的错误（runtime error） 逻辑错误：程序员在写代码的时候不规范，出现了一些逻辑性的错误，导致代码正常执行，但是得不到想要的结果 错误代号所有看到的错误代码在PHP中都被定义成了系统常量（可以直接使用） 系统错误： E_PARSE：编译错误，代码不会执行 E_ERROT：fatal error，致命错误，会导致代码不能正确继续执行（出错的位置断掉） E_WARNING：warning，警告错误，不会影响代码执行，但是可能得到意想不到的结果 E_NOTICE：notice，通知错误，不会影响代码执行 用户错误： E_USER_ERROR E_USER_WARNING E_USER_NOTICE用户在使用自定义错误触发的时候，会使用到的错误代号（系统不会用到） 其他： E_ALL代替着所有从错误（通常在进行错误控制的时候使用比较多），建议在开发过程中（开发环境）使用 所有以E开头的错误常量（代号）其实都是由一个字节存储，然后每一种错误占据一个对应的位，如果想进行一些错误的控制，可以使用位运算进行操作。 排除通知级别notice:E_ALL &amp; ~E_NOTICE 只要警告和通知：E_WARNING｜E_NOTICE 错误触发 程序运行时触发：系统自动根据错误发生后，对比对应的错误信息，输出给用户：主要针对代码的语法错误和运行时错误。 人为触发：知道某些逻辑可能会出错，从而使用对应的判断代码来触发相应的错误提示 代码示例： &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/16 * Time: 14:13 * Features: 错误处理 */ // 错误处理 // 处理脚本让浏览器按照指定字符集解析的方法 header(&#39;Content-type:text/html;charset=utf-8&#39;); //书写代码 // $a = 100 $a = 100; echo $a; // 除法运算 $b = 0; if ($b == 0) { // 人为触发错误 trigger_error(&#39;除数不能为0&#39;); //默认notice，会继续执行 trigger_error(&#39;除数不能为0&#39;,E_USER_ERROR); //默认error，代码不会执行 } echo $a / $b; echo &#39;hello&#39;; ?&gt; 错误显示设置 错误显示设置：哪些错误该显示，以及如何显示 在PHP中，其实有两种方式来设置当前脚本的错误处理 PHP的配置文件：全局配置：php.ini display-errors:是否显示错误 errod_reporting:显示什么级别的错误 可以在运行的PHP脚本中去设置：在脚本中定义的配置项级别比配置文件高（通常在开发当中都会在代码中去进行控制和配置） error-reporting：设置对应的错误显示级别 ini_set(&#39;配置文件中的配置项&#39;,&#39;配置值&#39;) ini_set(&#39;error_reporting&#39;,E_ALL) ini_set(&#39;display_errors&#39;,1) 错误日志设置在实际生产环境中，不会直接让错误赤裸裸的展示给用户： 不友好 不安全：错误会暴露网站很多信息（路径、文件名） 所以在生产环境中，一般不会显示错误（错误也比较少），但是不可能避免会出现错误（测试的时候不会发现所有问题），这个时候不希望看到，但是有希望捕捉到可以让后台程序员去修改：需要保存到日志文件中，需要在PHP配置文件中或者代码中（ini_set）设置对应error_log配置项。 开启日志功能：log_errors=On 指定路径:error_log=XXXXX 自定义错误处理最简单的错误处理：trigger_errors()函数，但是该函数不会阻止系统报错 PHP系统提供了一种用户处理错误的机制：用户自定义错误处理函数，然后将该函数增加到系统错误处理的句柄中，然后系统会在碰到错误之后，使用用户定义的错误函数。 如何将用户自定义的函数放到系统中？set-error_handler() 自定义错误处理函数，系统有要求 代码实现： 自定义错误处理函数：注意参数 注册自定义函数：修改错误处理机制 代码示例： &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/16 * Time: 14:51 * Features: 自定义错误处理机制 */ // 自定义错误处理机制 // 自定义函数 /* * @param1 $errno,是系统提供的错误代码：E_ALL，E_NOTICE... */ function myerrors($errno, $errstr, $errorfile, $errorline) { // 判断：当前会碰到错误有哪些 if (!(error_reporting() &amp; $errno)) { //error_reporting没有参数代表获取当前系统错误处理对应的级别 return false; } // 开始判断错误类型 switch ($errno) { case E_ERROR: case E_USER_ERROR: echo &#39;fatal error in file &#39; . $errorfile . &#39;on line&#39; . $errorline . &#39;&lt;br/&gt;&#39;; echo &#39;error info:&#39; . $errstr; break; case E_WARNING: case E_USER_WARNING: echo &#39;Warning error in file &#39; . $errorfile . &#39;on line&#39; . $errorline . &#39;&lt;br/&gt;&#39;; echo &#39;error info:&#39; . $errstr; break; case E_NOTICE: case E_USER_NOTICE: echo &#39;Notice error in file &#39; . $errorfile . &#39;on line&#39; . $errorline . &#39;&lt;br/&gt;&#39;; echo &#39;error info:&#39; . $errstr; break; } return true; } // 报错 echo $a; // 修改错误机制 set_error_handler(&#39;myerrors&#39;); echo $a; ?&gt; 当前属于简单自定义模式，如果要复杂，可以在某些影响代码功能的错误发生后，让用户跳转到某个指定界面 字符串类型字符串定义语法 单引号字符串：使用单引号包裹 双引号字符串：使用双引号包裹 引号方式：比较适合那些比较短（不超过一行）或者没有结构要求的字符串，如果有结构要求，或者内容超过一行，可以使用以下两种结构定义 nowdoc字符串：没有单引号的单引号字符串 heredoc字符串：没有双引号的双引号字符串 heredoc和nowdoc比引号还是区别多一点，主要体现在源代码上。 代码示例： &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/16 * Time: 21:48 * Features: 字符串 */ // 引号定义 $str1 = &#39;hello&#39;; $str2 = &quot;hello&quot;; var_dump($str1, $str2); echo &#39;&lt;hr&gt;&#39;; // 结构化定义 // heredoc结构 $str3 = &lt;&lt;&lt;EOD hello world EOD; // nowdoc结构 $str4 = &lt;&lt;&lt;&#39;EOD&#39; hello world EOD; var_dump($str3, $str4); echo &#39;&lt;hr&gt;&#39;; 字符串转义 转义的含义：在计算机通用协议中，有一些特定的方式定义的字母，系统会特定处理：通常这种方式都是使用反斜杠+字母（单词）的特性PHP在识别转义字符的时候也是使用同样的模式：反斜杠+字母。 在PHP中系统常用Definitely转义符号： \\&#39;:在单引号字符串中显示单引号 \\&quot;:在双引号字符串中显示双引号 \\r:代表回车（理论上时回到当前行的首位置） \\n:代表新一行 \\t:类型tab键，输出4个空格 \\$:在PHP中使用$符号作为变量符号，因此需要特定识别 单引号与双引号的区别： 其中单引号中能够识别：\\&#39;;而双引号中就不能识别\\&#39;。 双引号中因为能够识别$符号，所以双引号中可以解析变量，而单引号不可以。 双引号中变量识别的规则 变量本身系统能够与后面的内容区分：应该保证变量的独立性，不要让系统难以区分。 使用变量专业标识符（区分），给变量加上一组大括号{}。 结构化定义字符串变量的规则： 结构化定义字符串对应的边界符有条件1.1 上边界符后面不能跟任何内容1.2 下边界符必须定格：最左边1.3 下边界符同样后面只能跟分号，不能跟任何内容 结构化定义字符串的内部（边界符之间）的所有内容都是字符串本身 代码示例： &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/16 * Time: 22:03 * Features: 转义符号 */ // 定义字符串识别转义符号 $str1 = &#39;abc\\r\\ndef\\t\\&#39;\\&quot;\\$fg&#39;; $str2 = &quot;abc\\r\\ndef\\t\\&#39;\\&quot;\\$fg&quot;; echo $str1, &#39;&lt;br&gt;&#39;, $str2; echo &#39;&lt;hr&gt;&#39;; $a = &#39;hello&#39;; //变量识别 $str3 = &#39;abc $a dfg&#39;; $str4 = &quot;abc $a dfg&quot;; $str5 = &quot;abc $adfg&quot;; $str6 = &quot;abc{$a}dfg&quot;; echo $str3, &#39;&lt;br&gt;&#39;, $str4, &#39;&lt;br&gt;&#39;, $str5, &#39;&lt;br&gt;&#39;, $str6; echo &#39;&lt;hr&gt;&#39;; $str7 = &lt;&lt;&lt;EOD //js &lt;script&gt; alert(&#39;$str3&#39;); &lt;/script&gt; EOD; echo $str7; ?&gt; 字符串长度问题 基本函数strlen()：得到字符串的长度（字节为单位） 多字节字符串的长度问题：包含中文的长度 多字节字符串扩展模块：mbstring扩展；php.ini文件中开启mbstring。 mbstring扩展针对的是一些关于字符统计：strlen只是针对标准交换码ASCII，mbstring会针对不同的字符集。 代码示例： &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/16 * Time: 22:27 * Features: 字符串长度 */ // 字符串长度 // 定义字符串 $str1 = &#39;aknsfjknkfsjadnf&#39;; $str2 = &#39;你好123&#39;; echo strlen($str1), &#39;&lt;br/&gt;&#39;, strlen($str2); echo &#39;&lt;hr&gt;&#39;; // 使用mbstring扩展 echo mb_strlen($str1), &#39;&lt;br/&gt;&#39;, mb_strlen($str2), &#39;&lt;br/&gt;&#39;, mb_strlen($str2, &#39;utf-8&#39;); ?&gt; 字符串相关函数 转换函数： implode():将数组中的元素按照某个规则连接成一个字符串 explode():将字符串按照某种格式进行分割，变成数组 str_split():按照指定长度拆分字符串得到数组 截取函数： trim():本身默认是用来去除两边的空格（中间不行），但是也可以指定要去除的内容，是按照指定的内容循环去除两边有的内容：直到碰到一个不是目标字符串为止 itrim():去除左边的 rtrim():去除右边的 截取函数： substr():指定位置开始截取字符串，可以截取指定长度（不指定到最后） strstr():从指定位置开始截取到最后 大小转换函数： strolower():全部小写 strtoupper():全部大写 ucfirst():首字母大写 查找函数： strpos():判断字符在目标字符串中出现的位置（首次） strrpos():判断字符在目标字符串中最后出现的位置 替换函数： str_replace():将目标字符串中部分字符串进行替换 格式化函数： printf():格式化输出数据 sprintf():格式化输出数据 其他： str_repeat():重复某个字符串N次 str_shuffle():随机打乱字符串 数组数组的概念 数组：array，数据的组合，指将一组数据（多个）存储到一个指定的容器中国，用变量指向该容器，然后可以通过变量一次性得到该容器中的所有数据。 数组定义语法在PHP中系统提供了多种定义数组的方式： 使用array关键字：最常用的 $变量=array[元素1,元素2,元素3...]; 可以使用中括号来包裹数据 $变量=[元素1,元素2...]; 隐形定义数组：给变量增加一个中括号，系统会自动变成数组 $变量[]=值1; //如果不提供下标也可以i，系统会自动生成（数字：从0开始） $变量[下标]=值; //中括号里面的内容称之为小标key，该下标可以是字母（单词）或者数字，与变量名的规则相似 代码示例： &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/17 * Time: 13:39 * Features: 数组 */ // 数组 // 定义数组 $arr1 = array(&#39;1&#39;, 2, &#39;hello&#39;); var_dump($arr1); echo &#39;&lt;hr&gt;&#39;; // 定义数组：[] $arr2 = [&#39;1&#39;, 2, &#39;hello&#39;]; var_dump($arr2); echo &#39;&lt;hr&gt;&#39;; // 隐形数组 $arr3[] = 1; $arr4[10] = 1; $arr4[] = &#39;1&#39;; $arr5[&#39;key&#39;] = &#39;key&#39;; var_dump($arr3); echo &#39;&lt;hr&gt;&#39;; var_dump($arr4); //注意$arr4的下标 echo &#39;&lt;hr&gt;&#39;; var_dump($arr5); ?&gt; PHP数组特点 可以整数下标或者字符串下标 如果数组下标都为整数：索引数组 如果数组下标都为字符串：关联数组 不同下标可以混合存在：混合数组 数组元素的顺序以放入顺序为准，跟下标无关 数字下标的自增长特性：从0开始自动增长，如果终极按手动出现较大的，那么后面的自增长元素从最大的值+1开始 特殊值下标的自动转换 PHP中数组元素没有类型限制 PHP中数组元素没有长度限制 补充：PHP中的数组是很大的数据，所以存储位置是堆区，为当前数组分配一块连续的内存。 代码示例： &lt;?php //特殊下标转换 $arr6[false] = false; $arr6[true] = true; $arr6[NULL] = NULL; var_dump($arr6); echo &#39;&lt;hr&gt;&#39;; ?&gt; 多维数组 多维数组：数组里面的元素又是数组 二维数组 二维数组：数组中所有的元素都是一维数组 代码示例： &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/17 * Time: 下午 2:17 * Features: 多维数组 */ // 多维数组 // 定义二维数组 $info = array( array(&#39;name&#39; =&gt; &#39;Jim&#39;, &#39;age&#39; =&gt; 30), array(&#39;name&#39; =&gt; &#39;Jim1&#39;, &#39;age&#39; =&gt; 20), array(&#39;name&#39; =&gt; &#39;Jim2&#39;, &#39;age&#39; =&gt; 10) //最后一个元素，后面可以跟逗号不影响（不建议） ); echo &#39;&lt;pre&gt;&#39;; print_r($info); ?&gt; 多维数组 在第二维的数组元素中可以继续是数组，在PHP中没有维度限制（PHP本质没有二维数组）。但是不建议使用超过三维以上数组，会增加访问复杂度，降低访问效率。 异形数组（不规则数组） 异形数组：数组中的元素不规则，有普通基本变量也有数组。在实际开发中，并不常用，尽量让数组元素规则化（便于进行访问） 数组遍历遍历的基本含义 数组遍历：普通数组数据的访问都是通过数组元素的下标来实现访问，如果说数组中所有的数据都需要一次输出出来，就需要我们使用到一些简化的规则来实现自动获取下标以及输出数组元素。 foreach遍历语法基本语法： foreach($数组变量 as [$下标=&gt;]$值){ //通过$下标访问元素的下标，通过$值访问元素的值 } 通常如果是关联数组（字母下标），就需要下标，如果是数字下标就直接访问值。 在进行数据存储定义的时候，通常二维数组不会两个维度的key下标都为数字，一般是一维为数组（无意义），二维为字符串（数据库表字段），所以在进行遍历的时候，通常是只需要针对一维进行遍历，取得二维数组元素，然后二维数组元素通过下标去访问。 代码示例： &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/17 * Time: 下午 11:11 * Features: 数组遍历：foreach */ // 数组遍历：foreach // 定义数组 $arr = array(1, 2, 3, 4, 5, 6, 7, 8, 9, 0); // foreach循环 foreach ($arr as $v) { //$v随意命名 echo $v, &#39;&lt;br/&gt;&#39;; } // foreach循环 foreach ($arr as $k =&gt; $v) { //$v随意命名 echo &#39;key:&#39;, $k, &#39;==value:&#39;, $v, &#39;&lt;br/&gt;&#39;; } $arr = array( 0 =&gt; array(&#39;name&#39; =&gt; &#39;Tome&#39;, &#39;age&#39; =&gt; 30), 1 =&gt; array(&#39;name&#39; =&gt; &#39;Tome1&#39;, &#39;age&#39; =&gt; 20), 2 =&gt; array(&#39;name&#39; =&gt; &#39;Tome2&#39;, &#39;age&#39; =&gt; 10) ); // 通过foreach遍历一维元素 foreach ($arr as $value) { // 1.可以继续遍历：增加foreach遍历$value // 2.可以使用下标访问 echo &#39;name is:&#39;, $value[&#39;name&#39;], &#39;and age is:&#39;, $value[&#39;age&#39;], &#39;&lt;br/&gt;&#39;; } ?&gt; foreach遍历原理 foreach遍历原理：本质是数组的内部有一颗指针，默认是指向数组元素的第一个元素，foreach就是利用指针去获取数据，同时移动指针。 foreach会重置指针：让指针指向第一个元素 进入foreach循环：通过指针取得当前第一个元素，然后将下标去除放到对应的下标变量中（如果存在），将值取出来放到对应的值变量中；（指针下移） 进入到循环内部（循环体），开始执行 重复2和3，直到2的时候遇到指针取不到内容（指针指向数组最后） for循环遍历数组for循环：基于已知边界条件（起始和结束）然后又条件的变化（规律） 因此：for循环遍历数组有对应条件 获取数组长度：count(数组)得到数组元素的长度 要求数组元素的下标是规律的数字 代码示例： &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/17 * Time: 下午 11:31 * Features: for循环遍历数组 */ // for循环遍历数组 //数组特点：索引数组，下标规律 $arr = array(1, 2, 3, 4, 5, 6, 7, 8, 9); for ($i = 0, $len = count($arr); $i &lt; $len; $i++) { echo &#39;key is:&#39;, $i, &#39;and value is:&#39;, $arr[$i], &#39;&lt;br/&gt;&#39;; } ?&gt; while配合each和list遍历数组while实在外部定义边界条件，如果要实现可以和for循环。 each函数的使用：each能够从一个数组中国获取当前数组指针所指向的元素的下标和值，拿到之后将数组指针下移，同时将拿到的元素下标和值以一个四个元素的数组返回： 0下标：取得元素的下标值 1下标：取得元素的值 key下标：取得元素的下标值 value下标：取得元素的值 如果each取不到结果（数组指针移动到最后），返回false。 代码示例： &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/17 * Time: 下午 11:39 * Features: while配合each和list遍历数组 */ // while配合each和list遍历数组 $arr = array(1, &#39;name&#39; =&gt; &#39;Tom&#39;, 3, &#39;age&#39; =&gt; 30); echo &#39;&lt;pre&gt;&#39;; // each函数指针操作 print_r(each($arr)); print_r(each($arr)); ?&gt; list函数使用：list是一种结构，不止一种函数（没有返回值），是list提供一堆变量去从一个数组中取得元素值，然后依次存放到对应的变量当中（批量为变量赋值：值来源于数组）：list必须从索引数组中去获取数据，而且必须从0开始。 错误操作：变量多于数组元素，没有指定从0到指定变量的下标的数组元素 list与each配合特别好：each一定有两个元素就是0和1下标元素 list(变量1,变量2)=each(数组); //是一种赋值运算，但是可以的到false结果（each取不到正确的结果），整个表达式为false 代码示例： &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/17 * Time: 下午 11:39 * Features: while配合each和list遍历数组 */ // while配合each和list遍历数组 // while循环 $arr = array(1, &#39;name&#39; =&gt; &#39;Tom&#39;, 3, &#39;age&#39; =&gt; 30); while (list($key, $value) = each($arr)) { //list搭配each // list($key, $value) = each($arr); //输出 echo &#39;key is:&#39; . $key . &#39;value is :&#39; . $value . &#39;&lt;br/&gt;&#39;; } ?&gt; 数组的相关函数 排序函数：对数组元素进行排序，都是按照ASCII码进行比较，可以进行英文比较。 sort():顺序排序(下标重排) rsort():逆序排序 asort():顺序排序（下标保留） arsort():逆序排序 ksort():顺序排序 krsort():逆序排序：按照键名（下标） shuffle():随机打乱数组元素，数组下标会重排。 代码示例： &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/18 * Time: 下午 9:46 * Features: 数组排序 */ //排序函数 $arr = array(3, 1, 5, 2, 0); echo &#39;&lt;pre&gt;&#39;; sort($arr); print_r($arr); echo &#39;&lt;hr&gt;&#39;; $arr1 = array(3, 1, 5, 2, 0); asort($arr1); print_r($arr1); echo &#39;&lt;hr&gt;&#39;; $arr3 = array(3, 1, 5, 2, 0); krsort($arr3); print_r($arr3); echo &#39;&lt;hr&gt;&#39;; $arr4 = array(3, 1, 5, 2, 0); shuffle($arr4); print_r($arr4); shuffle($arr4); print_r($arr4); ?&gt; 指针函数 reset():重置指针，将数组指针回到首位 end():重置指针，将数组指针指导到最后一个元素 next():指针下移，取得下一个元素的值 prev():指针上移，取得上一个元素的值 current():获取当前指针对应的元素值 key():获取当前指针对应的下标值 代码示例： &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/18 * Time: 下午 9:46 * Features: 指针函数 */ //指针函数 $arr = array(3, 1, 5, 2, 0); echo &#39;&lt;pre&gt;&#39;; echo current($arr), &#39;&lt;br/&gt;&#39;; echo key($arr), &#39;&lt;br/&gt;&#39;; echo next($arr), next($arr), &#39;&lt;br/&gt;&#39;; echo prev($arr), &#39;&lt;br/&gt;&#39;; echo end($arr), &#39;&lt;br/&gt;&#39;; echo reset($arr), &#39;&lt;br/&gt;&#39;; ?&gt; 注意事项：next和prev会移动指针，有可能导致指针移动到最前或者最后（离开数组），导致数组不能使用，通过next和prev不能回到正确的指针位置。只能通过end或者reset进行指针重置。 其他函数 count():统计数组中元素的数量 array_push():从数组中加入一个元素（数组后面） array_pop():从数组中移除一个元素（数组后面） array_shift():从数组中去除一个元素（数组前面） array_unshift():从数组中加入一个元素（数组前面） array_reverse():数组元素反过来 in_array():判断一个元素在数组中是否存在 array_keys():获取一个数组的所有下标，返回一个索引数组 array_values():获取一个数组的所有值，返回一个索引数组 PHP模拟数据结构： 栈：压栈，先进后出（FILO） 队列：插队，先进先出（FIFO） 代码示例： &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/18 * Time: 下午 9:46 * Features: 其他函数 */ //其他函数 // 模拟数据结构：栈和队列 $arr = array(); //栈：先压栈后出栈：都是从一端出来 // 前面：array_shift和array_unshift // 后面：array_push和array_pop // 压栈 array_push($arr, 3); array_push($arr, 2); array_push($arr, 1); print_r($arr); // 出栈 echo array_pop($arr), array_pop($arr), array_pop($arr), &#39;&lt;br/&gt;&#39;; // 队列：先排队，先出来，一端进，另外一端出 //后进前出:array_push和array_shift //前进后出:array_unshift和arrap_pop $arr = array(); // 入队 array_unshift($arr, 3); array_unshift($arr, 2); array_unshift($arr, 1); print_r($arr); // 出队 echo array_pop($arr), array_pop($arr), array_pop($arr), &#39;&lt;br/&gt;&#39;; $arr = array(1, 2, 3, 6, 5); print_r(array_reverse($arr)); var_dump(in_array(100, $arr)); var_dump(in_array(1, $arr)); print_r(array_keys($arr)); print_r(array_values($arr)); ?&gt; 编程思想 编程思想：如何利用数学模式，来解决对应的需求问题；然后利用代码实现对应的数据模型（逻辑）算法：使用代码实现对应的数学模型，从而解决对应的业务问题。 递推算法 递推算法是一种简单的算法，即通过已知条件，利用特定关系得出中间推论，直到得到结果的算法。递推算法分为顺推和逆推两种。 顺推：通过最简单的条件（已知），然后逐步推演结果。 逆推：通过结果找到规律，然后推到已知条件。 代码示例： 斐波那契数列 &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/20 * Time: 下午 8:06 * Features: 递推思想 */ // 递推思想（算法） // 需求：规律 1 1 2 3 5 // 求出指定位数对应的值 function my_recursive($des) { //判断：如果为第一个或者第二个 if ($des == 1 || $des == 2) return 1; // 开始计算 $f[1] = 1; $f[2] = 1; //如果想要第一个或者第二个结果，那么可以直接给出 for ($i = 3; $i &lt;= $des; $i++) { $f[$i] = $f[$i - 1] + $f[$i - 2]; } //返回最后一个位置的结果 return $f[$des]; } echo my_recursive(15); ?&gt; 递归算法 递归算法是把问题转化为规模缩小了的同类问题的子问题。然后递归调用函数（或过程）来表示问题的解。 简化问题：找到最有子问题（不能再小） 函数自己调用自己 递归思想中：有两个非常重要的点 递归点：发现当前问题可以有解决当前问题的函数，去解决规模比当前小一点的问题来解决 递归出口：当问题解决的时候，已经到达（必须有）最优子问题，不能再次调用函数如果一个函数递归调用自己而没有递归出口：就是死循环。 递归的本质：是函数调用函数：一个函数需要开辟一块内存空间，递归会出现同时调用N多个函数（自己）：递归的本质就是利用空间换时间。 代码示例： 斐波那契数列 &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/20 * Time: 下午 8:28 * Features: 递归思想 */ // 递归思想 // 递归一定有函数 function recursion($n) { //递归出口 if ($n == 1 || $n == 2) return 1; //递归点：求N的值，与求N-1得值一模一样，只是N-1的规模比N小 return recursion($n - 1) + recursion($n - 2); } //调用 echo recursion(15); ?&gt; 数组排序算法冒泡排序 冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。它重复地走访过要排序地数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。 冒泡排序地算法思路： 比较相邻地元素。如果第一个比第二个大，就交换他们两个。 对每一对元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一堆数字需要比较。 代码示例： &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/22 * Time: 下午 4:00 * Features: 冒泡排序 */ // 冒泡排序 $arr = array(1, 4, 2, 9, 7, 5, 8); //2. 想办法让下面可以每次找出最大值的代码重复执行 for ($i = 0, $len = count($arr); $i &lt; $len; $i++) { // 1. 想办法将最大的值放到最右边去 for ($j = 0, $len = count($arr); $j &lt; $len - 1 - $i; $j++) { //判断：两两相比 if ($arr[$j] &gt; $arr[$j + 1]) { //左边比右边大：交换 $temp = $arr[$j]; $arr[$j] = $arr[$j + 1]; $arr[$j + 1] = $temp; } } } echo &#39;&lt;pre&gt;&#39;; print_r($arr); ?&gt; 选择排序 选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放到序列的起始位置，直到全部待排序的数据元素拍完。选择排序是不稳定的排序方法（比如序列[5,5,3]第一次就将第一个[5]与[3]交换，导致第一个5挪动到第二个5后面） 选择排序的算法思路： 假设第一个元素为最小元素，记下下标 寻找右侧剩余的元素，如果有更小的，重新记下最新的下标 如果有新的最小的，交换两个元素。 往右重复以上步骤，直到元素本身是最后一个。 代码示例： &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/22 * Time: 下午 4:25 * Features: 选择排序 */ // 选择排序 $arr = array(1, 5, 2, 9, 6, 3, 4); // 1. 确定要交换多少次：依次只能找到一个最小的，需要找数组长度对应的次数 for ($i = 0, $len = count($arr); $i &lt; $len; $i++) { // 2. 假设当前第一个已经排好序 $min = $i; //当前第一个数是最小的 //3. 拿该最小的去比较剩余的其他 for ($j = $i + 1; $j &lt; $len; $j++) { //4. 比较：比较当前元素与选定的最小的元素 if ($arr[$j] &lt; $arr[$min]) { //说明当前指定的$min不合适 $min = $j; } } //5. 交换当前选定的值与实际最小的元素值 if ($min != $i) { $temp = $arr[$i]; $arr[$i] = $arr[$min]; $arr[$min] = $temp; } } echo &#39;&lt;pre&gt;&#39;; print_r($arr); ?&gt; 插入排序 插入排序（Insert sort），插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，是稳定的排序方法。插入算法把排序的数组分成两部分：第一部分包含了这个数组的所有元素，但将最后一个元素除外（让数组多一个空间才有插入的位置），而第二部分就只包含这一i个元素（即待插入元素）。在第一部分排序完成后，再将这个最后元素插入到已排好序的第一部分中。 插入排序的基本思想是：每步将一个待排序的记录，按其关键码值得大小插入前面已经排序的文件中适当位置上，直到全部插入完为止。 插入排序的算法思路： 设置监视哨r[0]，将待插入记录的值赋值给r[0]。 设置开始查找的位置。 在数组中进行搜索，搜索中将第j个记录后移，直至r[0].key&gt;=r[j].key为止； 将r[0]插入r[j+1]的位置上。 代码示例： &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/23 * Time: 下午 1:32 * Features: 插入排序 */ // 插入排序 $arr = array(4, 2, 6, 8, 9, 5); //1. 确定要插入多少回（假设一个数组一次性插入到对的位置，同时第一个位置是假设对的） for ($i = 1, $len = count($arr); $i &lt; $len; $i++) { // 2. 取出当前要插入的元素的值 $temp = $arr[$i]; //标记：默认说明当前要插入的数组的位置是对的 $change = false; //3. 让该数据与前面已经排好序的数组元素重复比较（挨个比较），直到的位置（）交换 for ($j = $i - 1; $j &gt;= 0; $j--) { // 4. 比较 if ($arr[$j] &gt; $temp) { //说明当前要插入的元素，比前面的已经排好序的元素的值要小：交换位置 $arr[$j + 1] = $arr[$j]; //说明前面顺序的数组元素有不合适的位置 $change = true; } else { //说明当前待插入元素，比前面的元素要打：说明位置正确 break; } } //判断位置需要变动 if ($change) { //有数据移动，占错位置了 $arr[$j + 1] = $temp; } } echo &#39;&lt;pre&gt;&#39;; print_r($arr); ?&gt; 快速排序 快速排序（Quicksort）是对冒泡排序的一种改进。通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据编程有序序列。（递归） 设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，然后将所有比它小的数据放到他前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序。值得注意的是，快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。 快速排序的算法是： 从数组中选出一个元素（通常第一个），作为参照对象。 定义两个数组，将目标数组中剩余的元素与参照元素挨个比较：小的放到一个数组，大的放到另外一个数组。 第二步执行完之后，前后的数组顺序不确定，但是确定了自己的位置。 将得到的小数组按照第1到第3步重复操作（子问题）。 回溯最小数组（一个元素）。 代码示例： &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/23 * Time: 下午 4:20 * Features: 快速排序 */ // 快速排序 $arr = array(5, 6, 3, 4, 9, 2, 7, 8); //快速排序 function quickSort($array) { if (!isset($array[1])) return $array; $mid = $array[0]; //获取一个用于分割的关键字，一般是首个元素 $leftArray = array(); $rightArray = array(); foreach ($array as $v) { if ($v &gt; $mid) $rightArray[] = $v; //把比$mid大的数放到一个数组里 if ($v &lt; $mid) $leftArray[] = $v; //把比$mid小的数放到另一个数组里 } $leftArray = quickSort($leftArray); //把比较小的数组再一次进行分割 $leftArray[] = $mid; //把分割的元素加到小的数组后面，不能忘了它哦 $rightArray = quickSort($rightArray); //把比较大的数组再一次进行分割 return array_merge($leftArray, $rightArray); //组合两个结果 } echo &#39;&lt;pre&gt;&#39;; print_r(quickSort($arr)); ?&gt; 归并排序 归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法，该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即显示每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。 二路归并实现： 代码示例： &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/23 * Time: 下午 10:15 * Features: 归并排序 */ // 归并排序 // 二路归并 $arr1 = array(1, 3, 5); $arr2 = array(2, 4, 6); //取出一个空数组用于归并空间 $arr3 = array(); while (count($arr1) &amp;&amp; count($arr2)) { //只要$arr1和$arr2里面还有元素，就进行循环 //取出每个数组的第一个元素：进行比较 $arr3[] = $arr1[0] &lt; $arr2[0] ? array_shift($arr1) : array_shift($arr2); } //合并结果 print_r(array_merge($arr3, $arr1, $arr2)); ?&gt; 归并排序的算法是： 将数组拆分成两个数组 重复步骤1将数组拆分成最小单元 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列 设定两个指针，最初位置分别为两个已经排序序列的起始位置 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置 重复步骤3直到某一指针超出序列尾 将另一序列剩下的所有元素直接复制到合并序列尾 代码示例： &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/23 * Time: 下午 10:15 * Features: 归并排序 */ // 归并排序 $arr = array(4, 7, 2, 1, 5, 9, 3); //归并排序 function merge_sort($arr) { //递归出口 $len = count($arr); if ($len &lt;= 1) return $arr; //拆分 $middle = floor($len / 2); $left = array_slice($arr, 0, $middle); $right = array_slice($arr, $middle); //递归点：$left和$right都没有排好序：而且可能是多个元素的数组 $left = merge_sort($left); $right = merge_sort($right); //假设左边和右边都已经排好序：二路归并 //取出一个空数组用于归并空间 $arr3 = array(); while (count($left) &amp;&amp; count($right)) { //只要$arr1和$arr2里面还有元素，就进行循环 //取出每个数组的第一个元素：进行比较 $arr3[] = $left[0] &lt; $right[0] ? array_shift($left) : array_shift($right); } //合并结果 return array_merge($arr3, $left, $right); } print_r(merge_sort($arr)); ?&gt; 查找算法查找算法含义 查找是在大量的信息中寻找一个特定的信息元素，在计算机应用中，查找是常用的基本运算。查找算法是指实现查找过程对应的代码结。就是中大型数组中去快速定位想要的元素。 顺序查找算法 顺序查找也称为线性查找，从数据结构线性表的一段开始，顺序扫描，依次将扫描到的结点关键字与给定值k相比较，若相等则表示查找成功；若扫描结束仍没有找到关键字等于k的节点，表示查找失败。 代码示例： &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/23 * Time: 下午 10:52 * Features: 查找算法 */ // 查找算法 // 顺序查找 $arr = array(1, 3, 6, 8, 23, 68, 100); // 顺序查找 function check_order($arr, $num) { //全部匹配 for ($i = 0, $len = count($arr); $i &lt; $len; $i++) { //判断 if ($arr[$i] == $num) { return $i; } } return false; } var_dump(check_order($arr, 7)); ?&gt; 二分查找算法 二分查找要求线性表中的节点按关键字值升序或降序排列，用给定值k先与中间节点的关键字比较，中间结点把线形表分为两个子表，若相等则查找成功；若不想等，再根据k与该中间节点关键字的比较结果确定下一步查找那个子表，这样递归进行，直到查找到或查找结束发现表中没有这样的结点。 二分查找算法思路： 计算数组长度 确定左右两边的指针位置 找到中间位置 匹配 然后根据大小重定边界 代码示例： &lt;?php /* * Create by PhpStorm * Author: Yan * Date: 2019/8/23 * Time: 下午 10:52 * Features: 查找算法 */ // 查找算法 $arr = array(1, 3, 6, 8, 7, 7, 23, 68, 100); //二分查找算法 function check_break($arr, $res) { //1. 得到数组边界 $right = count($arr); $left = 0; // 2. 循环匹配 while ($left &lt;= $right) { //3. 得到中间位置 $middle = floor(($right + $left) / 2); //匹配数据 if ($arr[$middle] == $res) { return $middle + 1; } //5. 没有找到 if ($arr[$middle] &lt; $res) { //值在右边 $left = $middle + 1; } else { //值在左边 $right = $middle - 1; } } return false; } var_dump(check_break($arr, 0)); ?&gt; 待续","categories":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/categories/PHP/"},{"name":"入门","slug":"PHP/入门","permalink":"http://yoursite.com/categories/PHP/入门/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/tags/PHP/"},{"name":"入门","slug":"入门","permalink":"http://yoursite.com/tags/入门/"}]},{"title":"Java基础","slug":"java基础","date":"2019-08-06T16:00:00.000Z","updated":"2019-10-11T00:11:14.525Z","comments":true,"path":"2019/08/07/java基础/","link":"","permalink":"http://yoursite.com/2019/08/07/java基础/","excerpt":"代码仓库地址欢迎下载：GitHub 运行环境： IntelliJ IDEA 2019.1.3(Ultimate Edition) jdk 1.8.0_211 Java8手册文件名为jdk1.8.CHM即为Java8手册。 打不开参考下面链接： 解决win10中无法打开CHM文件的方法 Java 基础Java简介","text":"代码仓库地址欢迎下载：GitHub 运行环境： IntelliJ IDEA 2019.1.3(Ultimate Edition) jdk 1.8.0_211 Java8手册文件名为jdk1.8.CHM即为Java8手册。 打不开参考下面链接： 解决win10中无法打开CHM文件的方法 Java 基础Java简介 Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程。 Java具有简单性、面向对象、分布式、健壮性、安全性、平台独立与可移植性、多线程、动态性等特点 。Java可以编写桌面应用程序、Web应用程序、分布式系统和嵌入式系统应用程序等。 详情 运行环境搭建下载JDK建议使用1.8及以上的版本。官方下载路径：jdk下载路地址 安装双击下载软件，一路单击下一步即可。 配置环境变量Windows：右击【我的电脑】→【属性】→【高级系统设置】→【环境变量】→【系统变量】→【新建】，接着如下图所示： 在【系统变量】的path中添加 %JAVA_HOME%\\bin。 验证，如下图所示： Hello Worldpublic class helloworld { public static void main(String[] args) { System.out.println(&quot;helloworld&quot;); } } Hello World 运行原理 工具Intellij IDEA下载路径：indea U 激活（针对学生的免费使用计划）参考：Intellij IDEA的下载和使用（针对学生的免费使用计划） 注释、标识符命名规则及Java中的关键字1. Java注释1. 单行注释：// 2. 多行注释：/*。。。。。*/ 3. 文档注释：/**。。。*/ 2. 标识符命名标识符定义：Java语言中，对于变量、常量、函数、语句块也有名字，我们统统称为Java标识符。 标识符作用：标识符是用来给类、对象、方法、常量、接口和自定义数据类型命令的。 标识符命名规则：Java标识符由数字、字母和下划线（_），美元符号（$）组成。在Java中是区分大小写的，而且还要求首位不能是数字。最重要的是，Java关键字不能当作Java标识符。 3. Java关键字 访问控制 private protected public 类，方法和变量修饰符 abstract class extends final implements interface native new static strictfp synchronized transient volatile 程序控制 break continue return do while if else for instanceof switch case default 错误处理 try catch throw throws finally 包相关 import package 基本类型 boolean byte char double float int long short null true false 变量引用 super this void 保留字 goto const 参考：Java 关键字总结 Java基本数据类型1. 数据类型分类 2. 整数类型 序号 数据类型 大小/位 可表示的数据范围 1 byte(位) 8 -27到（26-1） 2 short(整型) 16 -215到（215-1） 3 int(整型) 32 -231到（231-1） 4 long(长整型) 64 -263到（263-1） Byte数据范围表示 符号位 1 1 1 1 1 1 1 1 符号位0表示正 范围 00000000~01111111符号位1表示负 范围 10000000~11111111（减一取反） 代码实例： package com.java.chap03; /** * @author Yan * @date 2019/7/16 13:52 */ public class Demo1 { public static void main(String[] args) { //定义一个int类型的变量 int a; //给变量a赋值 a=1; System.out.println(a); //定义一个int类型的变量a2 int a2=1; System.out.println(&quot;a2=&quot;+a2); //定义一个byte类型的变量b byte b=3; System.out.println(&quot;b=&quot;+b); //定义一个short类型的变量 short s=4; System.out.println(&quot;s=&quot;+s); //定义一个long类型的变量l long l=5; System.out.println(&quot;l=&quot;+l); int a11=1; int a22=2; int a3=a11+a22; System.out.println(&quot;a1+a2=&quot;+a3); } } 3. 浮点类型 序号 数据类型 大小/位 可表示的数据范围 1 float(单精度) 32 -3.4E38(-3.4x1038) 到 3.4E38(3.4x1038)) 2 double(双精度) 64 -1.7E308(-1.7x10308) 到 1.7E308(1.7x10308)) 代码示例： package com.java.chap03; /** * @author Yan * @date 2019/7/16 13:53 */ public class Demo2 { public static void main(String[] args) { //定义一个float类型的变量f //小数默认是double类型，所以必须加一个f,来表示float类型 float f=1.1f; System.out.println(&quot;f=&quot;+f); //定义一个double类型变量d double d=1.2; System.out.println(&quot;d=&quot;+d); //获取float的最大值 float maxF=Float.MAX_VALUE; System.out.println(&quot;float最大值：&quot;+maxF); //获取float的最小值 float minF=Float.MIN_VALUE; System.out.println(&quot;float最小值：&quot;+minF); } } 4. 字符型字符型常量有3种表示形式。char 1. 直接通过单个字符来指定字符型常量，如‘A’，‘b’，‘5’； 2. 通过转义字符表示特殊字符型常量，如‘\\n’,‘\\\\’; 3. 直接使用Unicode值来表示字符型常量，如‘\\u66f9’，‘\\yu950b’； 转义字符 说明 \\b 退格 \\n 换行 \\t 制表符 \\” 双引号 \\’ 单引号 \\ 反斜杠 \\r 回车符 代码示例: package com.java.chap03; /** * @author Yan * @date 2019/7/16 13:53 */ public class Demo3 { public static void main(String[] args) { //定义一个单个字符 char c1=&#39;A&#39;; System.out.println(&quot;c1=&quot;+c1); //定义一个反斜杠字符 char c2=&#39;\\\\&#39;; System.out.println(&quot;c2=&quot;+c2); //用Unicode编码输出自己的名字 char c3=&#39;\\u66f9&#39;; char c4=&#39;\\u950b&#39;; System.out.println(&quot;c3=&quot;+c3); System.out.println(&quot;c4=&quot;+c4); } } 5. 布尔类型布尔类型的变量只有true(真)和false(假)两种。 package com.java.chap03; /** * @author Yan * @date 2019/7/16 13:53 */ public class Demo4 { public static void main(String[] args) { //定义一个布尔类型变量b1 boolean b1=true; System.out.println(&quot;b1=&quot;+b1); //定义一个布尔类型变量b2 boolean b2=false; System.out.println(&quot;b2=&quot;+b2); } } 6. 基本类型的类型转换1. 自动类型转换 条件： 1. 转换前后的数据类型兼容； 2. 转换后的数据类型的表示范围要比转换前的大； 2. 强制类型转换 代码示例： package com.java.chap03; /** * @author Yan * @date 2019/7/16 13:53 */ public class Demo5 { public static void main(String[] args) { //自动类型转换 short s=1; int i; //自动类型转换 short类型转成int类型 i=s; System.out.println(&quot;i=&quot;+i); //强制类型转换 double d=1.333; float f; //把double类型的数据强制转换成float类型 f=(float) d; System.out.println(&quot;f=&quot;+f); } } Java运算符与表达式 1. 赋值运算符符号：=（赋值） package com.java.chap04; /** * @author Yan * @date 2019/7/16 13:01 */ public class Demo1 { public static void main(String[] args) { //定义变量a int a; //给变量a赋值 a=1; System.out.println(&quot;a=&quot;+a); //定义变量a，并且给a赋值 int a2=2; System.out.println(&quot;a2=&quot;+a2); } } 2. 算数运算符符号：+（加），-（减），*（乘），/（除），%（取模） package com.java.chap04; /** * @author Yan * @date 2019/7/16 13:07 */ public class Demo2 { public static void main(String[] args) { int a=10; int b=3; //+运算符 System.out.println(a+&quot;+&quot;+b+&quot;=&quot;+(a+b)); //-运算符 System.out.println(a+&quot;-&quot;+b+&quot;=&quot;+(a-b)); //*运算符 System.out.println(a+&quot;*&quot;+b+&quot;=&quot;+(a*b)); // /运算符 System.out.println(a+&quot;/&quot;+b+&quot;=&quot;+(a/b)); //%运算符 System.out.println(a+&quot;%&quot;+b+&quot;=&quot;+(a%b)); } } 3. 自增与自减运算符符号：++（自增），–（自减）重点：a++和++a的区别 package com.java.chap04; /** * @author Yan * @date 2019/7/16 13:13 */ public class Demo3 { public static void main(String[] args) { int a = 1; //a++表示先做赋值操作，然后自增 /* int b=a++; System.out.println(&quot;b=&quot;+b); System.out.println(&quot;a=&quot;+a); */ //++a表示先自增，然后赋值操作 int b=++a; System.out.println(&quot;b=&quot;+b); System.out.println(&quot;a=&quot;+a); } } 4. 逻辑运算符符号：&amp;&amp;（与），&amp;（不短路与），||（或），|（不短路或），!(非)，^（亦或） package com.java.chap04; /** * @author Yan * @date 2019/7/16 13:53 */ public class Demo4 { public static void main(String[] args) { // &amp;&amp; 与 前后两个操作数必须都是true才返回true，否则返回false boolean b1 = (5 &lt; 3) &amp;&amp; (4 &gt; 5); System.out.println(&quot;b1 = &quot; + b1); //&amp; 不短路与 boolean b2 = (5 &lt; 3) &amp; (4 &gt; 5); System.out.println(&quot;b2 = &quot; + b2); //一般都使用 &amp;&amp; //原因：效率高 // || 或 只要两个操作数中有一个是true，就返回true，否则返回false boolean b3 = (2 &lt; 3) || (4 &gt; 5); System.out.println(&quot;b3 = &quot; + b3); // | 不短路或 boolean b4 = (2 &lt; 3) | (4 &gt; 5); System.out.println(&quot;b4 = &quot; + b4); // ! 非，如果操作数为true，返回false，否则返回true boolean b5 = !(3 &lt; 4); System.out.println(&quot;b5 = &quot; + b5); // ^ 异或 当两个操作数不相同时，返回true，否则返回false boolean b6 = (5 &gt; 4) ^ (4 &gt; 5); System.out.println(&quot;b6 = &quot; + b6); } } 5. 关系运算符符号：&gt;(大于)，&lt;(小于)，&gt;=（大于等于），&lt;=(小于等于)，==（等于），!=(不等于) package com.java.chap04; /** * @author Yan * @date 2019/7/16 14:22 */ public class Demo5 { public static void main(String[] args) { int a = 2; int b = 3; // &gt; 大于 System.out.println(a + &quot;&gt;&quot; + b + &quot;:&quot; + (a &gt; b)); // &lt; 小于 System.out.println(a + &quot;&lt;&quot; + b + &quot;:&quot; + (a &lt; b)); // &gt;= 大于等于 System.out.println(a + &quot;&gt;=&quot; + b + &quot;:&quot; + (a &gt;= b)); // &lt;= 小于等于 System.out.println(a + &quot;&lt;=&quot; + b + &quot;:&quot; + (a &lt;= b)); // == 等于 System.out.println(a + &quot;==&quot; + b + &quot;:&quot; + (a == b)); // != 不等于 System.out.println(a + &quot;!=&quot; + b + &quot;:&quot; + (a != b)); } } 6. 三目运算符格式：（表达式）？表达式为true返回值A：表达式为false返回值B package com.java.chap04; /** * @author Yan * @date 2019/7/16 14:26 */ public class Demo6 { public static void main(String[] args) { //三目运算符 String s=2&gt;3?&quot;表达式为真&quot;:&quot;表达式为假&quot;; System.out.println(&quot;s = &quot; + s); } } Java选择与循环语句1. 程序的选择结构1. if 语句 2. if...else 语句 3. if...else if...else 语句 package com.java.chap05; /** * @author Yan * @date 2019/7/16 15:16 */ public class Demo1 { public static void main(String[] args) { int a=-1; // if语句 if (a&gt;0){ System.out.println(a+&quot;是正数&quot;); } //if...else语句 if (a&gt;0){ System.out.println(a+&quot;是正数&quot;); }else { System.out.println(a+&quot;不是正数&quot;); } //if...else if...else if (a&gt;0){ System.out.println(a+&quot;是正数&quot;); }else if (a&lt;0){ System.out.println(a+&quot;是负数&quot;); }else{ System.out.println(a+&quot;是0&quot;); } } } 4. switch 语句 package com.java.chap05; import java.util.Scanner; /** * @author Yan * @date 2019/7/16 15:22 */ public class Demo2 { public static void main(String[] args) { System.out.println(&quot;请输入一个数字&quot;); //定义一个系统输入对象 Scanner scanner=new Scanner(System.in); int n=scanner.nextInt(); //System.out.println(n); switch (n){ case 1:{ System.out.println(&quot;用户输入的是1&quot;); break; } case 2:{ System.out.println(&quot;用户输入的是2&quot;); break; } default:{ System.out.println(&quot;用户输入的是其他数字&quot;); } } } } 2. 程序的循环结构1. while 循环 2. do...while 循环 3. for 循环 4. for 循环的嵌套 package com.java.chap05; /** * @author Yan * @date 2019/7/16 15:31 */ public class Demo3 { public static void main(String[] args) { //在控制台输出1到10 //while 循环语句 int i = 1; while (i &lt; 11) { System.out.print(i + &quot; &quot;); i++; } System.out.println(&quot;\\n-------------------&quot;); // do...while 循环语句 int j = 1; do { System.out.print(j + &quot; &quot;); j++; } while (j &lt; 11); System.out.println(&quot;\\n-------------------&quot;); //while和do...while的区别 //while是先判断后执行，do...while是先执行后判断 // for 循环 for (int k = 1; k &lt; 11; k++) { System.out.printf(k + &quot; &quot;); } System.out.println(&quot;\\n-------------------&quot;); // for循环的嵌套 for (int m = 0; m &lt; 10; m++) { for (int n = 0; n &lt; 10; n++) { System.out.print(&quot;m=&quot; + m + &quot;n=&quot; + n+&quot; &quot;); } System.out.println(); } } } 5. 求水仙花数 package com.java.chap05; /** * @author Yan * @date 2019/7/16 15:42 */ public class Demo4 { public static void main(String[] args) { for (int i=100;i&lt;=999;i++){ //求出百位数 int b=i/100; //求出十位数 int s=(i-b*100)/10; //求出个位数 int g=(i-b*100-s*10); if (i==g*g*g+s*s*s+b*b*b){ System.out.println(i+&quot; &quot;); } } } } 3. 循环结构的控制1. break 语句 结束循环 package com.java.chap05; /** * @author Yan * @date 2019/7/16 15:52 */ public class Demo5 { public static void main(String[] args) { for (int i=0;i&lt;10;i++){ for (int j=0;j&lt;10;j++){ if (i==1){ break; } System.out.print(&quot;i=&quot;+i+&quot; j=&quot;+j+&quot; &quot;); } System.out.println(); } } } package com.java.chap05; /** * @author Yan * @date 2019/7/16 15:55 */ public class Demo6 { public static void main(String[] args) { outer: for (int i=0;i&lt;10;i++){ for (int j=0;j&lt;10;j++){ if (i==1){ break outer; } System.out.print(&quot;i=&quot;+i+&quot; j=&quot;+j+&quot; &quot;); } System.out.println(); } } } 2. continue 语句 结束本次循环 package com.java.chap05; /** * @author Yan * @date 2019/7/16 15:57 */ public class Demo7 { public static void main(String[] args) { for (int i=0;i&lt;10;i++){ if (i==4){ continue; } System.out.print(&quot;i=&quot;+i+&quot; &quot;); } } } 3. return 语句 结束方法 package com.java.chap05; /** * @author Yan * @date 2019/7/16 15:59 */ public class Demo8 { public static void main(String[] args) { for (int i=0;i&lt;10;i++){ for (int j=0;j&lt;10;j++){ if (i==1){ return; } System.out.print(&quot;i=&quot;+i+&quot; j=&quot;+j+&quot; &quot;); } System.out.println(); } System.out.println(&quot;执行到这里了&quot;); } } Java数组1. 数组简介数组是Java中最常见的一种数据结构，可用于存储多个数据。 2. 数组的定义type[] arrayName;或者type arrayName[]; 实例： int []arr; int arr[]; package com.java.chap06; /** * @author Yan * @date 2019/7/17 14:08 */ public class Demo1 { public static void main(String[] args) { //定义一个数组 int []arr; //定义一个数组 int arr2[]; } } 3. 数组的初始化1. 静态初始化 格式 arrayName=new type[]{element1,element2,element3.....} 实例： int arr1[]=new int[]{1,2,3}; package com.java.chap06; /** * @author Yan * @date 2019/7/17 14:14 */ public class Demo2 { public static void main(String[] args) { //定义一个数组，并且静态初始化 int arr[]=new int[]{1,2,3}; //普通的遍历数组方式 for (int i=0;i&lt;arr.length;i++){ System.out.println(arr[i]); } System.out.println(&quot;------------&quot;); //foreach方法遍历数组 for (int j:arr){ System.out.println(j); } } } 2. 动态初始化 格式 arrayName=new type[length]; 实例： int arr2[]=new int[3]; package com.java.chap06; /** * @author Yan * @date 2019/7/17 14:18 */ public class Demo3 { public static void main(String[] args) { //定义一个数组，然后动态初始化，长度是3 int arr[]=new int[3]; for(int i:arr){ System.out.println(i); } } } 内存分析 4. 二维数组及多维数组二维数组静态化初始化 格式： arrayName=new type[]{{element1,element2},{element1,element2},{element1,element2}}; 实例： int[][]arr=new int[][]{1,2,3},{4,5,6},{7,8,9}}; 二维数组动态初始化 格式： arrayName=new type[length][length]; 实例： int [][]arr2=new int[3][3]; package com.java.chap06; /** * @author Yan * @date 2019/7/17 14:35 */ public class Demo4 { public static void main(String[] args) { //定义一个二维数组,并静态初始化 int [][]arr=new int[][]{{1,2,3},{4,5,6},{7,8,9}}; //输出 for (int i=0;i&lt;arr.length;i++){ for (int j=0;j&lt;arr[0].length;j++){ System.out.print(arr[i][j]+&quot; &quot;); } System.out.println(); } //二维数组的动态初始化 int [][]arr2=new int[3][3]; for (int i=0;i&lt;arr2.length;i++){ for (int j=0;j&lt;arr2[0].length;j++){ System.out.print(arr2[i][j]+&quot; &quot;); } System.out.println(); } } } 5. 起泡法对4，21，0，-12，-3排序。原理：起泡法是从一端开始比较的，第一次循环就是把最大数放到最后一个位置，第二次循环就是把第二最大数放到倒数第二个位置。 4 21 0 -12 -3 第1次 4 0 -12 -3 21 第2次 0 -12 -3 4 21 第3次 -12 -3 0 4 21 第4次 -12 -3 0 4 21 package com.java.chap06; /** * @author Yan * @date 2019/7/17 14:46 */ public class Demo5 { public static void main(String[] args) { int temp; int []arr={4,21,0,-12,-3}; //循环的次数n-1次 for (int i=0;i&lt;arr.length-1;i++){ //比较次数n-1-i for (int j=0;j&lt;arr.length-1-i;j++){ //假如前面一个数大于后面一个数，则交换数据 if (arr[j]&gt;arr[j+1]){ temp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; } } } for (int i:arr){ System.out.print(i+&quot; &quot;); } } } Java面向对象1. 面向对象的基本概念定义：以基于对象的思维去分析和解决问题，万物皆对象；三大特性：封装，继承，多态； 2. 类与对象1. 类与对象的关系2. 类的定义3. 类的创建及使用package com.java.chap07.sec01; /** * @author Yan * @date 2019/7/18 13:39 * Person类 */ public class Person { String name; //在类中，定义一个姓名name字符串属性 int age; //在类中，定义一个年龄age属性 public void speak(){ System.out.println(&quot;我叫&quot;+name+&quot;我今年&quot;+age+&quot;岁了&quot;); } public static void main(String[] args) { //定义一个Person类的对象zhangsan Person zhangsan; //实例化对象 zhangsan=new Person(); //给对象的name属性赋值 zhangsan.name=&quot;张三&quot;; zhangsan.age=23; zhangsan.speak(); } } 内存分析 3. 方法1. 方法的定义及简单使用package com.java.chap07.sec02; /** * @author Yan * @date 2019/7/18 13:54 */ public class People { /** * 最简单的一个方法定义 */ void speak(){ System.out.println(&quot;我叫张三&quot;); } public static void main(String[] args) { People zhangsan=new People(); zhangsan.speak(); } } package com.java.chap07.sec02; /** * @author Yan * @date 2019/7/18 13:57 */ public class People2 { //形参，入参 void speak(String name){ System.out.println(&quot;我叫&quot;+name); } public static void main(String[] args) { People2 zhangsan=new People2(); zhangsan.speak(&quot;张三&quot;); } } package com.java.chap07.sec02; /** * @author Yan * @date 2019/7/18 13:57 */ public class People3 { //形参，入参 void speak(String name, int age) { System.out.println(&quot;我叫&quot; + name+&quot;我今年&quot;+age+&quot;岁了&quot;); } public static void main(String[] args) { People3 zhangsan = new People3(); zhangsan.speak(&quot;张三&quot;, 23); } } package com.java.chap07.sec02; /** * @author Yan * @date 2019/7/18 13:57 */ public class People4 { //形参，入参,不固定参数 void speak(String name, int age,String ...hobbies) { System.out.println(&quot;我叫&quot; + name + &quot;我今年&quot; + age + &quot;岁了&quot;); System.out.println(&quot;我的爱好： &quot;); for (String hobby:hobbies){ System.out.print(hobby+&quot; &quot;); } } public static void main(String[] args) { People4 zhangsan = new People4(); zhangsan.speak(&quot;张三&quot;, 23,&quot;游泳&quot;,&quot;唱歌&quot;); } } package com.java.chap07.sec02; /** * @author Yan * @date 2019/7/18 13:57 */ public class People5 { //返回类型 int speak(String name, int age,String ...hobbies) { System.out.println(&quot;我叫&quot; + name + &quot;我今年&quot; + age + &quot;岁了&quot;); System.out.println(&quot;我的爱好： &quot;); for (String hobby:hobbies){ System.out.print(hobby+&quot; &quot;); } //获取爱好的长度 int totalHobbies=hobbies.length; return totalHobbies; } public static void main(String[] args) { People5 zhangsan = new People5(); int n=zhangsan.speak(&quot;张三&quot;, 23,&quot;游泳&quot;,&quot;唱歌&quot;); System.out.println(&quot;\\n有&quot;+n+&quot;个爱好&quot;); } } 2. 方法的值传递和引用传递(重点)package com.java.chap07.sec02; /** * 三围类 * @author Yan * @date 2019/7/18 14:08 */ class Sanwei{ int b; //胸围 int w; //腰围 int h; //臀围 } public class People6 { /** * 报三围 * @param age 年龄 * @param sanwei 三围 */ void speak(int age,Sanwei sanwei){ System.out.println(&quot;我今年&quot;+age+&quot;岁了,我的三围是&quot;+sanwei.b+&quot;,&quot;+sanwei.w+&quot;,&quot;+sanwei.h); age=24; sanwei.b=80; } public static void main(String[] args) { People6 xiaoli=new People6(); int age=23; Sanwei sanwei=new Sanwei(); sanwei.b=90; sanwei.w=60; sanwei.h=90; //age传递的是值，sanwei传递的是引用（地址）,c里叫指针 xiaoli.speak(age,sanwei); System.out.println(age); System.out.println(sanwei.b); } } 3. 方法的重载方法重载定义：方法名称相同，但是参数的类型或者参数的个数不同。 package com.java.chap07.sec03; /** * @author Yan * @date 2019/7/18 14:22 */ public class Demo { int add(int a,int b){ System.out.print(&quot;方法一:&quot;); return a+b; } /** * 方法的重载，参数个数不一样 * @param a * @param b * @param c * @return */ int add(int a,int b,int c){ System.out.print(&quot;方法二：&quot;); return a+b+c; } /** * 方法的重载，参数的类型不一样 * @param a * @param b * @return */ int add(int a,String b){ System.out.print(&quot;方法三：&quot;); return a+Integer.parseInt(b); } public static void main(String[] args) { Demo demo=new Demo(); System.out.println(demo.add(1,2)); System.out.println(demo.add(1,2,3)); System.out.println(demo.add(1,&quot;3&quot;)); } } 4. static静态方法与普通方法static方法：方法属于类本身；调用方式：1. 类名.方法;2. 对象.方法 普通方法：方法属于类的对象；调用方式：1. 对象.方法 package com.java.chap07.sec03; /** * @author Yan * @date 2019/7/18 15:33 */ public class Demo2 { void fun1(){ System.out.println(&quot;这是一个普通方法&quot;); } static void fun2(){ System.out.println(&quot;这是一个静态方法&quot;); } public static void main(String[] args) { Demo2 demo2=new Demo2(); //调用普通方法，对象.方法 demo2.fun1(); //调用静态方法，类名.方法名 Demo2.fun2(); //调用静态方法，对象.方法 demo2.fun2(); } } 5. 递归方法求阶乘 1 2 3… (n-1) n原理： N=5 F(n-1) * 5 N=4 F(n-1) * 4 N=3 F(n-1) * 3 N=2 F(n-1) * 2 N=1 1 package com.java.chap07.sec03; /** * @author Yan * @date 2019/7/18 15:38 */ public class Demo3 { /** * 非递归 * @param n * @return */ static long notDiGui(int n){ long result=1; for (int i=1;i&lt;=n;i++){ result=result*i; } return result; } /** * 递归 * @param n * @return */ static long DiGUi(int n){ if (n==1){ return 1; } return DiGUi(n-1)*n; } public static void main(String[] args) { System.out.println(&quot;非递归：&quot;+Demo3.notDiGui(5)); System.out.println(&quot;递归:&quot;+Demo3.DiGUi(5)); } } 4. 构造方法，this关键字1. 构造方法构造器是一个特殊的方法，这个特殊方法用于创建实例时可执行初始化；假如没有构造方法，系统会自动生成一个默认的无参构造方法；假如有构造方法，系统不会自动生成构造方法； package com.java.chap07.sec04; /** * @author Yan * @date 2019/7/18 15:56 */ public class People { // String 类属性默认值是null private String name; //int 类属性默认值是0 private int age; /** * 默认构造方法 */ People(){ System.out.println(&quot;默认构造方法&quot;); } /** * 有参数的构造方法 构造方法的重载 */ People(String name2,int age2){ name=name2; age=age2; System.out.println(&quot;有参数的构造方法&quot;); } public void say(){ System.out.println(&quot;我叫：&quot;+name+&quot;，我今年：&quot;+age+&quot;岁了&quot;); } public static void main(String[] args) { //People people=new People(); People people2=new People(&quot;张三&quot;,23); people2.say(); } } 2. this关键字this表示当前对象 使用this调用本类中的属性； 使用this调用构造方法； package com.java.chap07.sec04; /** * @author Yan * @date 2019/7/18 15:56 */ public class People2 { // String 类属性默认值是null private String name; //int 类属性默认值是0 private int age; /** * 默认构造方法 */ People2(){ System.out.println(&quot;默认构造方法&quot;); } /** * 有参数的构造方法 构造方法的重载 */ People2(String name2, int age2){ this(); this.name=name2; this.age=age2; System.out.println(&quot;有参数的构造方法&quot;); } public void say(){ System.out.println(&quot;我叫：&quot;+name+&quot;，我今年：&quot;+age+&quot;岁了&quot;); } public static void main(String[] args) { //People people=new People(); People2 people2=new People2(&quot;张三&quot;,23); people2.say(); } } 5. 访问控制权限及package import关键字1. 访问控制权限private(私有) get,set方法package（包访问权限）protected(子类访问权限)public（公共访问权限） private package protected public 同一个类中 √ √ √ √ 同一个包中 √ √ √ 子类中 √ √ 全局范围 √ Demo1.java package com.java.chap07.sec05; /** * @author Yan * @date 2019/7/18 16:16 */ public class Demo1 { /** * 定义一个私有的属性a */ private int a; public int getA() { return a; } public void setA(int a) { this.a = a; } } TestDemo1.java package com.java.chap07.sec05; /** * @author Yan * @date 2019/7/18 16:17 */ public class TestDemo1 { public static void main(String[] args) { Demo1 demo1=new Demo1(); demo1.setA(2); int a=demo1.getA(); System.out.println(a); } } 2. package import 关键字package 包定义import 导入相关类 package com.java.chap07.sec05; import com.java.chap07.sec02.People; /** * @author Yan * @date 2019/7/18 16:19 */ public class Demo2 { public static void main(String[] args) { //不同包，则需要导入相关类 People people=new People(); //在同一个包中，则不需要导入相关类 Demo1 demo1=new Demo1(); } } 6. 内部类内部类定义：在类的内部定义类；内部类优点：可以方便的使用外部类的属性；内部类缺点：破环类的基本结构； Demo1.java package com.java.chap07.sec06; /** * @author Yan * @date 2019/7/18 16:38 */ public class Outer { private int a=1; /** * 定义内部类 */ class Inner{ public void show(){ System.out.println(a); } } public void show(){ Inner inner=new Inner(); inner.show(); } public static void main(String[] args) { Outer outer=new Outer(); outer.show(); } } Demo2.java package com.java.chap07.sec06; /** * @author Yan * @date 2019/7/18 16:38 */ public class Outer2 { private int a = 1; /** * 定义内部类 */ class Inner { public void show() { System.out.println(a); } } public static void main(String[] args) { Outer2 outer2 = new Outer2(); //实例化外部类对象 Outer2.Inner inner = outer2.new Inner(); //实例化内部类对象 inner.show(); } } 7. 代码块 普通代码块 package com.java.chap07.sec07; /** * @author Yan * @date 2019/7/18 16:49 */ public class Demo1 { public static void main(String[] args) { int a=1; /** * 普通代码块 */ { a=2; System.out.println(&quot;普通代码块&quot;); } System.out.println(&quot;a=&quot;+a); } } 构造块 package com.java.chap07.sec07; /** * @author Yan * @date 2019/7/18 16:52 */ public class Demo2 { /** * 构造块 * @param args */ { System.out.println(&quot;通用构造块&quot;); } /** * 构造方法一 */ public Demo2(){ System.out.println(&quot;构造方法一&quot;); } /** * 构造方法二 */ public Demo2(int i){ System.out.println(&quot;构造方法二&quot;); } /** * 构造方法三 */ public Demo2(int i,int j){ System.out.println(&quot;构造方法三&quot;); } public static void main(String[] args) { new Demo2(); //实例化一个对象 匿名类 new Demo2(1); new Demo2(1,2); } } 静态代码块 package com.java.chap07.sec07; /** * @author Yan * @date 2019/7/18 16:55 */ public class Demo3 { /** * 构造块 */ { System.out.println(&quot;通用构造块&quot;); } /** * 静态代码块 */ static { System.out.println(&quot;静态代码块&quot;); } /** * 构造方法一 */ public Demo3(){ System.out.println(&quot;构造方法一&quot;); } /** * 构造方法二 */ public Demo3(int i){ System.out.println(&quot;构造方法二&quot;); } /** * 构造方法三 */ public Demo3(int i,int j){ System.out.println(&quot;构造方法三&quot;); } public static void main(String[] args) { new Demo3(); new Demo3(1); new Demo3(1,2); } } 8. String 类1. 实例化String对象方法一： String name1=&quot;张三&quot;; 方法二： String name2=new String(&quot;李四&quot;); package com.java.chap07.sec08; /** * @author Yan * @date 2019/7/18 21:32 */ public class Demo1 { public static void main(String[] args) { //实例化String的方式一 String name1=&quot;张三&quot;; System.out.println(&quot;name1:&quot;+name1); //实例化String的方式二 String name2=new String(&quot;李四&quot;); System.out.println(&quot;name2:&quot;+name2); } } 2. “==” VS “equals方法” “==”，比较的是引用，“equals方法”比较的是具体内容 package com.java.chap07.sec08; /** * @author Yan * @date 2019/7/18 21:39 */ public class Demo2 { public static void main(String[] args) { String name1=&quot;张三&quot;; //直接赋值方式 String name2=new String(&quot;张三&quot;); //new 的方式 String name3=name2; // 传递引用 //==比较的是引用 System.out.println(&quot;name1==name2:&quot;+(name1==name2)); System.out.println(&quot;name1==name3:&quot;+(name1==name3)); System.out.println(&quot;name2==name3:&quot;+(name2==name3)); System.out.println(&quot;-------------&quot;); //equals比较的是内容 System.out.println(&quot;name1.equals(name2):&quot;+(name1.equals(name2))); System.out.println(&quot;name1.equals(name3):&quot;+(name1.equals(name3))); System.out.println(&quot;name2.equals(name3):&quot;+(name2.equals(name3))); } } 3. String 两种实例化方式的区别 直接赋值方式，创建的对象存放到字符串对象池里，假如存在的，就不会创建； new对象方式，每次都创建一个新的对象； package com.java.chap07.sec08; /** * @author Yan * @date 2019/7/18 21:46 */ public class Demo3 { public static void main(String[] args) { String name1=&quot;张三&quot;; String name2=&quot;张三&quot;; String name3=new String(&quot;张三&quot;); String name4=new String(&quot;张三&quot;); System.out.println(&quot;name1==name2:&quot;+(name1==name2)); System.out.println(&quot;name1==name3:&quot;+(name1==name3)); System.out.println(&quot;name3==name4:&quot;+(name3==name4)); } } 4. 字符串的内容不可变性字符串的特性：不能改变字符串的内容；只能通过指向一个新的内存地址； package com.java.chap07.sec08; /** * @author Yan * @date 2019/7/18 21:51 */ public class Demo4 { public static void main(String[] args) { String name=&quot;张&quot;; name+=&quot;三&quot;; System.out.println(name); } } 5. String类常用方法及基本使用 char charAt(int index)返回指定索引处的char值。`javapackage com.java.chap07.sec08; /** @author Yan @date 2019/7/18 22:00*/public class Demo5 { public static void main(String[] args) { String name=&quot;张三&quot;; char ming=name.charAt(1); System.out.println(ming); String srt=&quot;我是中国人&quot;; //遍历字符串 for (int i=0;i&lt;srt.length();i++){ System.out.println(srt.charAt(i)); } }} 2. int length()返回此字符串的长度。 3. int indexOf() 返回指定字符在此字符中第一次出现处的索引。 ```java package com.java.chap07.sec08; /** * @author Yan * @date 2019/7/18 22:03 */ public class Demo6 { public static void main(String[] args) { //indexOf方法使用示例 String str=&quot;abcdefghdijklmnopqrstuvwxyz&quot;; System.out.println(&quot;d在字符串str中第一次出现的索引位置：&quot;+str.indexOf(&quot;d&quot;)); System.out.println(&quot;d在字符串str中第一次出现的索引位置,从索引4开始：&quot;+str.indexOf(&quot;d&quot;,4)); } } String substring(int beginIndex)返回一个新的字符串，它是此字符串的一个子字符串。该子字符串从指定索引处的字符开始，直到此字符串末尾。 package com.java.chap07.sec08; /** * @author Yan * @date 2019/7/18 22:08 */ public class Demo7 { public static void main(String[] args) { //subString方法使用 String str=&quot;不开心每一天,不可能&quot;; String newStr=str.substring(1); String newStr2=str.substring(1,6); System.out.println(str); System.out.println(newStr); System.out.println(newStr2); } } String toUpperCase() 使用默认语言环境的规则将此String中的所有字符都转换为大写。 package com.java.chap07.sec08; /** * @author Yan * @date 2019/7/18 22:12 */ public class Demo8 { public static void main(String[] args) { String str=&quot;I&#39;m a boy!&quot;; String upStr=str.toUpperCase(); //转换成大写 System.out.println(&quot;str:&quot;+str); System.out.println(&quot;upStr:&quot;+upStr); String lowerStr=upStr.toLowerCase(); //转换成小写 System.out.println(&quot;lowerStr:&quot;+lowerStr); } } 综合实例编程输入一个字符串，要求去掉前后的空格，然后分别统计其中英文字母，空格，数字和其他字符的个数。 package com.java.chap07.sec08; /** * @author Yan * @date 2019/7/18 22:18 */ public class Demo9 { public static void main(String[] args) { String str=&quot; aB23 2&amp;* &amp;* s2 &quot;; //去掉前面和后面的空白 String newStr=str.trim(); System.out.println(&quot;str:&quot;+str); System.out.println(&quot;newStr:&quot;+newStr); int yingWen=0; int kongGe=0; int shuZi=0; int qiTa=0; for (int i=0;i&lt;newStr.length();i++){ char c=newStr.charAt(i); if (c&gt;=&#39;a&#39;&amp;&amp;c&lt;=&#39;z&#39;||(c&gt;=&#39;A&#39;&amp;&amp;c&lt;=&#39;Z&#39;)){ //判断英文字符 yingWen++; System.out.println(&quot;英文字符：&quot;+c); }else if (c&gt;=&#39;0&#39;&amp;&amp;c&lt;=&#39;9&#39;){ //判断数字 shuZi++; System.out.println(&quot;数字：&quot;+c); }else if (c==&#39; &#39;){ //判断空格 kongGe++; System.out.println(&quot;空格：&quot;+c); }else { //判断其他 qiTa++; System.out.println(&quot;其他：&quot;+c); } } System.out.println(); System.out.println(&quot;英文总数：&quot;+yingWen); System.out.println(&quot;数字总数：&quot;+shuZi); System.out.println(&quot;空格总数：&quot;+kongGe); System.out.println(&quot;其他总数：&quot;+qiTa); } } 9. Java类的继承 继承定义以及基本使用定义：子类能够继承父类的属性和方法；注意点：Java中只支持单继承；私有方法不能继承。 Animal.java package com.java.chap07.sec09; /** * 动物类 * * @author Yan * @date 2019/7/19 15:32 */ public class Animal { //属性姓名 private String name; //属性年龄 private int age; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } //方法say public void say() { System.out.println(&quot;我是一个动物，我叫：&quot; + this.getName() + &quot;我的年龄是：&quot; + this.getAge()); } } Dog.java package com.java.chap07.sec09; /** * * 定义Dog类，继承自Animal类 * @author Yan * @date 2019/7/19 17:25 */ public class Dog extends Animal{ public static void main(String[] args) { Dog dog=new Dog(); dog.setName(&quot;Pick&quot;); dog.setAge(1); dog.say(); } } 方法重写 Animal.java package com.java.chap07.sec09; /** * 动物类 * * @author Yan * @date 2019/7/19 15:32 */ public class Animal { //属性姓名 private String name; //属性年龄 private int age; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } //方法say public void say() { System.out.println(&quot;我是一个动物，我叫：&quot; + this.getName() + &quot;我的年龄是：&quot; + this.getAge()); } } Cat.java package com.java.chap07.sec09; /** * @author Yan * @date 2019/7/19 17:32 */ public class Cat extends Animal { /** * 重写父类的say方法 */ //方法say public void say() { System.out.println(&quot;我是一只猫，我叫：&quot; + this.getName() + &quot;我的年龄是：&quot; + this.getAge()); } public static void main(String[] args) { Cat cat=new Cat(); cat.setName(&quot;Mini&quot;); cat.setAge(2); cat.say(); } } 对象实例化过程以及super关键字 Animal.java package com.java.chap07.sec09; /** * 动物类 * * @author Yan * @date 2019/7/19 15:32 */ public class Animal { //属性姓名 private String name; //属性年龄 private int age; /** * 无参构造方法 */ public Animal(){ System.out.println(&quot;无参构造方法&quot;); } /** * 有参父类构造方法 * @param name 名字 * @param age 年龄 */ public Animal(String name,int age){ System.out.println(&quot;有参父类构造方法&quot;); this.name=name; this.age=age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } //方法say public void say() { System.out.println(&quot;我是一个动物，我叫：&quot; + this.getName() + &quot;我的年龄是：&quot; + this.getAge()); } } Cat.java package com.java.chap07.sec09; /** * @author Yan * @date 2019/7/19 17:32 */ public class Cat extends Animal { private String address; public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } public Cat() { super(); System.out.println(&quot;子类无参构造方法&quot;); } public Cat(String name, int age,String address) { super(name, age); this.address=address; System.out.println(&quot;子类有参构造方法&quot;); } /** * 重写父类的say方法 */ //方法say public void say() { //调用父类的say方法 super.say(); System.out.println(&quot;我是一只猫，我叫：&quot; + this.getName() + &quot;我的年龄是：&quot; + this.getAge()+&quot;我来自：&quot;+this.address); } public static void main(String[] args) { Cat cat=new Cat(&quot;Mini&quot;,1,&quot;火星&quot;); //cat.setName(&quot;Mini&quot;); //cat.setAge(2); cat.say(); } } 10. final关键字 使用final声明的类不能被继承使用final声明的方法不能被子类覆盖使用final声明的变量不能被修改，即为常量 final 修饰类 代码示例：JiangShi.java package com.java.chap07.sec10; /** * @author Yan * @date 2019/7/19 21:04 */ public final class JiangShi { } test.java package com.java.chap07.sec10; /** * @author Yan * @date 2019/7/19 21:05 */ public class Test extends JiangShi{ } final 修饰方法 People.java package com.java.chap07.sec10; /** * @author Yan * @date 2019/7/19 21:55 */ public class People { public final void action(){ System.out.println(&quot;做一个良好公民！&quot;); } } Test.java package com.java.chap07.sec10; /** * @author Yan * @date 2019/7/19 21:05 */ public class Test extends People{ public void action(){ System.out.println(&quot;做一个坏蛋&quot;); } } final 修饰的变量 People.java package com.java.chap07.sec10; /** * @author Yan * @date 2019/7/19 21:55 */ public class People { private final int a=1; public void action(){ a=2; System.out.println(&quot;做一个良好公民！&quot;); } } Common.java package com.java.chap07.sec10; /** * @author Yan * @date 2019/7/19 22:25 */ public class Common { /** * 静态常量 */ public static final String SOMETILE=&quot;中国的首都是北京&quot;; } Test.java package com.java.chap07.sec10; /** * @author Yan * @date 2019/7/19 21:05 */ public class Test extends People{ public void action(){ System.out.println(&quot;做一个坏蛋&quot;); } public static void main(String[] args) { System.out.println(Common.SOMETILE); } } 11. 抽象类定义：在Java中，含有抽象方法的类称为抽象类，同样不能生成对象。注意点： 包含一个抽象方法的类是抽象类 抽象类和抽象方法都要用abstract 关键字声明 抽象方法只需要声明而不需要实现 抽象类必须被子类（假如不是抽象类）必须重写抽象类中的全部抽象方法 抽象类不能被实例化 People.java package com.java.chap07.sec11; /** * 定义一个抽象类People * @author Yan * @date 2019/7/20 15:25 */ public abstract class People { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } public void say(){ System.out.println(&quot;我的姓名是：&quot;+this.getName()); } /** * * 定义一个抽象方法职业 */ public abstract void profession(); } Student.java package com.java.chap07.sec11; /** * @author Yan * @date 2019/7/20 15:29 */ public class Student extends People{ @Override public void profession() { System.out.println(&quot;职业是：学生&quot;); } } Teacher.java package com.java.chap07.sec11; /** * @author Yan * @date 2019/7/20 15:30 */ public class Teacher extends People{ @Override public void profession() { System.out.println(&quot;职业是：老师&quot;); } } Test.java package com.java.chap07.sec11; /** * @author Yan * @date 2019/7/20 15:28 */ public class Test { public static void main(String[] args) { //抽象类不能被实例化 //People p=new People(); Student student=new Student(); student.profession(); Teacher teacher=new Teacher(); teacher.profession(); } } 12. 接口定义：一种特殊的“抽象类”，没有普通方法，有全局常量和公共的抽象方法所组成。 接口的定义 A.java package com.java.chap07.sec12; /** * 定义一个接口A * @author Yan * @date 2019/7/20 15:40 */ public interface A { /** * 全局常量 */ public static final String TITLE=&quot;www.baidu.com&quot;; /** * 定义一个抽象方法 abstract可以省略 */ public void a(); } 实现接口可以实现一个或者多个接口 实现一个接口A.java package com.java.chap07.sec12; /** * 定义一个接口A * @author Yan * @date 2019/7/20 15:40 */ public interface A { /** * 全局常量 */ public static final String TITLE=&quot;www.baidu.com&quot;; /** * 定义一个抽象方法 abstract可以省略 */ public void a(); } Test.java package com.java.chap07.sec12; /** * @author Yan * @date 2019/7/20 16:04 */ public class Test implements A{ @Override public void a() { System.out.println(&quot;a方法&quot;); } public static void main(String[] args) { Test test=new Test(); test.a(); System.out.println(Test.TITLE); } } 实现多个接口 A.java package com.java.chap07.sec12; /** * 定义一个接口A * @author Yan * @date 2019/7/20 15:40 */ public interface A { /** * 全局常量 */ public static final String TITLEA=&quot;www.baidu.com&quot;; /** * 定义一个抽象方法 abstract可以省略 */ public void a(); } B.java package com.java.chap07.sec12; /** * 定义一个接口A * @author Yan * @date 2019/7/20 15:40 */ public interface B { /** * 全局常量 */ public static final String TITLEB=&quot;www.google.com&quot;; /** * 定义一个抽象方法 abstract可以省略 */ public void b(); } Test.java package com.java.chap07.sec12; /** * @author Yan * @date 2019/7/20 16:04 */ public class Test implements A, B { @Override public void a() { System.out.println(&quot;a方法&quot;); } @Override public void b() { System.out.println(&quot;b方法&quot;); } public static void main(String[] args) { Test test = new Test(); test.a(); test.b(); System.out.println(Test.TITLEA); System.out.println(Test.TITLEB); } } 继承类和实现接口先继承，后实现接口 C.java package com.java.chap07.sec12; /** * @author Yan * @date 2019/7/20 16:12 */ public class C { public void c(){ System.out.println(&quot;c方法&quot;); } } Test.java package com.java.chap07.sec12; /** * @author Yan * @date 2019/7/20 16:04 */ public class Test extends C implements A, B { @Override public void a() { System.out.println(&quot;a方法&quot;); } @Override public void b() { System.out.println(&quot;b方法&quot;); } public static void main(String[] args) { Test test = new Test(); test.a(); test.b(); test.c(); System.out.println(Test.TITLEA); System.out.println(Test.TITLEB); } } 接口的继承接口可以多继承 D.java package com.java.chap07.sec12; /** * 定义接口D,继承A，B接口 * @author Yan * @date 2019/7/20 16:15 */ public interface D extends A,B{ /** * 定义一个抽象方法 abstract可以省略 */ public void d(); } Test2.java package com.java.chap07.sec12; /** * @author Yan * @date 2019/7/20 16:04 */ public class Test2 extends C implements D { @Override public void a() { System.out.println(&quot;a方法&quot;); } @Override public void b() { System.out.println(&quot;b方法&quot;); } @Override public void d() { System.out.println(&quot;d方法&quot;); } public static void main(String[] args) { Test2 test = new Test2(); test.a(); test.b(); test.c(); test.d(); System.out.println(Test2.TITLEA); System.out.println(Test2.TITLEB); } } 13. 对象多态性Java中多态性体现： 方法的重载和重写； 可以用父类的引用指向子类的具体实现，而且可以随时更换为其他子类的具体实现； Animal.java package com.java.chap07.sec13; /** * @author Yan * @date 2019/7/20 16:23 */ public class Animal { public void say(){ System.out.println(&quot;我是一个动物&quot;); } } Cat.java package com.java.chap07.sec13; /** * @author Yan * @date 2019/7/20 16:24 */ public class Cat extends Animal{ public void say(){ System.out.println(&quot;我是一个猫&quot;); } } Dog.java package com.java.chap07.sec13; /** * @author Yan * @date 2019/7/20 16:24 */ public class Dog extends Animal{ public void say(){ System.out.println(&quot;我是一个狗&quot;); } } Test.java package com.java.chap07.sec13; /** * @author Yan * @date 2019/7/20 16:25 */ public class Test { public static void main(String[] args) { /* Dog dog=new Dog(); dog.say(); Cat cat=new Cat(); cat.say(); */ //父类引用指向Dog类的具体实现 Animal animal = new Dog(); animal.say(); animal=new Cat(); animal.say(); } } 对象的转型：向上转型：子类对象-&gt;父类对象 安全向下转型：父类对象-&gt;子类对象 不安全 向下转型 package com.java.chap07.sec13; /** * @author Yan * @date 2019/7/20 16:25 */ public class Test { public static void main(String[] args) { /* Dog dog=new Dog(); dog.say(); Cat cat=new Cat(); cat.say(); */ //父类引用指向Dog类的具体实现 Animal animal = new Dog(); animal.say(); //向下转型 Dog dog= (Dog) animal; dog.say(); //向下转型2 不安全 Cat cat= (Cat) animal; cat.say(); /*animal=new Cat(); animal.say(); */ } } 接口方式 Animal.java package com.java.chap07.sec13; /** * @author Yan * @date 2019/7/20 16:23 */ public interface Animal2 { public void say2(); } Dog2.java package com.java.chap07.sec13; /** * @author Yan * @date 2019/7/20 16:34 */ public class Dog2 implements Animal2{ @Override public void say2() { System.out.println(&quot;我是一只狗&quot;); } } Cat2.java package com.java.chap07.sec13; /** * @author Yan * @date 2019/7/20 16:24 */ public class Cat2 implements Animal2 { public void say2() { System.out.println(&quot;我是一个猫&quot;); } } Test2.java package com.java.chap07.sec13; /** * @author Yan * @date 2019/7/20 16:25 */ public class Test2 { public static void main(String[] args) { //父类引用指向Dog类的具体实现 向上转型 Animal2 animal2 = new Dog2(); animal2.say2(); animal2=new Cat2(); animal2.say2(); //向下转型 Dog2 dog2= (Dog2) animal2; dog2.say2(); //向下转型2 不安全 Cat2 cat2= (Cat2) animal2; cat2.say2(); } } 14. Object类 Object类是所有类的父类； package com.java.chap07.sec14; /** * @author Yan * @date 2019/7/20 21:02 */ public class A extends Object{ /** * Object 类是所有类的父类 */ public A(){ super(); } } 1. Object类的常用方法 public String toString(); //返回该对象的字符串表示 代码示例： package com.java.chap07.sec14; /** * @author Yan * @date 2019/7/20 21:04 */ public class People { private String name; public People(String name) { this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return this.getName(); } public static void main(String[] args) { People people=new People(&quot;张三&quot;); System.out.println(people); System.out.println(people.toString()); } } public boolean equals(Object obj); //指示其他某个对象是否与此对象“相等” 代码示例： package com.java.chap07.sec14; /** * @author Yan * @date 2019/7/20 21:04 */ public class People { private String name; public People(String name) { this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return this.getName(); } @Override public boolean equals(Object obj) { String name=((People)obj).getName(); System.out.println(name); return this.name==name; } public static void main(String[] args) { People people=new People(&quot;张三&quot;); People people1=new People(&quot;张三&quot;); People people3=new People(&quot;李四&quot;); System.out.println(&quot;people.equals(people1)&quot;+people.equals(people1)); System.out.println(&quot;people1.equals(people3)&quot;+people1.equals(people3)); System.out.println(people); System.out.println(people.toString()); } } 15. instanceof关键字作用：判断一个对象是否属于一个类格式： 对象 instanceof类 返回布尔类型向下转型作判断； 代码示例： Animal.java package com.java.chap07.sec15; /** * @author Yan * @date 2019/7/20 21:17 */ public class Animal { public void say(){ System.out.println(&quot;我是一个动物&quot;); } } Cat.java package com.java.chap07.sec15; /** * @author Yan * @date 2019/7/20 21:17 */ public class Cat extends Animal { public void say(){ System.out.println(&quot;我是一只猫&quot;); } /** * 子类方法 */ public void f2(){ System.out.println(&quot;我喜欢吃鱼&quot;); } } Dog.java package com.java.chap07.sec15; /** * @author Yan * @date 2019/7/20 21:17 */ public class Dog extends Animal { public void say(){ System.out.println(&quot;我是一只狗&quot;); } /** * 子类方法 */ public void f2(){ System.out.println(&quot;我的名字是jack&quot;); } } Test.java package com.java.chap07.sec15; /** * @author Yan * @date 2019/7/20 21:18 */ public class Test { public static void doSomeThing(Animal animal){ animal.say(); if (animal instanceof Dog){ ((Dog)animal).f2(); } if (animal instanceof Cat){ ((Cat)animal).f2(); } } public static void main(String[] args) { Animal dog=new Dog(); System.out.println(&quot;dog对象是否属于Animal类：&quot;+(dog instanceof Animal)); System.out.println(&quot;dog对象是否属于Dog类：&quot;+(dog instanceof Dog)); System.out.println(&quot;dog对象是否属于Cat类：&quot;+(dog instanceof Cat)); doSomeThing(new Dog()); doSomeThing(new Cat()); } } 16. 匿名内部类作用：假如某个类只使用一次，则可以使用匿名内部类。 代码示例： A.java package com.java.chap07.sec16; /** * @author Yan * @date 2019/7/20 21:34 */ public interface A { public void a(); } B.java package com.java.chap07.sec16; /** * @author Yan * @date 2019/7/20 21:35 */ public class B implements A{ @Override public void a() { System.out.println(&quot;只使用一次&quot;); } } Test.java package com.java.chap07.sec16; /** * @author Yan * @date 2019/7/20 21:35 */ public class Test { public void test(A a){ a.a(); } public static void main(String[] args) { Test test=new Test(); test.test(new B()); //匿名内部类 test.test(new A() { @Override public void a() { System.out.println(&quot;匿名内部类，一次性使用&quot;); } }); } } 17. 包装类每个基本类型都有一个对应的类； 序号 基本类型 包装类 1 int Integer 2 char Character 3 short Short 4 long Long 5 float Float 6 double Double 7 boolean Boolean 8 byte Byte 装箱和拆箱 package com.java.chap07.sec17; /** * @author Yan * @date 2019/7/20 22:02 */ public class Demo1 { public static void main(String[] args) { int a=1; Integer i=new Integer(a); //装箱 把基本变量变成对象变量 int b=i.intValue(); //拆箱 把对象变量变成基本变量 System.out.println(&quot;a=&quot;+a+&quot;,i=&quot;+i+&quot;,b=&quot;+b); } } 自动装箱和拆箱 package com.java.chap07.sec17; /** * @author Yan * @date 2019/7/20 22:05 */ public class Demo2 { public static void main(String[] args) { Integer i=1; //自动装箱的过程 自动把基本数据转换成对象 int i2=i; //自动拆箱 自动把对象转换成基本数据 System.out.println(&quot;i=&quot;+i+&quot;,i2=&quot;+i2); } } 包装类的作用 package com.java.chap07.sec17; /** * @author Yan * @date 2019/7/20 22:07 */ public class Demo3 { public static void main(String[] args) { String a=&quot;1&quot;; String b=&quot;2&quot;; int m=Integer.parseInt(a); int n=Integer.parseInt(b); System.out.println(&quot;a+b=&quot;+(m+n)); } } 18. 设计模式 单例模式在Java应用中，单例对象能保证在一个JVM中，该对象只有一个实例存在。 饿汉式 Singleton1.java package com.java.chap07.sec18; /** * @author Yan * @date 2019/7/21 14:05 */ public class Singleton1 { /** * 构造方法私有 */ private Singleton1(){ } /** * 饿汉式单例实现 */ private static final Singleton1 single1=new Singleton1(); /** * 静态工厂方式 */ public static Singleton1 getInstance(){ return single1; } } TestSingleton.java package com.java.chap07.sec18; /** * @author Yan * @date 2019/7/21 14:06 */ public class TestSingleton { public static void main(String[] args) { //Singleton1 singleton1=new Singleton1(); Singleton1 singleton1=Singleton1.getInstance(); Singleton1 singleton2=Singleton1.getInstance(); System.out.println(&quot;饿汉式：&quot;+(singleton1==singleton2)); TestSingleton testSingleton=new TestSingleton(); TestSingleton testSingleton2=new TestSingleton(); System.out.println(testSingleton==testSingleton2); } } 懒汉式 Singleton2.java package com.java.chap07.sec18; /** * @author Yan * @date 2019/7/21 14:05 */ public class Singleton2 { /** * 构造方法私有 */ private Singleton2(){ } /** * 懒汉式单例实现 在第一次调用的时候实例化 */ private static Singleton2 single; /** * 工厂 */ public synchronized static Singleton2 getInstance(){ if (single==null){ //第一次调用的时候实例化 System.out.println(&quot;第一次调用的时候实例化&quot;); single=new Singleton2(); } return single; } } TestSingleton.java package com.java.chap07.sec18; /** * @author Yan * @date 2019/7/21 14:06 */ public class TestSingleton { public static void main(String[] args) { Singleton2 singleton3=Singleton2.getInstance(); Singleton2 singleton4=Singleton2.getInstance(); System.out.println(&quot;懒汉式：&quot;+(singleton3==singleton4)); } } Java异常处理异常的概念代码示例： package com.java.chap08.sec01; /** * @author Yan * @date 2019/7/21 14:30 */ public class ExceptionDemo { public static void main(String[] args) { String str=&quot;123a&quot;; int a=Integer.parseInt(str); System.out.println(a); } } 捕获和处理异常在Java中，我们用try…catch…来捕获异常； try...catch...finally 代码示例： package com.java.chap08.sec02; /** * @author Yan * @date 2019/7/21 14:32 */ public class Demo1 { public static void main(String[] args) { String str=&quot;123a&quot;; try { int a=Integer.parseInt(str); }catch (NumberFormatException e){ e.printStackTrace(); } System.out.println(&quot;aaaa&quot;); } } package com.java.chap08.sec02; /** * @author Yan * @date 2019/7/21 15:59 */ public class Demo2 { public static void testFinally(){ String str=&quot;123a&quot;; try{ int a=Integer.parseInt(str); System.out.println(a); }catch (Exception e){ e.printStackTrace(); System.out.println(&quot;exception&quot;); return; }finally { System.out.println(&quot;final end&quot;); } System.out.println(&quot;end&quot;); } public static void main(String[] args) { testFinally(); } } throws和throw关键字throws表示当前方法不处理异常，而是交给方法的调用处去处理。throw表示直接抛出一个异常 代码示例： throws package com.java.chap08.sec03; /** * @author Yan * @date 2019/7/21 16:03 */ public class Demo1 { /** * 把异常向外抛 * @throws NumberFormatException */ public static void testThrows() throws NumberFormatException { String str = &quot;123a&quot;; int a = Integer.parseInt(str); System.out.println(a); } public static void main(String[] args) { try { testThrows(); }catch (Exception e){ System.out.println(&quot;在这里处理异常&quot;); e.printStackTrace(); } System.out.println(&quot;I&#39;m here&quot;); } } throw package com.java.chap08.sec03; /** * @author Yan * @date 2019/7/21 16:07 */ public class Demo2 { public static void testThrow(int a) throws Exception{ if (a==1){ //直接抛出一个异常类 throw new Exception(&quot;有异常&quot;); } System.out.println(a); } public static void main(String[] args) { try { testThrow(1); } catch (Exception e) { e.printStackTrace(); } try { testThrow(0); } catch (Exception e) { e.printStackTrace(); } } } Exception和RuntimeException区别Exception 是检查型异常，例如Exception在程序中必须使用try…catch进行处理； RuntimeException 是非检查型异常，例如NumberFormatException，可以不使用try…catch进行处理，但是如果产生异常，则异常将由JVM进行处理； RuntimeException 最好也用try…catch捕获。 代码示例： package com.java.chap08.sec04; /** * @author Yan * @date 2019/7/21 16:12 */ public class Demo1 { /** * 运行时异常，编译时不检查，可以不适用try...catch捕获 * @throws RuntimeException */ public static void testRuntimeException() throws RuntimeException { throw new RuntimeException(&quot;运行时异常&quot;); } /** * Exception异常，编译时异常，必须使用try...catch捕获 * @throws Exception */ public static void testException() throws Exception{ throw new Exception(&quot;Exception异常&quot;); } public static void main(String[] args) { try{ testRuntimeException(); }catch (Exception e){ e.printStackTrace(); } try { testException(); } catch (Exception e) { e.printStackTrace(); } } } 自定义异常类代码示例： CustomerException.java package com.java.chap08.sec05; /** * 自定义异常，继承自Exception * @author Yan * @date 2019/7/21 16:18 */ public class CustomerException extends Exception{ public CustomerException(String message){ super(message); } } TestCustomerException.java package com.java.chap08.sec05; /** * @author Yan * @date 2019/7/21 16:19 */ public class TestCustomerException { public static void test() throws CustomerException{ throw new CustomerException(&quot;自定义异常&quot;); } public static void main(String[] args) { try { test(); } catch (CustomerException e) { e.printStackTrace(); } } } Java常用类Java日期处理类 Date类 package com.java.chap09.sec01; import java.util.Date; /** * 日期类Date * @author Yan * @date 2019/7/21 20:56 */ public class TestDate { public static void main(String[] args) { Date date=new Date(); System.out.println(&quot;当前日期：&quot;+date); } } Calendar类 package com.java.chap09.sec01; import java.util.Calendar; /** * @author Yan * @date 2019/7/21 20:58 */ public class TestCalendar { public static void main(String[] args) { Calendar calendar = Calendar.getInstance(); System.out.println(calendar.get(Calendar.YEAR)); System.out.println(calendar.get(Calendar.MONTH) + 1); System.out.println(&quot;现在是&quot; + calendar.get(Calendar.YEAR) + &quot;年&quot; + (calendar.get(Calendar.MONTH) + 1) + &quot;月&quot; + calendar.get(Calendar.DAY_OF_MONTH) + &quot;日&quot; + calendar.get(Calendar.HOUR_OF_DAY) + &quot;时&quot; + calendar.get(Calendar.MINUTE) + &quot;分&quot; + calendar.get(Calendar.SECOND) + &quot;秒&quot;); } } SimpleDateFormat package com.java.chap09.sec01; import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Date; /** * @author Yan * @date 2019/7/21 21:05 */ public class TestSimpleDateFormat { /** * 将日期对象格式为指定格式的日期字符串 * @param date 传入的日期对象 * @param format 格式 * @return */ public static String formatDate(Date date,String format){ String result=&quot;&quot;; SimpleDateFormat sdf=new SimpleDateFormat(format); if (date!=null){ result=sdf.format(date); } return result; } /** * 将日期字符串转换成一个日期对象 * @param dataStr 日期字符串 * @param format 格式 * @return */ public static Date formatDate(String dataStr,String format) throws ParseException { SimpleDateFormat sdf=new SimpleDateFormat(format); return sdf.parse(dataStr); } public static void main(String[] args) throws ParseException { Date date=new Date(); //SimpleDateFormat sdf=new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); //System.out.println(sdf.format(date)); String dataStr=&quot;2010-07-21 21:12:26&quot;; Date date1=formatDate(dataStr,&quot;yyyy-MM-dd HH:mm:ss&quot;); System.out.println(formatDate(date,&quot;yyyy-MM-dd HH:mm:ss&quot;)); System.out.println(formatDate(date1,&quot;yyyy-MM-dd HH:mm:ss&quot;)); } } String VS StringBufferString：对String类型的对象操作，等同于重新生成一个对象，然后将引用指向它； StringBuffer：对StringBuffer类型的对象操作，操作的始终是用一个对象。 String 代码示例： package com.java.chap09.sec02; /** * @author Yan * @date 2019/7/22 14:00 */ public class TestString { public static void main(String[] args) { String str=&quot;123&quot;; str+=&quot;abc&quot;; System.out.println(str); } } StringBuffer 代码示例： package com.java.chap09.sec02; /** * @author Yan * @date 2019/7/22 14:01 */ public class TestStringBuffer { public static void main(String[] args) { StringBuffer sb=new StringBuffer(&quot;123&quot;); sb.append(&quot;abc&quot;); System.out.println(sb); } } Math类 max方法：求最大值 min方法：求最小值 round方法：四舍五入 pow方法：求次幂 代码示例： package com.java.chap09.sec03; /** * @author Yan * @date 2019/7/22 14:10 */ public class TestMath { public static void main(String[] args) { System.out.println(&quot;最大值：&quot;+Math.max(1,2)); System.out.println(&quot;最小值：&quot;+Math.min(1,2)); System.out.println(&quot;四舍五入：&quot;+Math.round(12.4)); System.out.println(&quot;次幂：&quot;+Math.pow(3,4)); } } Arrays类 toString()方法：返回指定数组内容的字符串表示形式 sort()方法：对指定的类型数组按数字升序进行排序 binarySearch()方法：使用二分搜索法来搜索指定类型数组，以获得指定的值 fill()方法：将指定类型值分配给指定类型数组的每个元素 代码示例： package com.java.chap09.sec04; import java.util.Arrays; /** * @author Yan * @date 2019/7/22 14:36 */ public class TestArrays { public static void main(String[] args) { int arr[]={1,7,3,8,2}; System.out.println(&quot;以字符串形式输出数组：&quot;+Arrays.toString(arr)); Arrays.sort(arr); //给数组排序 System.out.println(&quot;排序后的数组&quot;+Arrays.toString(arr)); System.out.println(Arrays.binarySearch(arr,7)); Arrays.fill(arr,0); //将指定内容填充到数组中 System.out.println(&quot;填充数组后的字符串：&quot;+Arrays.toString(arr)); } } Java泛型泛型引入定义：使用泛型可以指代任意对象类型 代码示例： C1.java package com.java.chap10.sec01; /** * @author Yan * @date 2019/7/22 16:00 */ public class C1 { private Integer a; public C1(Integer a) { super(); this.a = a; } public Integer getA() { return a; } public void setA(Integer a) { this.a = a; } /** * 打印a的类型 */ public void print(){ System.out.println(&quot;a的类型是：&quot;+a.getClass().getName()); } } C2.java package com.java.chap10.sec01; /** * @author Yan * @date 2019/7/22 16:02 */ public class C2 { private String a; public C2(String a) { super(); this.a = a; } public String getA() { return a; } public void setA(String a) { this.a = a; } /** * 打印a的类型 */ public void print(){ System.out.println(&quot;a的类型是：&quot;+a.getClass().getName()); } } C12.java package com.java.chap10.sec01; /** * @author Yan * @date 2019/7/22 16:09 */ public class C12 { private Object object; public C12(Object object) { super(); this.object = object; } public Object getObject() { return object; } public void setObject(Object object) { this.object = object; } /** * 打印object的类型 */ public void print(){ System.out.println(&quot;a的类型是：&quot;+object.getClass().getName()); } } CC.java package com.java.chap10.sec01; /** * 定义泛型类 * @author Yan * @date 2019/7/24 15:56 */ public class CC&lt;T&gt; { private T ob; public CC(T ob) { super(); this.ob = ob; } public T getOb() { return ob; } public void setOb(T ob) { this.ob = ob; } /** * 打印T的类型 */ public void print(){ System.out.println(&quot;T的实际类型&quot;+ob.getClass().getName());; } } Test.java package com.java.chap10.sec01; /** * @author Yan * @date 2019/7/22 16:03 */ public class Test1 { public static void main(String[] args) { //begin test c1 C1 c1=new C1(1); c1.print(); int i=c1.getA(); System.out.println(&quot;i=&quot;+i); //end test c1 //begin test c2 C2 c2=new C2(&quot;Hi&quot;); c2.print(); String s1=c2.getA(); System.out.println(&quot;s1=&quot;+s1); //end test c2 //begin test c12 C12 c12=new C12(1); //向上转型 c12.print(); int i12= (Integer) c12.getObject(); //向下转型 System.out.println(&quot;i12=&quot;+i12); C12 c121=new C12(&quot;你好&quot;); //向上转型 c121.print(); String i121=(String) c121.getObject(); //向下转型 System.out.println(&quot;i121=&quot;+i121); //end test c12 //begin test CC CC&lt;Integer&gt; cc=new CC&lt;Integer&gt;(1); cc.print(); int icc=cc.getOb(); System.out.println(&quot;icc=&quot;+icc); //end test CC //begin test CC CC&lt;String&gt; cc1=new CC&lt;String&gt;(&quot;你好&quot;); cc1.print(); String icc1=cc1.getOb(); System.out.println(&quot;icc1=&quot;+icc1); //end test CC } } 限制泛型代码示例： Animal.java package com.java.chap10.sec02; /** * @author Yan * @date 2019/7/24 16:07 */ public class Animal { public void print(){ System.out.println(&quot;动物&quot;); } } Cat.java package com.java.chap10.sec02; /** * @author Yan * @date 2019/7/24 16:07 */ public class Cat extends Animal{ public void print(){ System.out.println(&quot;Cat&quot;); } } Dog.java package com.java.chap10.sec02; /** * @author Yan * @date 2019/7/24 16:07 */ public class Dog extends Animal{ public void print(){ System.out.println(&quot;Dog&quot;); } } Demo.java package com.java.chap10.sec02; /** * @author Yan * @date 2019/7/24 16:08 */ public class Demo &lt;T extends Animal&gt;{ private T ob; public Demo(T ob) { super(); this.ob = ob; } public T getOb() { return ob; } public void setOb(T ob) { this.ob = ob; } public void print(){ System.out.println(&quot;T的类型是： &quot;+ob.getClass().getName()); } } Test.java package com.java.chap10.sec02; /** * @author Yan * @date 2019/7/24 16:11 */ public class Test { public static void main(String[] args) { Demo&lt;Dog&gt; demo=new Demo&lt;Dog&gt;(new Dog()); Dog dog=demo.getOb(); dog.print(); Demo&lt;Cat&gt; demo2=new Demo&lt;Cat&gt;(new Cat()); Cat cat=demo2.getOb(); cat.print(); //Demo&lt;Integer&gt; demo3=new Demo&lt;Integer&gt;(2); Demo&lt;Animal&gt; demo3=new Demo&lt;Animal&gt;(new Animal()); } } 通配符泛型代码示例： Test.java package com.java.chap10.sec03; import com.java.chap10.sec02.Animal; import com.java.chap10.sec02.Cat; import com.java.chap10.sec02.Demo; import com.java.chap10.sec02.Dog; /** * @author Yan * @date 2019/7/24 16:23 */ public class Test { /** * 通配符泛型 * @param animal */ private static void take(Demo&lt;?&gt; animal){ animal.print(); } public static void main(String[] args) { Demo&lt;Dog&gt; dog=new Demo&lt;Dog&gt;(new Dog()); take(dog); Demo&lt;Cat&gt; cat=new Demo&lt;Cat&gt;(new Cat()); take(cat); Demo&lt;Animal&gt; animalDemo=new Demo&lt;Animal&gt;(new Animal()); take(animalDemo); } } 泛型方法代码示例： package com.java.chap10.sec04; /** * @author Yan * @date 2019/7/24 19:39 */ public class Test { /** * 泛型方法 * @param t * @param &lt;T&gt; */ public static &lt;T&gt; void f(T t){ System.out.println(&quot;T的类型是：&quot;+t.getClass().getName()); } public static void main(String[] args) { f(&quot;&quot;); f(1); f(1.0); f(new Object()); } } Java集合Java集合的引入代码示例： Student.java package com.java.chap11.sec01; /** * @author Yan * @date 2019/7/25 14:40 */ public class Student { private String name; private int age; public Student(String name, int age) { super(); this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } } Demo.java package com.java.chap11.sec01; import java.util.LinkedList; /** * @author Yan * @date 2019/7/25 14:41 */ public class Demo { public static void main(String[] args) { Student student[]=new Student[3]; Student student1=new Student(&quot;张三&quot;,1); Student student2=new Student(&quot;李四&quot;,3); Student student3=new Student(&quot;王五&quot;,4); LinkedList&lt;Student&gt; list=new LinkedList&lt;Student&gt;(); list.add(student1); list.add(student2); list.add(student3); /** * 遍历集合 */ for (int i=0;i&lt;list.size();i++){ Student student4=list.get(i); System.out.println(student4.getName()+&quot;:&quot;+student4.getAge()); } } } List集合是Collection接口的子接口，也是最常用的接口。此接口对Collection接口进行了大量的扩展，List集合里的元素是允许重复的。 ArrayList实现类 代码实现： package com.java.chap11.sec02; import java.util.ArrayList; /** * @author Yan * @date 2019/7/25 15:09 */ public class TestArrayList { public static void printArrayList(ArrayList&lt;String&gt; arrayList){ System.out.println(&quot;当前的集合元素&quot;); for (int i=0;i&lt;arrayList.size();i++){ System.out.print(arrayList.get(i)+&quot; &quot;); } System.out.println(); } public static void main(String[] args) { ArrayList&lt;String&gt; arrayList=new ArrayList&lt;String&gt;(); //添加元素 arrayList.add(&quot;张三&quot;); arrayList.add(&quot;李四&quot;); printArrayList(arrayList); //将指定的元素插入此列表中的指定位置 arrayList.add(1,&quot;小张三&quot;); printArrayList(arrayList); //用指定的元素替代此列表指定位置上的元素 arrayList.set(2,&quot;小李四&quot;); printArrayList(arrayList); //移除此列表中指定位上的元素 arrayList.remove(0); printArrayList(arrayList); } } LinkedList实现类 代码示例： package com.java.chap11.sec02; import java.util.LinkedList; /** * @author Yan * @date 2019/7/25 15:36 */ public class TestLinkedList { public static void printLinkedList(LinkedList&lt;String&gt; linkedList){ System.out.println(&quot;当前元素集合：&quot;); for (int i=0;i&lt;linkedList.size();i++){ System.out.print(linkedList.get(i)+&quot; &quot;); } System.out.println(); } public static void main(String[] args) { LinkedList&lt;String&gt; linkedList=new LinkedList&lt;String&gt;(); linkedList.add(&quot;张三&quot;); linkedList.add(&quot;李四&quot;); linkedList.add(&quot;王五&quot;); linkedList.add(&quot;李四&quot;); linkedList.add(&quot;赵六&quot;); printLinkedList(linkedList); //返回此列表中首次出现的指定元素的索引，如果此列表中不包括该元素，则返回-1； System.out.println(linkedList.indexOf(&quot;李四&quot;)); //获取但不移除此列表的第一个元素；如果此列表为空，则返回null System.out.println(linkedList.peekFirst()); printLinkedList(linkedList); //获取但不移除此列表的最后一个元素；如果此列表为空，则返回null System.out.println(linkedList.peekLast()); printLinkedList(linkedList); //获取并移除此列表的第一个元素；如果此列表为空，则返回null System.out.println(linkedList.pollFirst()); printLinkedList(linkedList); //获取并移除此列表的最后一个元素；如果此列表为空，则返回null System.out.println(linkedList.pollLast()); printLinkedList(linkedList); } } 集合的遍历 Iterator 代码示例： package com.java.chap11.sec03; import com.java.chap11.sec01.Student; import java.util.Iterator; import java.util.LinkedList; /** * @author Yan * @date 2019/7/25 15:51 */ public class TestIterator { public static void main(String[] args) { LinkedList&lt;Student&gt; list=new LinkedList&lt;Student&gt;(); list.add(new Student(&quot;张三&quot;,10)); list.add(new Student(&quot;李四&quot;,20)); list.add(new Student(&quot;王五&quot;,30)); /** * 用Iterator遍历集合 */ Iterator&lt;Student&gt; iterator=list.iterator(); //返回一个迭代器 while(iterator.hasNext()){ Student s=iterator.next(); //返回迭代的下一个元素 System.out.println(&quot;姓名：&quot;+s.getName()+&quot; 年龄：&quot;+s.getAge()); } } } foreach 代码示例： package com.java.chap11.sec03; import com.java.chap11.sec01.Student; import java.util.Iterator; import java.util.LinkedList; /** * @author Yan * @date 2019/7/25 15:57 */ public class TestForeach { public static void main(String[] args) { LinkedList&lt;Student&gt; list=new LinkedList&lt;Student&gt;(); list.add(new Student(&quot;张三&quot;,10)); list.add(new Student(&quot;李四&quot;,20)); list.add(new Student(&quot;王五&quot;,30)); /** * 用Foreach遍历集合 */ for (Student s:list){ System.out.println(&quot;姓名：&quot;+s.getName()+&quot; 年龄：&quot;+s.getAge()); } } } Set集合是Collertion接口的子接口，没有对Collection接口进行扩展，里面不允许存重复的内容。 HashSet类 代码示例： package com.java.chap11.sec04; import java.util.HashSet; import java.util.Iterator; /** * @author Yan * @date 2019/7/25 16:02 */ public class TestHashSet { public static void main(String[] args) { /** * 1. HashSet是无序的 * 2. 不允许有重复值 */ HashSet&lt;String&gt; hashSet=new HashSet&lt;String&gt;(); hashSet.add(&quot;1&quot;); hashSet.add(&quot;2&quot;); hashSet.add(&quot;5&quot;); hashSet.add(&quot;4&quot;); hashSet.add(&quot;2&quot;); /** * 用Iterator遍历集合 */ Iterator&lt;String&gt; iterator=hashSet.iterator(); while (iterator.hasNext()){ String s=iterator.next(); System.out.println(s+&quot; &quot;); } } } Map集合是存放一对值的最大接口，即接口中的每一个元素都是一对，以key-&gt;value键值对的形式保存。 HashMap类 代码示例： package com.java.chap11.sec05; import com.java.chap11.sec01.Student; import java.util.HashMap; import java.util.Iterator; /** * @author Yan * @date 2019/7/25 16:08 */ public class TestHashMap { public static void main(String[] args) { HashMap&lt;String, Student&gt; hashMap=new HashMap&lt;String,Student&gt;(); hashMap.put(&quot;1号&quot;,new Student(&quot;张三&quot;,10)); hashMap.put(&quot;2号&quot;,new Student(&quot;李四&quot;,20)); hashMap.put(&quot;3号&quot;,new Student(&quot;王五&quot;,30)); // 通过key获取value Student student=hashMap.get(&quot;1号&quot;); System.out.println(student.getName()+&quot;:&quot;+student.getAge()); Iterator&lt;String&gt; iterator=hashMap.keySet().iterator(); //获取key的集合，再获取迭代器 while (iterator.hasNext()){ String key=iterator.next(); //获取key Student student1=hashMap.get(key); //通过key获取value System.out.println(&quot;key=&quot;+key+&quot;value=[&quot;+student1.getName()+&quot;,&quot;+student1.getAge()+&quot;]&quot;); } } } Java多线程多线程的引入定义：同时对多项任务加以控制 代码示例： Demo.java package com.java.chap12.sec01; /** * @author Yan * @date 2019/7/27 13:15 */ public class Demo1 { /** * 听音乐 */ private static void music(){ for (int i=0;i&lt;1000;i++){ System.out.println(&quot;听音乐&quot;); } } /** * 吃饭 * */ private static void eat(){ for (int i=0;i&lt;1000;i++){ System.out.println(&quot;吃饭&quot;); } } public static void main(String[] args) { //music(); //eat(); /** * 利用多线程实现一边吃饭一边听歌 */ Music musicThread=new Music(); Eat eatThread=new Eat(); musicThread.start(); eatThread.start(); } } Eat.java package com.java.chap12.sec01; /** * @author Yan * @date 2019/7/27 13:18 */ public class Eat extends Thread { @Override public void run() { for (int i=0;i&lt;1000;i++){ try { Thread.sleep(100); System.out.println(&quot;吃饭&quot;); } catch (InterruptedException e) { e.printStackTrace(); } } } } Music.java package com.java.chap12.sec01; /** * @author Yan * @date 2019/7/27 13:19 */ public class Music extends Thread { @Override public void run() { for (int i=0;i&lt;1000;i++){ try { Thread.sleep(100); System.out.println(&quot;听音乐&quot;); } catch (InterruptedException e) { e.printStackTrace(); } } } } Java多线程实现 继承Thread类 代码示例： package com.java.chap12.sec02; /** * @author Yan * @date 2019/7/27 13:24 */ public class Thread1 extends Thread { private int baoZi=1; private String threadName; public Thread1(String threadName) { super(); this.threadName = threadName; } @Override public synchronized void run() { while (baoZi&lt;=10){ System.out.println(threadName+&quot;吃第&quot;+baoZi+&quot;包子&quot;); baoZi++; } } public static void main(String[] args) { System.out.println(&quot;张三，李四一起吃包子，每人吃了10个&quot;); Thread1 t1=new Thread1(&quot;张三线程&quot;); Thread1 t2=new Thread1(&quot;李四线程&quot;); t1.start(); t2.start(); } } 实现Runnable接口 代码示例： package com.java.chap12.sec02; /** * @author Yan * @date 2019/7/27 13:29 */ public class Thread2 implements Runnable { private int baoZi=1; private String threadName; public Thread2(String threadName) { super(); this.threadName = threadName; } @Override public synchronized void run() { while (baoZi&lt;=10){ System.out.println(threadName+&quot;吃第&quot;+baoZi+&quot;包子&quot;); baoZi++; } } public static void main(String[] args) { //System.out.println(&quot;张三，李四一起吃包子，每人吃了10个&quot;); //Thread2 t1=new Thread2(&quot;张三线程&quot;); //Thread2 t2=new Thread2(&quot;李四线程&quot;); //Thread t11=new Thread(t1); //Thread t12=new Thread(t2); //t11.start(); //t12.start(); Thread2 t1=new Thread2(&quot;超级张三线程&quot;); Thread t11=new Thread(t1); Thread t12=new Thread(t1); Thread t13=new Thread(t1); Thread t14=new Thread(t1); //实现资源共享 t11.start(); t12.start(); t13.start(); t14.start(); } } 线程状态 创建状态在程序中用构造方法创建了一个线程对象后，新的线程对象便处于新建状态，此时，它已经有了相应的内存空间和其他资源，但还处于不可运行状态。新建一个线程对象可采用Thread类的构造方法来实现，例如，“Thread thread=new Thread();”。 就绪状态新建线程对象后，调用该线程的start()方法就可以启动线程。当线程启动时，线程进入就绪状态。此时，线程将进入线程队列排队，等待CPU服务，这表明它已经具备了运行条件。 运行状态当就绪状态的线程被调用并获得处理器资源时，线程就进入了运行状态。此时，自动调用该线程对象的run()方法。run()方法定义了该线程的操作和功能。 堵塞状态一个正在运行的线程在某些特殊情况下，如被人为挂起或需要执行耗时的输入/输出操作时，将让出CPU并暂时中止自己的执行，进入堵塞状态，堵塞时，线程不能进入排队队列，只有当引起堵塞的原因被消除后，线程才可以转入就绪状态。 死亡状态线程调用stop()方法时或run()方法执行结束后，即处于死亡状态。处于死亡状态的线程不具有继续运行的能力。 线程常用方法 getName(); 返回该线程的名称。 currentThread(); 返回对当前正在执行的线程对象的引用。 isAlive(); 测试线程是否处于活动状态。 sleep(); 线程休眠。 setPriority(int newPriority); 更改线程的优先级。 yield(); 暂停当前正在执行的线程对象，并执行其他线程。 代码示例： getName()、currentThread() package com.java.chap12.sec04; import javax.swing.plaf.TableHeaderUI; /** * @author Yan * @date 2019/7/27 14:23 */ public class Demo1 implements Runnable{ @Override public void run() { for (int i=0;i&lt;10;i++){ //获取当前线程 Thread t=Thread.currentThread(); System.out.println(t.getName()+&quot;:&quot;+i); //返回线程的名称 } } public static void main(String[] args) { Demo1 demo1=new Demo1(); new Thread(demo1).start(); new Thread(demo1).start(); new Thread(demo1,&quot;线程3&quot;).start(); } } isAlive() package com.java.chap12.sec04; /** * @author Yan * @date 2019/7/27 14:35 */ public class Demo2 implements Runnable{ @Override public void run() { for (int i=0;i&lt;10;i++){ //获取当前线程 Thread t=Thread.currentThread(); System.out.println(t.getName()+&quot;:&quot;+i); //返回线程的名称 } } public static void main(String[] args) { Demo2 demo2=new Demo2(); Thread t1=new Thread(demo2); System.out.println(&quot;t1是否活动：&quot;+t1.isAlive()); t1.start(); System.out.println(&quot;t1是否活动：&quot;+t1.isAlive()); } } sleep() package com.java.chap12.sec04; /** * @author Yan * @date 2019/7/27 14:35 */ public class Demo3 implements Runnable{ @Override public void run() { for (int i=0;i&lt;10;i++){ try { Thread.sleep(1000); //获取当前线程 Thread t=Thread.currentThread(); System.out.println(t.getName()+&quot;:&quot;+i); //返回线程的名称 } catch (InterruptedException e) { e.printStackTrace(); } } } public static void main(String[] args) { Demo3 demo2=new Demo3(); Thread t1=new Thread(demo2); t1.start(); } } setPriority(int newPriority) package com.java.chap12.sec04; /** * @author Yan * @date 2019/7/27 14:35 */ public class Demo4 implements Runnable{ @Override public void run() { for (int i=0;i&lt;10;i++){ try { Thread.sleep(1000); //获取当前线程 Thread t=Thread.currentThread(); System.out.println(t.getName()+&quot;:&quot;+i); //返回线程的名称 } catch (InterruptedException e) { e.printStackTrace(); } } } public static void main(String[] args) { Demo4 demo4=new Demo4(); Thread t1=new Thread(demo4,&quot;线程A&quot;); Thread t2=new Thread(demo4,&quot;线程B&quot;); Thread t3=new Thread(demo4,&quot;线程C&quot;); t1.setPriority(Thread.MAX_PRIORITY); t2.setPriority(Thread.MIN_PRIORITY); t3.setPriority(Thread.NORM_PRIORITY); t1.start(); t2.start(); t3.start(); } } yield() package com.java.chap12.sec04; /** * @author Yan * @date 2019/7/27 14:35 */ public class Demo5 implements Runnable { @Override public void run() { for (int i = 0; i &lt; 10; i++) { try { Thread.sleep(1000); //获取当前线程 Thread t = Thread.currentThread(); System.out.println(t.getName() + &quot;:&quot; + i); //返回线程的名称 if (i==5){ System.out.println(&quot;线程礼让&quot;); Thread.currentThread().yield(); } } catch (InterruptedException e) { e.printStackTrace(); } } } public static void main(String[] args) { Demo5 demo5 = new Demo5(); new Thread(demo5, &quot;线程A&quot;).start(); new Thread(demo5, &quot;线程B&quot;).start(); } } 线程同步 同步方法 同步锁 代码示例： Demo2.java package com.java.chap12.sec05; /** * @author Yan * @date 2019/7/27 14:54 */ public class Demo2 implements Runnable { private int baoZi=10; /** * 同步方法 */ @Override public synchronized void run() { while (baoZi&gt;0){ System.out.println(Thread.currentThread().getName()+&quot;吃了第&quot;+baoZi+&quot;包子&quot;); baoZi--; } } public static void main(String[] args) { Demo2 demo1=new Demo2(); new Thread(demo1,&quot;张三&quot;).start(); new Thread(demo1,&quot;李四&quot;).start(); new Thread(demo1,&quot;王五&quot;).start(); } } Demo3.java package com.java.chap12.sec05; /** * @author Yan * @date 2019/7/27 14:54 */ public class Demo3 implements Runnable { private int baoZi = 10; @Override public void run() { /** * 同步块 */ synchronized (this) { while (baoZi &gt; 0) { System.out.println(Thread.currentThread().getName() + &quot;吃了第&quot; + baoZi + &quot;包子&quot;); baoZi--; } } } public static void main(String[] args) { Demo3 demo1 = new Demo3(); new Thread(demo1, &quot;张三&quot;).start(); new Thread(demo1, &quot;李四&quot;).start(); new Thread(demo1, &quot;王五&quot;).start(); } } Java图形界面Swing框架Swing简介 Swing是Java的一个图形框架，继承自AWT； Swing主要涉及到容器，组件，还有布局管理器； Swing与用户交互的时候还涉及到事件概念 JFrame容器 public void setVisible(boolean b):根据参数b的值显示或隐藏此窗体 public void setSize(int width,int height):调整组件的大小，使其宽度为width，高度为height public void setLocation(int x,.int y):将组件移到新位置。通过此组件父级坐标空间中的x和y参数来指定新位置的左上角 public Container getContentPane():返回此窗体的contentPane对象 public void setBackground(Color c):设置组件的背景色 代码示例： package com.java.chap13.sec02; import javax.swing.*; import java.awt.*; /** * @author Yan * @date 2019/7/27 15:38 */ public class JFrameTest { public static void main(String[] args) { JFrame jFrame=new JFrame(&quot;JFrame窗体&quot;); /*Container c=jFrame.getContentPane(); c.setBackground(Color.blue);*/ jFrame.getContentPane().setBackground(Color.red); //设置容器的背景颜色 jFrame.setLocation(300,200); //设置容器的位置 jFrame.setSize(500,500); //设置容器大小 jFrame.setVisible(true); //让容器显示 } } JButton组件代码示例： package com.java.chap13.sec03; import javax.swing.*; import java.awt.*; /** * @author Yan * @date 2019/7/27 16:18 */ public class JButtonTest { public static void main(String[] args) { JFrame jFrame=new JFrame(&quot;JButton测试&quot;); JButton jButton=new JButton(&quot;这是一个按钮&quot;); jFrame.add(jButton); jFrame.getContentPane().setBackground(Color.red); //设置容器的背景颜色 jFrame.setLocation(300,200); //设置容器的位置 jFrame.setSize(500,500); //设置容器大小 jFrame.setVisible(true); //让容器显示 jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } } Swing布局管理器 FlowLayout流式布局使用此种布局方式会使所有的组件像流水一样依次进行排列 代码示例： package com.java.chap13.sec04; import javax.swing.*; import java.awt.*; /** * FlowLayout流式布局 * @author Yan * @date 2019/7/27 16:26 */ public class FlowLayout { public static void main(String[] args) { JFrame jFrame=new JFrame(&quot;FlowLayout测试&quot;); //jFrame.setLayout(new java.awt.FlowLayout()); //jFrame.setLayout(new java.awt.FlowLayout(java.awt.FlowLayout.LEFT)); jFrame.setLayout(new java.awt.FlowLayout(java.awt.FlowLayout.LEFT,15,15)); JButton jButton=null; for(int i=0;i&lt;9;i++){ jButton=new JButton(&quot;JButton&quot;+i); jFrame.add(jButton); } jFrame.getContentPane().setBackground(Color.red); //设置容器的背景颜色 jFrame.setLocation(300,200); //设置容器的位置 jFrame.setSize(500,500); //设置容器大小 jFrame.setVisible(true); //让容器显示 jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } } BorderLayout使用此种布局方式将一个窗体的版面划分成东、西、南、北、中5个区域，可以直接将需要的组件放到这5个区域中 代码示例： package com.java.chap13.sec04; import javax.swing.*; import java.awt.*; /** * * @author Yan * @date 2019/7/28 15:35 */ public class BorderLayoutTest { public static void main(String[] args) { JFrame jFrame=new JFrame(&quot;BorderLayout测试&quot;); //jFrame.setLayout(new BorderLayout()); jFrame.setLayout(new BorderLayout(5,5)); jFrame.add(new JButton(&quot;东&quot;),BorderLayout.EAST); jFrame.add(new JButton(&quot;西&quot;),BorderLayout.WEST); jFrame.add(new JButton(&quot;南&quot;),BorderLayout.SOUTH); jFrame.add(new JButton(&quot;北&quot;),BorderLayout.NORTH); jFrame.add(new JButton(&quot;中&quot;),BorderLayout.CENTER); jFrame.getContentPane().setBackground(Color.red); //设置容器的背景颜色 jFrame.setLocation(300,200); //设置容器的位置 jFrame.setSize(500,500); //设置容器大小 jFrame.setVisible(true); //让容器显示 jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } } GridLayout表格布局使用此种布局是以表格的形式进行布局管理的，在使用此布局管理器时必须设置显示的行数和列数 代码示例： package com.java.chap13.sec04; import javax.swing.*; import java.awt.*; /** * @author Yan * @date 2019/7/28 15:39 */ public class GridLayoutTest { public static void main(String[] args) { JFrame jFrame=new JFrame(&quot;GridLayout测试&quot;); jFrame.setLayout(new GridLayout(4,5,5,5)); JButton jButton=null; for (int i=0;i&lt;19;i++){ jButton=new JButton(&quot;JButton&quot;+i); jFrame.add(jButton); } jFrame.getContentPane().setBackground(Color.red); //设置容器的背景颜色 jFrame.setLocation(300,200); //设置容器的位置 jFrame.setSize(500,500); //设置容器大小 jFrame.setVisible(true); //让容器显示 jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } } 绝对布局 代码示例： package com.java.chap13.sec04; import javax.swing.*; import java.awt.*; /** * @author Yan * @date 2019/7/28 15:44 */ public class AbsoluteLayoutTest { public static void main(String[] args) { JFrame jFrame=new JFrame(&quot;绝对布局测试&quot;); jFrame.setLayout(null); JButton jButton1=new JButton(&quot;按钮1&quot;); JButton jButton2=new JButton(&quot;按钮2&quot;); jFrame.add(jButton1); jFrame.add(jButton2); jButton1.setBounds(50,10,100,20); jButton2.setBounds(70,40,200,30); jFrame.getContentPane().setBackground(Color.red); //设置容器的背景颜色 jFrame.setLocation(300,200); //设置容器的位置 jFrame.setSize(500,500); //设置容器大小 jFrame.setVisible(true); //让容器显示 jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } } JLable 组件代码示例： package com.java.chap13.sec05; import javax.swing.*; import java.awt.*; /** * @author Yan * @date 2019/7/28 16:02 */ public class JLableTest { public static void main(String[] args) { JFrame jFrame=new JFrame(&quot;JLable测试&quot;); JLabel jLabel=new JLabel(&quot;JLable组件&quot;,JLabel.CENTER); jFrame.add(jLabel); jFrame.getContentPane().setBackground(Color.red); //设置容器的背景颜色 jFrame.setLocation(300,200); //设置容器的位置 jFrame.setSize(500,500); //设置容器大小 jFrame.setVisible(true); //让容器显示 jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } } 文本框组件 JTextField 文本框 代码示例： package com.java.chap13.sec06; import javax.swing.*; import java.awt.*; /** * @author Yan * @date 2019/7/28 16:17 */ public class JTextFiledTest { public static void main(String[] args) { JFrame jFrame=new JFrame(&quot;JTextFiled单行文本框测试&quot;); jFrame.setLayout(new GridLayout(1,2,10,10)); JLabel jLabel=new JLabel(&quot;用户名：&quot;); JTextField jTextField=new JTextField(); jFrame.add(jLabel); jFrame.add(jTextField); jFrame.getContentPane().setBackground(Color.red); //设置容器的背景颜色 jFrame.setLocation(300,200); //设置容器的位置 jFrame.setSize(500,500); //设置容器大小 jFrame.setVisible(true); //让容器显示 jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } } JPasswordField 密码框 代码示例： package com.java.chap13.sec06; import javax.swing.*; import java.awt.*; /** * @author Yan * @date 2019/7/28 16:42 */ public class JPasswordFiledTest { public static void main(String[] args) { JFrame jFrame = new JFrame(&quot;JPasswordFiled密码框测试&quot;); jFrame.setLayout(new GridLayout(2, 2, 10, 10)); JLabel jLabel = new JLabel(&quot;用户名：&quot;); JTextField jTextField = new JTextField(); JLabel jLabe2 = new JLabel(&quot;密码：&quot;); JPasswordField jPasswordField=new JPasswordField(); jFrame.add(jLabel); jFrame.add(jTextField); jFrame.add(jLabe2); jFrame.add(jPasswordField); jFrame.getContentPane().setBackground(Color.red); //设置容器的背景颜色 jFrame.setLocation(300, 200); //设置容器的位置 jFrame.setSize(500, 500); //设置容器大小 jFrame.setVisible(true); //让容器显示 jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } } JTextArea 文本域 代码示例： package com.java.chap13.sec06; import javax.swing.*; import java.awt.*; /** * @author Yan * @date 2019/7/28 16:17 */ public class JTextAreaTest { public static void main(String[] args) { JFrame jFrame = new JFrame(&quot;JTextArea文本域测试&quot;); jFrame.setLayout(new GridLayout(1, 2, 10, 10)); JLabel jLabel = new JLabel(&quot;描述：&quot;); JTextArea jTextArea = new JTextArea(); jFrame.add(jLabel); jFrame.add(jTextArea); jFrame.getContentPane().setBackground(Color.red); //设置容器的背景颜色 jFrame.setLocation(300, 200); //设置容器的位置 jFrame.setSize(500, 500); //设置容器大小 jFrame.setVisible(true); //让容器显示 jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } } JPanel 轻量级容器代码示例： package com.java.chap13.sec07; import javax.swing.*; import javax.swing.border.EmptyBorder; import java.awt.*; /** * @author Yan * @date 2019/7/28 16:50 */ public class JPanelTest { public static void main(String[] args) { JFrame jFrame = new JFrame(&quot;JPanel面板测试&quot;); JPanel jPanel=new JPanel(); jPanel.setLayout(new GridLayout(3,2,10,10)); jFrame.add(jPanel); jPanel.setBorder(new EmptyBorder(10,10,10,10)); //设置边距 JLabel jLabel = new JLabel(&quot;用户名：&quot;); JTextField jTextField = new JTextField(); JLabel jLabe2 = new JLabel(&quot;密码：&quot;); JPasswordField jPasswordField = new JPasswordField(); JButton jButton=new JButton(&quot;登录&quot;); JButton jButton2=new JButton(&quot;重置&quot;); jPanel.add(jLabel); jPanel.add(jTextField); jPanel.add(jLabe2); jPanel.add(jPasswordField); jPanel.add(jButton); jPanel.add(jButton2); jFrame.getContentPane().setBackground(Color.red); //设置容器的背景颜色 jFrame.setLocation(300, 200); //设置容器的位置 jFrame.setSize(500, 500); //设置容器大小 jFrame.setVisible(true); //让容器显示 jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } } Swing事件处理代码示例： demo1 package com.java.chap13.sec08; import javax.swing.*; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; /** * @author Yan * @date 2019/7/28 22:11 */ class JButtonListener implements ActionListener{ @Override public void actionPerformed(ActionEvent e) { System.out.println(e.getActionCommand()); JOptionPane.showMessageDialog(null,&quot;我被点击了&quot;); } } public class EventTest1 { public static void main(String[] args) { JFrame jFrame = new JFrame(&quot;Swing事件&quot;); JButton jButton=new JButton(&quot;我是一个按钮&quot;); JButtonListener jButtonListener=new JButtonListener(); jButton.addActionListener(jButtonListener); //添加/注册事件监听 jFrame.add(jButton); jFrame.getContentPane().setBackground(Color.red); //设置容器的背景颜色 jFrame.setLocation(300, 200); //设置容器的位置 jFrame.setSize(500, 500); //设置容器大小 jFrame.setVisible(true); //让容器显示 jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } } demo2 package com.java.chap13.sec08; import javax.swing.*; import java.awt.*; import java.awt.event.WindowEvent; import java.awt.event.WindowListener; /** * @author Yan * @date 2019/7/28 22:17 */ //class MyWindowListener implements WindowListener { // // @Override // public void windowOpened(WindowEvent e) { // System.out.println(&quot;窗口被打开&quot;); // } // // @Override // public void windowClosing(WindowEvent e) { // System.out.println(&quot;窗口关闭&quot;); // } // // @Override // public void windowClosed(WindowEvent e) { // System.out.println(&quot;窗口被关闭&quot;); // } // // @Override // public void windowIconified(WindowEvent e) { // System.out.println(&quot;窗口最小化&quot;); // } // // @Override // public void windowDeiconified(WindowEvent e) { // System.out.println(&quot;窗口从最小化恢复&quot;); // } // // @Override // public void windowActivated(WindowEvent e) { // System.out.println(&quot;窗口被选中&quot;); // } // // @Override // public void windowDeactivated(WindowEvent e) { // System.out.println(&quot;窗口选中被取消&quot;); // } //} public class EventTest2 { public static void main(String[] args) { JFrame jFrame = new JFrame(&quot;Swing事件&quot;); //MyWindowListener myWindowListener=new MyWindowListener(); //jFrame.addWindowListener(myWindowListener); jFrame.addWindowListener(new WindowListener() { @Override public void windowOpened(WindowEvent e) { System.out.println(&quot;窗口被打开&quot;); } @Override public void windowClosing(WindowEvent e) { System.out.println(&quot;窗口关闭&quot;); } @Override public void windowClosed(WindowEvent e) { System.out.println(&quot;窗口被关闭&quot;); } @Override public void windowIconified(WindowEvent e) { System.out.println(&quot;窗口最小化&quot;); } @Override public void windowDeiconified(WindowEvent e) { System.out.println(&quot;窗口从最小化恢复&quot;); } @Override public void windowActivated(WindowEvent e) { System.out.println(&quot;窗口被选中&quot;); } @Override public void windowDeactivated(WindowEvent e) { System.out.println(&quot;窗口选中被取消&quot;); } }); jFrame.getContentPane().setBackground(Color.red); //设置容器的背景颜色 jFrame.setLocation(300, 200); //设置容器的位置 jFrame.setSize(500, 500); //设置容器大小 jFrame.setVisible(true); //让容器显示 jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } } demo3 package com.java.chap13.sec08; import javax.swing.*; import java.awt.*; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; /** * @author Yan * @date 2019/7/28 22:24 */ //class MyWindowAdapter extends WindowAdapter{ // @Override // public void windowClosing(WindowEvent e) { // super.windowClosing(e); // System.out.println(&quot;窗口关闭。。。。。。。&quot;); // } //} public class EventTest3 { public static void main(String[] args) { JFrame jFrame = new JFrame(&quot;Swing事件&quot;); //MyWindowAdapter myWindowAdapter=new MyWindowAdapter(); //jFrame.addWindowListener(myWindowAdapter); jFrame.addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { super.windowClosing(e); System.out.println(&quot;窗口关闭。。。。&quot;); } }); jFrame.getContentPane().setBackground(Color.red); //设置容器的背景颜色 jFrame.setLocation(300, 200); //设置容器的位置 jFrame.setSize(500, 500); //设置容器大小 jFrame.setVisible(true); //让容器显示 jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } } Java IO流IO流简介流是一组有顺序的，有起点和终点的字节集合，是对数据传输的总称或抽象。即数据再两设备间的传输称为流，流的本质是数据传输，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。 IO 流的分类根据处理数据类型的不同分类：字符流和字节流根据数据流向不同分为：输入流和输出流 文件操作File类 public boolean mkdir()：创建此抽象路径名指定的目录 public boolean createNewFile():创建一个文件 public boolean delete():删除此抽象路径名表示的文件或目录。如果此路径名表示一个目录，则该目录必须为空才能删除 public boolean exists():测试此抽象路径名表示的文件或目录是否存在 public File[] listFiles():返回一个抽象路径名数组，这些路径名表示此抽象路径名表示的目录中的文件 public boolean idDirectory():测试此抽象路径名表示的文件是否是一个目录 代码示例： Demo1.java package com.java.chap14.sec02; import java.io.File; import java.io.IOException; /** * @author Yan * @date 2019/7/30 15:43 */ public class Demo1 { public static void main(String[] args) throws IOException { File file=new File(&quot;D://java创建的目录&quot;); boolean b=file.mkdir(); //创建虚拟目录 if (b){ System.out.println(&quot;目录创建成功&quot;); file=new File(&quot;D://java创建的目录//java创建的文件.txt&quot;); boolean b2=file.createNewFile(); //创建文件 if (b2){ System.out.println(&quot;文件创建成功&quot;); }else { System.out.println(&quot;文件创建失败&quot;); } }else { System.out.println(&quot;目录创建失败&quot;); } } } Demo2.java package com.java.chap14.sec02; import java.io.File; import java.io.IOException; /** * @author Yan * @date 2019/7/30 15:43 */ public class Demo2 { public static void main(String[] args) throws IOException { File file=new File(&quot;D://java创建的目录//Java创建的文件.txt&quot;); if (file.exists()){ //假如目录存在 boolean b=file.delete(); //删除文件 if (b){ System.out.println(&quot;删除文件成功&quot;); }else { System.out.println(&quot;删除文件失败&quot;); } } file=new File(&quot;D://java创建的目录&quot;); if (file.exists()){ boolean b2=file.delete(); //删除目录 if (b2){ System.out.println(&quot;删除目录成功&quot;); }else { System.out.println(&quot;删除目录失败&quot;); } } } } Demo3.java package com.java.chap14.sec02; import java.io.File; /** * @author Yan * @date 2019/7/30 17:21 */ public class Demo3 { public static void main(String[] args) { File file=new File(&quot;D://图书&quot;); File files[]=file.listFiles(); //遍历目录 for (int i=0;i&lt;files.length;i++){ System.out.println(files[i]); } } } Demo4.java package com.java.chap14.sec02; import java.io.File; /** * @author Yan * @date 2019/7/30 17:45 */ public class Demo4 { /** * 打印文件 * @param file */ public static void listFile(File file) { if (file != null) { if (file.isDirectory()) { //是目录 File files[]=file.listFiles(); //遍历目录 if (files!=null){ for (int i=0;i&lt;files.length;i++){ listFile(files[i]); //递归调用 } } } else { //是文件 System.out.println(file); //是文件，直接打印文件的路径 } } } public static void main(String[] args) { File file=new File(&quot;D://实验报告&quot;); listFile(file); } } 字节输入，输出流 InputStream 读取文件 代码示例： Demo1.java package com.java.chap14.sec03; import java.io.File; import java.io.FileInputStream; import java.io.InputStream; /** * @author Yan * @date 2019/7/31 14:36 */ public class Demo1 { public static void main(String[] args) throws Exception { File file=new File(&quot;D://测试文件.txt&quot;); InputStream inputStream=new FileInputStream(file); //实例化FileInputStream byte b[]=new byte[1024]; int len=inputStream.read(b); inputStream.read(b); inputStream.close(); //关闭输出流 System.out.println(&quot;读取的内容：&quot;+new String(b,0,len)); } } Demo2.java package com.java.chap14.sec03; import java.io.File; import java.io.FileInputStream; import java.io.InputStream; /** * @author Yan * @date 2019/7/31 14:36 */ public class Demo2 { public static void main(String[] args) throws Exception { File file=new File(&quot;D://测试文件.txt&quot;); InputStream inputStream=new FileInputStream(file); //实例化FileInputStream int fileLength= (int) file.length(); byte b[]=new byte[fileLength]; int len=inputStream.read(b); inputStream.read(b); inputStream.close(); //关闭输出流 System.out.println(&quot;读取的内容：&quot;+new String(b)); } } Demo3.java package com.java.chap14.sec03; import java.io.File; import java.io.FileInputStream; import java.io.InputStream; /** * @author Yan * @date 2019/7/31 14:36 */ public class Demo3 { public static void main(String[] args) throws Exception { File file=new File(&quot;D://测试文件.txt&quot;); InputStream inputStream=new FileInputStream(file); //实例化FileInputStream int fileLength= (int) file.length(); byte b[]=new byte[fileLength]; int temp=0; int len=0; while ((temp=inputStream.read())!=-1){ //一个字节一个字节读取，放到b字节数组里 b[len++]= (byte) temp; } inputStream.close(); //关闭输出流 System.out.println(&quot;读取的内容：&quot;+new String(b)); } } OutputStream 写入文件 代码示例： Demo4.java package com.java.chap14.sec03; import java.io.File; import java.io.FileOutputStream; import java.io.OutputStream; /** * @author Yan * @date 2019/7/31 15:38 */ public class Demo4 { public static void main(String[] args) throws Exception { File file=new File(&quot;D://测试文件.txt&quot;); OutputStream outputStream=new FileOutputStream(file); String str=&quot;你好，我好，大家好&quot;; byte b[]=str.getBytes(); outputStream.write(b); //将b字节数组写入到输出流中 outputStream.close(); //关闭输出流 } } Demo5.java package com.java.chap14.sec03; import java.io.File; import java.io.FileOutputStream; import java.io.OutputStream; /** * @author Yan * @date 2019/7/31 15:38 */ public class Demo5 { public static void main(String[] args) throws Exception { File file=new File(&quot;D://测试文件.txt&quot;); OutputStream outputStream=new FileOutputStream(file,true); //true追加 String str=&quot;你好，我好，大家好&quot;; byte b[]=str.getBytes(); outputStream.write(b); //将b字节数组写入到输出流中 outputStream.close(); //关闭输出流 } } BufferedInputStream和BufferedOutputStream 代码示例： package com.java.chap14.sec03; import java.io.*; /** * @author Yan * @date 2019/7/31 22:31 */ public class Demo6 { /** * 缓冲 * * @throws Exception */ public static void bufferStream() throws Exception { //定义一个带缓冲的字节输入流 BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(&quot;D://实验报告//android//Android应用开发实验指导书.doc&quot;)); //定义一个带缓冲的字节输出流 BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(new FileOutputStream(&quot;D://复制的文件2.doc&quot;)); int b = 0; Long startTime = System.currentTimeMillis(); //开始时间 while ((b = bufferedInputStream.read()) != -1) { bufferedOutputStream.write(b); } bufferedInputStream.close(); bufferedOutputStream.close(); Long endTime = System.currentTimeMillis(); //结束时间 System.out.println(&quot;缓冲花费的时间：&quot; + (endTime - startTime)); } /** * 非缓冲 * * @throws Exception */ public static void stream() throws Exception { InputStream inputStream = new FileInputStream(&quot;D://实验报告//android//Android应用开发实验指导书.doc&quot;); //定义一个输入流 OutputStream outputStream = new FileOutputStream(&quot;D://复制的文件.doc&quot;); int b = 0; Long startTime = System.currentTimeMillis(); //开始时间 while ((b = inputStream.read()) != -1) { outputStream.write(b); } inputStream.close(); outputStream.close(); Long endTime = System.currentTimeMillis(); //结束时间 System.out.println(&quot;非缓冲花费的时间：&quot; + (endTime - startTime)); } public static void main(String[] args) throws Exception { stream(); bufferStream(); } } 缓冲和非缓冲的区别及性能对比 字符输入、输出流 Reader读取文件 代码示例： Demo1.java package com.java.chap14.sec04; import java.io.File; import java.io.FileReader; import java.io.Reader; /** * @author Yan * @date 2019/7/31 23:00 */ public class Demo1 { public static void main(String[] args) throws Exception { File file = new File(&quot;D://测试文件.txt&quot;); Reader reader=new FileReader(file); char c[]=new char[1024]; //字符数组 int len=reader.read(c); reader.close(); //关闭输入流 System.out.println(&quot;读取的内容是：&quot;+new String(c,0,len)); } } Demo2.java package com.java.chap14.sec04; import java.io.File; import java.io.FileReader; import java.io.Reader; /** * @author Yan * @date 2019/7/31 23:04 */ public class Demo2 { public static void main(String[] args) throws Exception { File file = new File(&quot;D://测试文件.txt&quot;); Reader reader=new FileReader(file); char c[]=new char[1024]; //字符数组 int temp=0; int len=0; while ((temp=reader.read())!=-1){ c[len++]= (char) temp; } reader.close(); //关闭输入流 System.out.println(&quot;读取的内容是：&quot;+new String(c,0,len)); } } Writer写入文件 代码示例： Demo3.java package com.java.chap14.sec04; import java.io.*; /** * @author Yan * @date 2019/7/31 23:06 */ public class Demo3 { public static void main(String[] args) throws Exception { File file = new File(&quot;D://测试文件.txt&quot;); Writer out = new FileWriter(file); String str = &quot;我爱中华&quot;; out.write(str); //将字符串写入输出流 out.close(); //关闭输出流 } } Demo4.java package com.java.chap14.sec04; import java.io.File; import java.io.FileWriter; import java.io.Writer; /** * @author Yan * @date 2019/7/31 23:06 */ public class Demo4 { public static void main(String[] args) throws Exception { File file = new File(&quot;D://测试文件.txt&quot;); Writer out = new FileWriter(file,true); String str = &quot;我爱中华&quot;; out.write(str); //将字符串写入输出流 out.close(); //关闭输出流 } } 待续参考 Java知识分享网 Java入门到精通-基础篇op=>operation: Hello World.java(Javac 编译) op1=>operation: Hello World.class(Java 运行) op2=>operation: 执行并运行结果 e=>end op->op1->op2{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-0\", options);","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"},{"name":"基础","slug":"Java/基础","permalink":"http://yoursite.com/categories/Java/基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"基础","slug":"基础","permalink":"http://yoursite.com/tags/基础/"}]},{"title":"饥荒游戏服务器端搭建","slug":"饥荒游戏服务器端搭建","date":"2019-08-01T16:00:00.000Z","updated":"2019-10-11T00:05:29.558Z","comments":true,"path":"2019/08/02/饥荒游戏服务器端搭建/","link":"","permalink":"http://yoursite.com/2019/08/02/饥荒游戏服务器端搭建/","excerpt":"Linux服务器要求 上行带宽：8KBps 一个玩家； 内存：差不多一个玩家 65Mbytes； CPU：没太大要求","text":"Linux服务器要求 上行带宽：8KBps 一个玩家； 内存：差不多一个玩家 65Mbytes； CPU：没太大要求 服务器端口开放默认情况下，服务器在端口10999上使用UDP流量 因此需要将服务器的10999端口进行开放 内存为了防止内存不足，开启SWAP。 首先确认SWAP设置了多少 free -m 如果觉得不满意其空间大小，则对SWAP进行删除 swapoff -a 新增SWAP分区 dd if=/dev/zero of=/root/swapfile bs=1M count=1024 #1024大小可根据自己情况进行更改 格式化交换分区文件 mkswap /root/swapfile 启用swap分区文件 swapon /root/swapfile 添加开机启动 vi /etc/fstab 这里提一下vi编辑器的基本用法：进入文本后按键盘上的insert按钮开始编辑，按esc退出编辑，输入:wq保存并退出。 添加或修改 /root/swapfile swap swap defaults 0 0 重启下是否生效 reboot 重启后输入指令查看下SWAP是否增加 free -m 依赖安装# Ubuntu $ sudo apt-get install libstdc++6:i386 libgcc1:i386 libcurl4-gnutls-dev:i386 lib32gcc1 # CentOS(仅供参考) $ yum -y install glibc.i686 libstdc++.i686 libcurl4-gnutls-dev.i686 libcurl.i686 安装 SteamCMDSteamCMD，顾名思义，就是 Steam 的命令行版本。虽然饥荒服务器本身并不需要用 Steam 进行验证啊之类的，但我们还是得用它来把服务器更新到最新版本，不然其他人是进不来的。 我们最好新建一个用户来运行 SteamCMD，如果直接用 root 用户运行游戏服务端的话可能会导致严重的安全隐患。在 root 权限下使用以下命令来创建一个新用户： $ useradd -m steam $ su - steam 然后在你喜欢的地方创建一个为 SteamCMD 准备的目录： $ mkdir ~/steamcmd ## 创建目录 $ cd ~/steamcmd ## 进入该目录 下载并解压 Linux 专用的 SteamCMD： $ wget https://steamcdn-a.akamaihd.net/client/installer/steamcmd_linux.tar.gz ## 下载 $ tar -xvzf steamcmd_linux.tar.gz ## 解压 运行 SteamCMD： $ ./steamcmd.sh 登录安装退出操作： # 匿名登录，没必要用用户名密码登录 login anonymous # 这里我们强制要 Steam 把饥荒服务端安装到此目录下 # 最好用绝对路径，否则可能会安装到奇怪的地方去 force_install_dir ../dontstarvetogether_dedicated_server app_update 343050 validate quit 安装完成后，使用 quit 命令退出 steam 程序。 成功安装所出现的标志： Success! App &#39;343050&#39; fully installed. 通过客户端获取配置文件服务器端配置文件位置及相关操作饥荒的配置目录位于: ~/.klei/DoNotStarveTogether 然后手动创建一个存档目录： mkdir -p ~/.klei/DoNotStarveTogether/MyDediServer 利用客户端创建世界 进入游戏 创建自己的世界，设置可自定应。 以 Windows 为例（Linux/Mac 类似），存档位置位于 /Users/username/Documents/Klei/DoNotStarveTogether，也就是文档目录下。 在该目录的下一级目录中，在一个全是数字的文件夹中有一个命名为 Cluster_X 的文件夹（X 为数字编号），提取出刚刚创建的存档。 修改配置文件cluster.ini 修改bind_ip和master_ip内容 [SHARD] shard_enabled = true bind_ip = 0.0.0.0 master_ip = 你的主服务器的 IP Mod进入到服务器的的饥荒安装目录： cd ~/dontstarvetogether_dedicated_server/mods 修改该目录下的 dedicated_server_mods_setup.lua 文件： vim dedicated_server_mods_setup.lua # 在该文件中添加类似这样的内容，这串 ID 是 Mod 文件在 Steam 中的 ID # 可以在提取到的配置文件的 Master/modoverrides.lua 中找到 # 然后添加到本文件中，一行一个 ServerModSetup(&quot;362175979&quot;) 本教程模板： ServerModSetup(&quot;1089344410&quot;) ServerModSetup(&quot;1146082006&quot;) ServerModSetup(&quot;1200745268&quot;) ServerModSetup(&quot;1207269058&quot;) ServerModSetup(&quot;1290228121&quot;) ServerModSetup(&quot;1301033176&quot;) ServerModSetup(&quot;352499675&quot;) ServerModSetup(&quot;362175979&quot;) ServerModSetup(&quot;375850593&quot;) ServerModSetup(&quot;378160973&quot;) ServerModSetup(&quot;380423963&quot;) ServerModSetup(&quot;444235588&quot;) ServerModSetup(&quot;458587300&quot;) ServerModSetup(&quot;462434129&quot;) ServerModSetup(&quot;488009136&quot;) ServerModSetup(&quot;577104313&quot;) ServerModSetup(&quot;622448972&quot;) ServerModSetup(&quot;666155465&quot;) ServerModSetup(&quot;682721879&quot;) ServerModSetup(&quot;785295023&quot;) ServerModSetup(&quot;841471368&quot;) ServerModSetup(&quot;892478248&quot;) ServerModSetup(&quot;934638020&quot;) 上传配置文件将配置文件上传到 ~/.klei/DoNotStarveTogether/MyDediServer下 Linux传输文件可参考链接： Linux scp命令 Linux下如何将一个用户下的文件拷贝到另一个用户里 Linux中zip压缩和unzip解压缩命令详解 配置user_id和自己的token搭建服务器需要相关的管理人员以及相关token文件 获取相关文件进入 https://accounts.klei.com/account/info 该链接 按图中步骤进行操作首先获取用户id,下图中的箭头所指的即是用户id，复制之后作为设置管理员文件的信息。 点击 导航栏 – 游戏 – Don’t Starve Together Server 下图中三个箭头所指的东西任选其一即可，同时最下方也可以支持添加。复制作为token。 编辑相关文件先新建 cluster_token.txt 文件，再将此前获取到的 Token 复制到文件中。 touch cluster_token.txt 再新建 adminlist.txt 文件，再将此前获取到的 UserID 复制到文件中。 touch adminlist.txt 启动游戏启动脚本创建脚本文件: cd ~ &amp;&amp; touch startDST.sh 编辑脚本文件: #!/bin/bash steamcmd_dir=&quot;$HOME/steamcmd&quot; install_dir=&quot;$HOME/dontstarvetogether_dedicated_server&quot; cluster_name=&quot;MyDediServer&quot; dontstarve_dir=&quot;$HOME/.klei/DoNotStarveTogether&quot; cd &quot;$install_dir/bin&quot; run_shared=(./dontstarve_dedicated_server_nullrenderer) run_shared+=(-console) run_shared+=(-cluster &quot;$cluster_name&quot;) run_shared+=(-monitor_parent_process $$) &quot;${run_shared[@]}&quot; -shard Caves | sed &#39;s/^/Caves: /&#39; &amp; &quot;${run_shared[@]}&quot; -shard Master | sed &#39;s/^/Master: /&#39; 给启动脚本添加权限： chmod +x ./startDST.sh 运行： ./startDST.sh 更新游戏版本创建脚本文件： cd ~ &amp;&amp; touch updateDST.sh 编辑脚本文件： #!/bin/bash steamcmd_dir=&quot;$HOME/steamcmd&quot; ## 检查并更新更新游戏版本 cd &quot;$steamcmd_dir&quot; ./steamcmd.sh +@ShutdownOnFailedCommand 1 +@NoPromptForPassword 1 +login anonymous +force_install_dir ../dontstarvetogether_dedicated_server +app_update 343050 validate +quit 给脚本添加权限： chmod +x ./startDST.sh 模板下载下载地址： DST服务器搭建","categories":[{"name":"游戏","slug":"游戏","permalink":"http://yoursite.com/categories/游戏/"},{"name":"饥荒","slug":"游戏/饥荒","permalink":"http://yoursite.com/categories/游戏/饥荒/"}],"tags":[{"name":"游戏","slug":"游戏","permalink":"http://yoursite.com/tags/游戏/"},{"name":"饥荒","slug":"饥荒","permalink":"http://yoursite.com/tags/饥荒/"}]},{"title":"操作系统","slug":"操作系统","date":"2019-07-17T16:00:00.000Z","updated":"2019-10-11T00:02:35.935Z","comments":true,"path":"2019/07/18/操作系统/","link":"","permalink":"http://yoursite.com/2019/07/18/操作系统/","excerpt":"操作系统信号量解决进程同步问题例题：桌子上有一只盘子，最多可容纳两个水果，每次只能放入或取出一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，两个儿子专等吃盘子中的橘子，两个女儿专等吃盘子中的苹果。请用信号量操作来实现爸爸、妈妈、儿子、女儿之间的同步与互斥关系。","text":"操作系统信号量解决进程同步问题例题：桌子上有一只盘子，最多可容纳两个水果，每次只能放入或取出一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，两个儿子专等吃盘子中的橘子，两个女儿专等吃盘子中的苹果。请用信号量操作来实现爸爸、妈妈、儿子、女儿之间的同步与互斥关系。 semaphore s=2,so=0,sa=0;//s表示盘空，so表示橘子，sa表示苹果。 Cobegin Void father(void) { while(1){ p(s); put apple(); v(sa); } } Void mother(void) { while(1){ p(s); put orange(); v (so); } } Void son(void) { while(1){ p(so); eat orange(); v(s); } } Void daughter(void) { while(1){ p(sa); eat apple(); v(s); } } Coend PV操作参考进程同步之信号量机制（pv操作）及三个经典同步问题 作业调度算法（先来先服务算法、短作业优先算法），计算周转时间、带权周转时间、平均周转时间、平均带权周转时间 周转时间=完成时间-提交时间带权周转时间=周转时间/执行时间平均周转时间=每个周转时间之和/作业总数平均带权周转时间=每个带权周转时间之和/作业总数 例题：求解下表中4个作业在FCFS（先来先服务算法）和SJF（短作业优先算法）调度算法下的调度次序、周转时间、带权周转时间、平均周转时间、平均带权周转时间。 作业 提交时间 执行时间 开始时间 完成时间 周转时间 带权周转时间 1 8.00 2.00 2 8.50 0.50 3 9.00 0.10 4 9.50 0.20 先来先服务调度算法 作业 提交时间 运行时间 开始时间 完成时间 周转时间 带权周转时间 执行顺序 1 8.00 2.00 8.00 10.00 2.00 1 1 2 8.50 0.50 10.00 10.50 2.00 4 2 3 9.00 0.10 10.50 10.60 1.60 16 3 4 9.50 0.20 10.60 10.80 1.30 6.5 4 平均周转时间=1.725平均带权周转时间=6.875 短作业优先调度算法 作业 提交时间 运行时间 开始时间 完成时间 周转时间 带权周转时间 执行顺序 1 8.00 2.00 8.00 10.00 2.00 1 1 2 8.50 0.50 10.30 10.80 2.30 4.6 4 3 9.00 0.10 10.00 10.10 1.10 11 2 4 9.50 0.20 10.10 10.30 0.80 4 3 平均周转时间=1.55平均带权周转时间=5.15 先来先服务算法先来先服务根据作业的提交时间来执行作业，提交的时间早则首先被执行。 短作业优先算法根据执行时间来作为执行顺序，同时第一个到达的作业要首先被执行，之后再根据运行时间的长短来执行，短的则优先执行。 资源分配图的简化资源分配图 在资源分配图中，通常使用圆圈来表示每个进程，用方框表示每种资源类型。由于同一资源类型可能有多个实例，所以在矩形中用圆点数表示实例数。 实例 说明 进程P1申请一个R1类资源 系统分配一个R1类资源给进程P1，此时系统还剩下2个R1类资源 进程P1申请2个R类资源 系统分配2个R1类资源给进程P1，此时系统还剩下1个R1类资源 系统分配一个R1类资源给进程P2，然后分配一个R1类资源给进程P1，最后进程P1收到一个R1类资源又继续申请一个R1类资源，此时系统还剩下一个R1类资源可以分配给进程P1，但是还没有分配给P1 系统分配一个R1类资源给进程P2，然后又分配一个R1类资源给进程P1，最后进程P1收到一个R1类资源又继续申请一个R1类资源，此时系统已经没有R1类资源可以分配给进程P1，于是进程P1收到阻塞 例题： 第一步：先看R1资源，它有三个箭头是向外的，因此它一共给进程分配了3个资源，此时，R1没有空闲的资源剩余。 第二步：再看R2资源，它有一个箭头是向外的，因此它一共给进程分配了1个资源，此时，R2还剩余一个空闲的资源没分配。 第三步：看完资源，再来看进程，先看进程P2，它只申请一个R1资源，但此时R1资源已经用光了，所以，进程P2进入阻塞状态，因此，进程P2暂时不能化成孤立的点。 第四步：再看进程P1，它只申请一个R2资源，此时，系统还剩余一个R2资源没分配，因此，可以满足P1的申请。这样，进程P1便得到了它的全部所需资源，所以它不会进入阻塞状态，可以一直运行，等它运行完后，我们再把它的所有的资源释放。相当于：可以把P1的所有的边去掉，变成一个孤立的点，如下图所示： 第五步：进程P1运行完后，释放其所占有的资源（2个R1资源和1个R2资源），系统回收这些资源后，空闲的资源便变成2个R1资源和1个R2资源，由于进程P2一直在申请一个R1资源，所以此时，系统能满足它的申请。这样，进程P2便得到了它的全部所需资源，所以它不会进入阻塞状态，可以一直运行，等它运行完后，我们再把它的所有的资源释放。相当于：可以把P2的所有的边都去掉，化成一个孤立的点，变成下图： 由于这个资源分配图可完全简化，因此，不会产生死锁。而如果资源分配图中的点，最终不能够化成孤立的点，则进程资源图不能够完全简化，从而会发生死锁。 分页地址变换 地址变换处理 得到页号：自动将逻辑地址分为页号和页内地址 用页号查页表，得到块号 将块号与页内地址拼接，即得物理地址 分页存储逻辑地址转物理地址例题：已知某个分页系统，页面大小为1K(即1024字节)，某一个作业有4个页面，分别装入到主存的第3、4、6、8块中，求逻辑地址2100对应的物理地址。 第一步：求逻辑地址的页号 = 2100/1024=2 （整除） 第二步：求页内偏移量 = 2100 % 1024 =52 （取余） 第三步：产生页表： 页号 块号 0 3 1 4 2 6 3 8 第四步：根据逻辑地址的页号查出物理地址的页框号/帧号：如上图，逻辑地址的第2页对应物理地址的第6页。 第五步：求出物理地址 = 6*1024 + 52 = 6196 设有8页的逻辑地址空间，每页有1024个字节，它们被映射到32块的物理存储区，那么逻辑地址的有效位是多少，物理地址至少多少位？ 逻辑地址：8x1024=2^3x2^10=2^13物理地址：32x1024=2^5x2^10=2^15逻辑地址的有效位是13，物理地址的有效位是15. 十六进制逻辑地址转物理地址一分页存储管理系统中逻辑地址长度为16位，页面大小为4KB字节，现有一逻辑地址为2F6AH，且第0、1、2页依次存放在物理块5、10、11中。求逻辑地址2F6AH对应的物理地址 解： 第一步：将逻辑地址2F6AH转换为二进制为：0010 1111 0110 1010 第二步：由于页面大小为4KB字节，（4KB=2的12次方）。所以逻辑地址的后12位为“页内地址”(也叫做页内偏移量) 第三步：由于逻辑地址的后12位为页内地址，所以剩下的前4位为页号：即0010为页号 第四步：根据页表可知，0010(十进制为2)对于的页框号为11(二进制为1011)所以最终的物理地址为：1011 1111 0110 1010即BF6AH 页面置换算法 定义：选择换出页面的算法评价依据：页面更换频率（缺页率）。 缺页率=缺页次数/页面总访问次数 最佳置换算法（OPT）最佳置换算法所选择淘汰的页面是最长（未来）时间内不再被访问的页面。 例如：系统为某进程分配3个物理块，进程访问页面的顺序是0，7，6，5，7，4，7，3，5，4，7，4，5，6，5，7，6，0，7，6。 访问页面 0 7 6 物理块 0 0 0 7 7 6 接下来下一个进入的数字是5，然后需要淘汰最久不被访问的页面。 首先，需要看0，7，6的哪个是最久不被访问的页面。0在第18次再次访问。7在第5次再次被访问。6在第14次再次被访问。因此需要淘汰0。 按照如上的规律，可以得到以下的结果。 访问页面 0 7 6 5 7 4 7 3 5 4 7 4 5 6 5 7 6 0 7 6 物理块 0 0 0 5 5 5 5 5 5 5 5 5 5 5 5 5 5 0 0 0 7 7 7 7 7 7 3 3 3 7 7 7 7 7 7 7 7 7 7 6 6 6 4 4 4 4 4 4 4 4 6 6 6 6 6 6 6 缺页中断 x x x x x x x x x 缺页率：9/20*100%=36% 缺页中断：在请求分页系统中，可以通过查询页表中的状态位来确定所要访问的页面是否存在于内存中。每当所要访问的页面不在内存时，会产生一次缺页中断，此时操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存。 通俗的讲也就是每次往物理块中添加数据就会产生一次缺页中断。 先进先出页面置换算法（FIFO）先进先出页面置换算法淘汰的页面是淘汰最先进入内存的页面。 访问页面 6 0 1 2 0 3 0 4 2 3 物理块 6 6 6 2 2 2 2 4 4 4 0 0 0 0 3 3 3 2 2 1 1 1 1 0 0 0 3 缺页中断 x x x x x x x x x 缺页率：9/10*100%=90% 最近最久未使用置换算法（LRU）最近最久未使用置换算法淘汰的页面是淘汰最近最久未使用的页面。 访问页面 2 3 2 1 5 2 4 5 3 2 5 2 物理块 2 3 2 1 5 2 4 5 3 2 5 2 2 3 2 1 5 2 4 5 3 2 5 3 2 1 5 2 4 5 3 3 缺页中断 x x x x x x x 缺页率：7/12*100%=58.3% 堆栈实现LRU：系统使用特殊的堆栈来存放内存中每一个页面的页号。每当访问一页时就调整一次，即把被访问页面的页号从栈中移出再压入栈顶。因此，栈顶始终是最新被访问页面的页号。当发生缺页中断时，总是淘汰栈底页号所对应的页面。 磁盘的调度算法先来先服务（FCFS）先来先服务算法是根据进程请求访问磁盘的先后顺序进行调度。例题：某一磁盘请求序列（磁盘号）：98，183，37，122，14，124，65，61.按照先来先服务磁盘调度对磁盘进行请求服务，假设当前磁头在53道上，则磁臂总移动倒数为多少？ 下一个磁道 移动磁道数 98 45 183 85 37 146 122 85 14 108 124 110 65 59 61 4 总移动磁道数=45+85+146+85+108+110+59+4=642. 最短寻道时间优先磁盘调度算法（SSTF）最短寻道时间优先磁盘调度算法是每次都优先满足当前磁头位置最近的磁道访问请求。 例题：若干个等待访问磁盘者依次要访问的磁道为19，43，40，4，79，11，76，当前磁头位于42号柱面，若用最短寻道时间优先磁盘调度算法，则访问序列是什么？思路：将要访问的磁道与当前磁头所在柱面相减并取绝对值，绝对值越小的优先访问。 访问序列为40，43，19，11，4，76，79. 扫描算法（SCAN） 考虑当前移动方向，一直移动到最外/内层磁道时，折返，进行反方向移动。就好比电梯。 寻道方向：…，里-&gt;外，外-&gt;里，….; 若干个等待访问磁盘者依次要访问的磁道为86,147,91,177,94,150,102,175,130，当前磁头位于143号柱面，刚刚处理完125号柱面，使用SCAN算法则访问序列是什么？ 答： 当前方向：从143向磁道号增加的方向 依次访问：147，150，175，177 反方向：130，102，94，91，86（电梯原理） 循环扫描（CSCAN） 循环扫描 寻道方向：…..,里-&gt;外，里-&gt;外，….。或者相反。 若干个等待访问磁盘者依次要访问的磁道为86,147,91,177,94,150,102,175,130，当前磁头位于143号柱面，刚刚处理完125号柱面，使用CSCAN算法则访问序列是什么？ 答： 当前方向：从143向磁道号增加的方向 依次访问：147，150，175，177 再从0开始增加方向：86，91，94，102，130 磁盘空间分配多级索引分配例题：设一个盘块大小为1k,每个盘块号占4Byte,若系统采用2级索引，求文件的最大长度。 答:每个索引块最多可存放1k/4=256个盘块号；采用2级索引是，一个文件最多可拥有的数据块数为256x256=2^6x2^10=64k文件的最长长度为64kx1k=64m. 混合索引分配存放在某磁盘上的文件系统采用混合索引分配方式，其中FCB由6个地址项构成，前四个地址项是直接寻址方式，第五个地址项是一次间接寻址方式，第六个地址项是二次间接寻址。若每个盘块的大小为1KB，盘块号用4个字节描述。那么： （1）源文件系统允许文件的最大长度是多少？（2）将文件的字节偏移量800、8193和819300 转换为物理块号和块内偏移。答：（1）每个盘块能存放的盘块号的个数：1024/4=256文件系统允许的文件最大长度：（4+256+256x256）x1K=65796KB （2） 800/1024商0余800，因为0&lt;4，所以，第一个地址项中存放的块号即为其所在物理块号，块内偏移800。 8193/1024商8余1，4&lt;=8&lt;4+256，所以一次间接寻址，8-4=4，读第五个地址项中存放的块号物理块的内容，其内容中的第五个块号即为其所在物理块号，块内偏移1。 819300/1024商800余100，4+256&lt;=800&lt;4+256+256x256，所以二次间接寻址，800-(4+256)=540，540/256商2余28，读第六个地址项中存放的块号的物理块的内容，再读其内容中的第三个块号所在物理块的内容，其内容的第29个块号即为其所在物理块号，块内偏移为100。 磁盘空间的管理位置分配位示图位示图：用二进制的一位表示磁盘中一个盘块的使用情况。 “0”，对应块是空闲块； “1”，对应块已被分配出去。 盘块分配(1) 顺序扫描位示图，从中找出一个或一组其值为“0”的二进制位(“0”表示空闲)。(2) 将所找到的一个或一组二进制位， 转换成与之相应的盘块号。假定找到的其值为“0”的二进制位，位于位示的第i行、第j列，则其相应的盘块号应按下式计算：b=n(i-1)+j式中， n代表每行的位数。(3) 修改位示图， 令map［i,j］=1。 盘块的回收(1) 将回收盘块的盘块号转换成位示图中的行号和列号。 转换公式为： i=(b-1)DIV n+1 j=(b-1)MOD n+1(2) 修改位示图。 令map ［i,j］=0。 例题：有一计算机系统采用如下图所示的位示图（行号、列号都从0开始编号）来管理空闲盘块。如果盘块从1开始编号，每个盘块的大小为1KB。 （1）现要为文件分配两个盘块，试具体说明分配过程。 （2）若要释放磁盘的第300块，应如何处理？","categories":[{"name":"期末复习","slug":"期末复习","permalink":"http://yoursite.com/categories/期末复习/"},{"name":"操作系统","slug":"期末复习/操作系统","permalink":"http://yoursite.com/categories/期末复习/操作系统/"}],"tags":[{"name":"期末复习","slug":"期末复习","permalink":"http://yoursite.com/tags/期末复习/"},{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/tags/操作系统/"}]},{"title":"软件测试","slug":"软件测试","date":"2019-07-17T16:00:00.000Z","updated":"2019-10-11T00:06:09.773Z","comments":true,"path":"2019/07/18/软件测试/","link":"","permalink":"http://yoursite.com/2019/07/18/软件测试/","excerpt":"思考题1. 你怎样组建一支新的测试团队，包含一些什么岗位，如果要去招聘，开出什么条件？","text":"思考题1. 你怎样组建一支新的测试团队，包含一些什么岗位，如果要去招聘，开出什么条件？参考：首先，测试团队包含的成员（即工作岗位） 测试经理测试部门的负责人。主要职责： 对外： 公司内团队之间的沟通 向上沟通、汇报、日常作业 人才招募 外部影响力（公司内外） 对内 团队管理与建设 项目管理 人才培养 目标拆解、执行、调整、跟进 测试架构师测试技术的负责人，主要承担教练职责，是测试部门的技术核心，涵盖产品测试技术、自动化测试技术、专项测试技术、交付测试技术等方向。主要负责：测试技术管理、测试技术调研、测试技术应用、测试人员的技术培养等。 核心测试人员测试任务的主要执行者，主要负责核心测试任务的落地执行、重要测试技术的落地实践、测试管理要求的有效实施。中等职级、业务专家或擅长某一方向技术。 一般测试人员测试任务的主要辅助执行者，主要负责一般测试任务的落地执行、一般测试技术的落地实践、测试管理要求的有效实施。中低等职级。 测试项目负责人类似于项目经理。工作重点在于沟通和协调。 外包测试人员视为人力，作为一些特殊项目的补充。 测试实习生除了做一些特殊时期的补充外，是选择和提前培养优秀应届生的途径之一。 其次，招聘条件（仅供参考）任职要求： 计算机相关专业，本科及以上学历，3年及以上测试经验，有互联网、SaaS平台产品测试经验者优先； 具备一定的编程能力，熟练掌握Java/C/C++或各类脚本语言中一种，熟悉MySQL等数据库； 熟悉Linux操作系统，有自动化测试经验，能独立设计用例并编写代码实现自动化测试； 熟练测试理论与方法，对互联网质量保证领域有强烈的兴趣； 具有较强的业务分析能力，较好的沟通表达和综合协调能力，对质量保证有深刻理解； 具备撰写自动化测试工具以及搭建自动化测试平台的实战经验者优先。 参考链接： 如何搭建测试团队（研发同理) 2. 如果你作为测试项目负责人，你为什么要对软件测试过程进行管理？测试过程管理的原则，测试过程管理的目标参考：对软件测试过程进行管理的原因： 能够使规定时间内完成所需完成的测试任务。 测试过程管理原则：①有关测试需求；②测试计划先行；③建立任务优先级；④建立客观的评估标准；⑤尽早测试；⑥全面测试；⑦全过程测试；⑧独立的、迭代的测试。 测试过程管理目标：尽可能早地找出软件缺陷，并保证其得以修复。 参考链接： 测试过程管理 测试过程管理 3. 白盒测试策略定义：白盒测试也称结构测试或逻辑驱动测试，是一种测试用例设计方法，它从程序的控制结构导出测试用例。（测试用例由测试输入数据以及与之对应的输出结果组成。） 白盒测试使用被测单元内部如何工作的信息，允许测试人员对程序内部逻辑结构及有关信息来设计和选择测试用例，对程序的逻辑路径进行测试。基于一个应用代码的内部逻辑知识，测试是基于覆盖全部代码、分支、路径、条件。 策略： 桌前检查 模块测试 代码评审 同行评审 代码走查 静态分析 其他参考： 白盒测试：理论基础 4. 掌握功能测试需求分析确定测试优先级参考： 快速划分测试用例优先级 5. 掌握性能测试需求分析会用80-20原理计算负载量书本例题： 测试强度估算80-20原理：每个工作日中80%的业务在20%的时间内完成。举例：每年业务量集中在8个月，每个月20个工作日，每个工作日8个小时即每天80%的业务在1.6小时完成去年全年处理业务约100万笔，其中15%的业务处理中每笔业务需对应用服务器提交7次请求；其中70%的业务处理中每笔业务需对应用服务器提交5次请求；其余15%的业务处理中每笔业务需对应用服务器提交3次请求。根据以往统计结果，每年的业务增量为15%，考虑到今后3年业务发展的需要，测试需按现有业务量的两倍进行。 每年总的请求数：（100x15%x7+100x70%x5+100x15%x3）x2=1000万次/年 每天请求数：1000/160=6.25万次/天 每秒请求数：（62500x80%）/(8x20%x3600)=8.68次/秒即服务器处理请求的能力应达到9次/秒。 6. 设计功能测试用例测试用例模板（仅供参考） 项目/软件 XXX 程序版本 XXX 功能模块名 Login 编制人 XXXX 用例编号 XXXX 编制时间 XXXX 相关的用例 无 功能特性 用户身份验证 测试目的 验证是否输入合法的信息，允许合法登录，阻止非法登录 预置条件 无 特殊规格说明 如数据库访问权限 参考信息 需求说明中关于“登录”的说明 测试数据 用户名=yiii密码=1 操作步骤 操作描述 数据 期望结果 预期结果 实际结果 测试状态 1 输入用户名称按“登录”按钮 用户名=yiyh密码为空 显示警告信息，请输入用户名和密码 2 输入密码，按“登录”按钮 用户名为空密码=1 显示警告信息请输入用户名和密码 测试人员 开发人员 项目负责人 操作步骤需要写出所有情况 7. I/O接口测试，局部数据结构测试检查模块接口是否正确CheckList: 输入的实际参数与形式参数是否一致 个数、属性、量纲 调用其他模块的实际参数与被调模块的形参是否一致 个数、属性、量纲 全程变量的定义在各模块是否一致 外部输入、输出 文件、缓冲区、错误处理 其他 当一个模块执行外部I/O操作时，必须进行附加的接口测试 文件属性是否正确 OPEN/CLOSE语句是否正确？ 格式规约是否和I/O语句匹配？ 缓冲区大小是否和记录大小匹配？ 文件是否在打开之前被使用？ 是否处理了文件结束条件？ 是否处理了I/O错误？ 在输出信息里时候有文本错误？ 模块的局部数据结构是经常出现的错误源。应当设计测试用例以发现下列类型的错误 不正确或不一致的类型描述 错误的初始化或缺省值 不正确的（拼写错误的或被截断的）变量名字 不一致的数据类型 下溢、上溢和地址错误除了局部数据结构，全局数据对模块的影响在单元测试过程中应当进行审查。 检查局部数据结构完整性Checklist: 不适合或不相容的类型说明 变量无初值 变量初始化或默认值有错 不正确的变量名或从来未被使用过 出现上溢或下溢和地址异常 其他 8. 怎样对一段Java代码进行测试，找出代码错误参考：单元测试的步骤： 理解需求和设计 概览源代码 精读源代码 设计测试用例 搭建单元测试环境 执行测试 补充和完善测试用例 分析结果，给出评价 参考链接： 单元测试的步骤 9. 进行项目测试计划时间安排的时候，怎样才算是合理的时间安排？参考：测试计划时间安排上遵守：趋势收敛的原则，越到后面，周期越短，问题应该越少。那么测试执行的原则就是：尽可能的把问题都暴露在前面，这样才能保证测试时间上呈收敛趋势。 做测试计划时，测试轮次的安排，一般根据不同的项目来定，小项目2+1或者1+1，大项目3+1或者2+1。举例说明：假如现有一项目，测试总时间为10天，需要分3轮进行测试。那么测试时间的安排我们采取4、3、2的原则。第一轮（4天）：全面覆盖所有用例；第二轮（3天）：基本上是基本功能全覆盖（故要刷筛选好一级用例），回归问题单，缺陷比较多的模块功能全覆盖；第三轮（2天）：基本上是回归问题单+基本功能全覆盖（执行一级用例）。还有1天留着备用，若第3轮测试有未关闭的bug，需要再加一轮，用于回归问题。 以上就是常见测试计划安排模式：3+1模式。 参考链接： 如何合理安排测试时间 软件测试的测试计划是如何计算测试时间 10. 如果时间紧迫了，测试范围怎样裁剪？参考： 网上资料 部分不重要的需求可以裁剪，不进行测试 对测试范围按照重要性和风险进行优先级评定，优先测试重要的和风险大的 课本 优先级最高的需求功能（优先级如何确定） 新功能和编码改动较大（提高性能表现）的旧功能 经常容易出现问题部分的功能 一些经常被用户使用的功能和配置 11. QTP自动化测试的时候，怎样提高测试脚本执行效率？参考： 使用VBS文件来启动QTP 把变量和函数定义放到外部VBS文件，而不要放在Action中 通过AOM控制QTP重启来解决QTP内存泄露问题 尽量不要使用wait，而使用.sync或exist语句 使用with语句可以让代码更清晰，而且效率更好 使用OR要比DP快点 不要保存image和movie到测试结果中 把运行模式设置为fast 通过AOM控制QTP 在调用Action时使用相对路径 参考链接： QTP：如何优化测试脚本 提高测试效率 以及脚本结构化 如何让你的QTP脚本执行效率更高？ 12. 理解性能测试的指标和性能测试给出的结果曲线参考：性能测试的指标 bs结构程序一般会关注的通用指标如下： Web服务器指标指标： Avg Rps: 平均每秒钟响应次数=总请求时间 / 秒数； Avg time to last byte per terstion （mstes）：平均每秒业务脚本的迭代次数，有人会把这两者混淆； Successful Rounds：成功的请求； Failed Rounds ：失败的请求； Successful Hits ：成功的点击次数； Failed Hits ：失败的点击次数； Hits Per Second ：每秒点击次数； Successful Hits Per Second ：每秒成功的点击次数； Failed Hits Per Second ：每秒失败的点击次数； Attempted Connections ：尝试链接数； cs结构程序，由于一般软件后台通常为数据库，所以我们更注重数据库的测试指标： User 0 Connections ：用户连接数，也就是数据库的连接数量； Number of deadlocks：数据库死锁； Buffer Cache hit ：数据库Cache的命中情况 性能测试给出的结果曲线参考LoadRunner性能测试工具—（三）测试结果样例分析 13. 如果让你负责性能测试，你会按照什么思路开展工作？参考：性能测试的方法是通过模拟生产运行的业务压力量和使用场最组合,测试系统的性能是否满足生产的性能要求。即在特定的运行条件下验证系统的能力状况。主要强调在特定的软硬件环境、特定的测试业务场景下,获得系统的各个性能指标。而身为一个软件测试工程师应根据以下步骤开展工作： 制定目标和分析系统 选择测试度量的方法 学习的相关技术和工具 制定评估标准 设计测试用例 运行测试用例 分析测试结果 课本补充有关软件测试的作用 产品质量的保证 控制成本的关键 软件可靠性确认 让企业具备国际竞争的实力 QA、QC、QM QA 质量保证 QC 质量控制 QM 质量管理 软件测试人才需求快速增长的体现 中国软件产业正在快速增长，需要大量软件相关人才。 软件企业的发展要求测试人才达到一个合适的比例 软件企业开始认识到软件测试对于提高软件质量的重要性，开始重视软件测试。 软件测试技术的内容软件测试包括： 测试计划、测试流程、测试策略、设计测试用例、执行测试、撰写测试报告 单元测试、集成测试、系统测试、确认测试 手工测试、自动化测试 测试工具、缺陷管理和维护工具 编写操作手册、功能手册、系统管理手册、培训手册 维护文档、维护测试环境、分析问题、归纳推理能力 测试用例的组成 用例标识 用例名称 被测功能 用例目的 数据准备 测试步骤 预期结果 实际结果 测试人员 测试日期 编写测试用例的注意事项要解决4W问题 why when who what 测试用例说明包含的要素 标识符 测试项 输入说明 输出说明 环境要求 特殊要求 用例依赖性 测试的三大原则1. 尽早测试2. 连续测试3. 自动化测试 软件测试职业素质 软件测试员的目标：——发现潜在的软件缺陷 软件测试员应具备的素质： 具有探索精神 具有创造性 坚持不懈的精神 故障排除专家 判断准确 追求完美 沟通能力 软件危机内在的原因 在软件开发过程中，软件缺陷的积累和放大效应是导致软件危机的主要原因 人员和其他资源的投入导致开发成本急剧增加，带有缺陷的开发成果导致开发质量大幅下降，反复无常的修改导致开发效率严重底下 因此，迫切地需要规范化地过程来制约软件开发的无序性，便产生了软件工程。 怎样写测试计划 确定内容 总的测试计划 分阶段的测试计划 参考测试模板 考虑以下问题 测试问题 测试策略 测试技术 测试组织 测试准备 测试计划的用途 为测试中的管理工作和技术工作提供指导 确定达到测试目标和测试目的的必要的测试类型和范围 概述有效使用资源的时间和活动的时间顺序安排 通过建立需求跟踪矩阵，为可能的、最高水平的测试覆盖提供保证 概述测试程序脚本的详细内容，描述如何执行测试程序脚本 概述测试所需的人员、财力、设备和工具资源 测试计划的作用 避免测试的“事件驱动” 使测试工作和整个开发工作融合起来 资源和变更事先作为一个可控制的风险 测试需求分析 什么时候进行测试需求分析在开始测试设计之前确定测试需求 测试需求分析做什么？清晰地定义测试需求并形成文档，使所有工作人员理解测试工作的基础 测试需求分析的目的是什么？识别验证系统所需的不同类型的测试，在哪个测试阶段完成。 白盒测试能做什么？ 保证模块内的所有独立路径至少执行一次 执行所有逻辑判定为真和为假的情况 在循环可操作范围内，执行所有边界循环 运用内部数据结构以保证其有效性 单元测试方法在对每个模块进行单元测试时，需要考虑它和周围模块之间的相互联系。为模拟这一联系，在进行单元测试时，必须设置若干个辅助测试模块，这些辅助模块分为两种： 驱动模块。相当于被测模块的主程序，用以模拟被测模块的上级模块，用于接收测试数据，并把这些数据传送给被测模块，启动被测模块，最后输出实测结果。 桩模块。相当于被测模块调用的子模块，用以模拟被测模块的下级模块。 测试评估 软件测试的主要评测方法包括覆盖评测和质量评测。 覆盖评测是对测试完全程度的评测，它建立在测试覆盖基础上测试覆盖是由 测试需求和 测试用例的覆盖或 已执行代码的覆盖表示的 质量评测是对测试对象（系统或测试的应用程序）的可靠性、稳定性以及性能的评测。质量建立在对测试结果的评估和对测试过程中确定的缺陷及缺陷修复的分析的基础上。 功能测试一般什么时候执行 白盒测试可以在编码的早期进行 功能测试主要在后期执行 功能测试的两种策略 顺序测试每个程序特性的功能 一个模块一个模块的测试，即每个功能在其最先调用的地方测试 功能测试的特点 优点 对于较大的代码单元来说（子系统甚至系统级），黑盒测试效率高 测试人员不需要了解实现的细节，包括特定的编程语言 测试人员和编码人员是彼此独立的 从用户的视角进行测试，很容易被理解和接受 有助于暴露任何规格不一致或有歧义的问题 测试用例设计可以在规格完成之后马上进行 缺点 覆盖率较低，大概只能达到总代码量的30% 自动化测试的复用性较低 没有清晰的和简明的规格，测试用例是很难设计的 测试需求和用户需求的区别 测试范围变化 实现方式变化 用测试策略去过滤用户需求 标准手工功能测试和实用手工功能测试的比较 标准软件开发生命周期 实际软件开发生命周期 标准手工功能测试的过程 实用手工功能测试的过程 实用手工功能测试的关注重点 良好的测试用例的特征 可以最大程度地找出软件隐藏的缺陷 可以最高效率地找出软件缺陷 可以最大程度地满足测试覆盖要求 既不过分复杂，也不能过分简单 使软件缺陷的表现可以清楚的判定 不包含重复的测试用例 测试用例的内容清晰、格式一致、分类组织管理 为什么设计良好的（最佳）的测试用例 输入量太大 输出结果太多 软件实现途径太多 软件缺陷的标准不同 完全测试是不可能的 性能测试的类型 并发（竞争）测试 负载测试 压力测试 大数据量测试 疲劳测试 可靠性测试 基准测试 配置测试 性能测试的目标（问题：为了实现目标怎么选择性能测试类型） 评价系统当前性能 寻找瓶颈，优化性能 预测系统未来性能，可扩展性 系统的参数配置 发现一些软件算法方面的缺陷 产品评估/选型 性能测试关注的内容 是否满足需求 并发用户数/吞吐量 平均响应时间 服务器资源占用情况 故障恢复时间 负载量分析的步骤 识别性能测试的目标 与最终客户一起定义 文档化以确保一致 定义负载量 识别关键业务功能 定义场景如何被执行 近似的数据访问模式 识别用户类型和特性 选择测量点 编写负载量分析文档 用来创建有效的测试场景 与最终客户一起复审（获得负载量模型的认可） 软件安全性测试的方法 功能测试（专门设计的安全功能） 漏洞扫描 模拟攻击实验 侦听技术","categories":[{"name":"期末复习","slug":"期末复习","permalink":"http://yoursite.com/categories/期末复习/"},{"name":"软件测试","slug":"期末复习/软件测试","permalink":"http://yoursite.com/categories/期末复习/软件测试/"}],"tags":[{"name":"软件测试","slug":"软件测试","permalink":"http://yoursite.com/tags/软件测试/"},{"name":"期末复习","slug":"期末复习","permalink":"http://yoursite.com/tags/期末复习/"}]},{"title":"缺陷跟踪","slug":"缺陷跟踪","date":"2019-07-17T16:00:00.000Z","updated":"2019-10-11T00:05:57.193Z","comments":true,"path":"2019/07/18/缺陷跟踪/","link":"","permalink":"http://yoursite.com/2019/07/18/缺陷跟踪/","excerpt":"简答题开发各阶段缺陷放大图","text":"简答题开发各阶段缺陷放大图 同行评审 同行评审的种类 正式评审 技术审查 走查 同行评审方式的选择 工作产品刚勾画，起草时—走查 完成了某一个单独的章节时—技术审查 整个产品完成时—正式评审 软件缺陷发现 同行评审 软件测试 管理评审 PPQA发现 项目组内部发现 客户反馈 软件缺陷生命周期软件缺陷生命周期主要由四个阶段组成： 识别 调查 改正 总结 缺陷度量 缺陷度量：CMMI第四级（量化管理级）的软件组织会根据已收集的缺陷数据，采用统计过程控制（Statistical Process Control,SPC)的方法建立软件过程能力基线（Process Capability Baseline，PCB），定量地刻划出软件或过程的特点，进行量化管理。 SPC:利用统计方法对过程中的各个阶段进行控制，从而达到改进与保证质量的目的；强调以全过程的预防为主；方法是建立控制图 PCB：用基线形式量化地表示过程能力；PCB是个不断随着数据累积校正的过程，本身数据收集必须遵循客观、准确、事实，确保组织基线可以持续为各项目研发作为参考标准；运用PCB有助于对过程的分析和改进； PCB是一组能力指标，是过程实际能力的具体体现。通常包括期望值（Mean）、控制上限（Upper Control Limit，UCL）、控制下限（Low Control Limit，LCL）。以缺陷密度为例， Mean描述了未来项目的缺陷密度的预期值，UCL和LCL描述了未来项目的缺陷密度的合理变化范围。 这样的过程能力基线可用来：(1)帮助未来的项目设立量化的项目质量目标；(2)理解和控制未来项目的实际结果。 软件缺陷跟踪管理流程 总体流程 提交流程 修复流程 验证流程 拒绝流程 争议处理流程 缺陷挂起流程 缺陷状态常用软件缺陷状态 编号 缺陷状态 描述 1 提交（Submitted或New） 已提交的缺陷 2 打开（Open或Active） 经审查后确认的缺陷，等待处理 3 拒绝（Rejected、Refuse或Not a bug） 经审查确认不是缺陷、不需要修复或不需要提交 4 修复（Resolved或Fixed） 或为Fixed。缺陷已被修复 5 关闭（Closed或Inactive） 经审查确认已被修复的缺陷，可将其关闭 6 推迟（Later、Pending或Deferred） 当前无法修复，以后条件具备时再解决，但要确定修复的日期 7 重新打开（Reopen) 经过修复的缺陷未通过验证测试，或已关闭的缺陷重新出现 软件缺陷报告“5C”原则： 内容正确(Correct)：每个组成部分的描述正确，不会引起误解。 内容清晰(Clear)：每个组成部分的描述清晰，易于理解。 步骤简洁(Concise)：只包含必不可少的信息，不包括任何多余的内容。 结构完整(Complete)：包含复现该缺陷的完整步骤和其他本质信息。 风格一致（Consistent）：按照一致的格式书写全部缺陷报告。 优秀的缺陷报告 重现步骤 (1) 打开编辑文字的软件 （2）创建一个新文档（这个文档可以录入文字） （3）在这个文档里随意录入一两行文字（任意） （4）选中录入的一两行文字，选择Font菜单，然后选择Arial字体格式 （5）一两行文字变成了无意义的乱字符 期望结果 当用户选择已录入的文字并改变文字格式时，文本应该正确显示选中的文字格式，不会显示成乱字符 实际结果 这是字体格式的问题，如果把文字格式改变成Arial前保存文件，缺陷不会出现。缺陷仅发生在Win98，且改变文字格式成其他字体格式时正常。 缺陷工具： Bugzilla是一款免费、跨平台的开源缺陷跟踪系统，最初是专门为Unix定制开发的，目前也可在windows、Mac OS平台安装使用，在wins操作系统下的安装和配置略为复杂。bugzilla历史悠久、功能强大、受到很多企业用户的欢迎。 Mantis是一款开源的基于PHP的轻量级跟踪系统，简洁灵活，安装容易，扩展性强，其实用性足以满足中小型项目的缺陷管理和跟踪需要。 禅道：集产品管理、项目管理、质量管理、文档管理、组织管理和事务管理于一体，避免了一个团队使用多个工具，较bugfree功能更全面。 TestCenter是一款集测试需求、测试用例、测试过程、测试结果、以及测试报告管理的测试管理工具。 BugFree基于浏览器，简单、方便、易用的免费、开源的缺陷管理工具。 大题注入-发现矩阵实例 缺陷注入阶段/缺陷发现阶段 需求阶段 概要设计阶段 详细设计阶段 编码阶段 单元测试阶段 集成测试阶段 系统测试阶段 现场阶段 注入合计 需求评审 概要设计审查 49 681 730 详细设计审查 6 42 681 729 代码审查 12 28 114 941 1095 单元测试 21 43 43 223 2 332 集成测试 20 41 61 261 —— 4 387 系统测试 6 8 24 72 —— —— 1 111 现场 8 16 16 40 —— —— —— 1 81 发现合计 122 859 939 1537 2 4 1 1 3465 本阶段缺陷移除率 —— 74% 61% 55% 36% 67% 58% 思路：单元测试：332/（122+859+939+1537+2-730-729-1095）x100%=36% 故障树参考：故障树PPT 故障树分析逻辑门 例题 使用MOCUS算法确定最小割集。首先画出一个足够大的矩阵表格，然后按下面的步骤填充矩阵： 将故障事件门的字符放在左上角（0，0）单元格 将每个门的字符用其下方较低级别的门或基本事件的字符或数字替换，重复此过程。 对于或门：将字符写成一竖排（也就是竖着写）；对于与门：将字符写成一横排。","categories":[{"name":"期末复习","slug":"期末复习","permalink":"http://yoursite.com/categories/期末复习/"},{"name":"缺陷跟踪","slug":"期末复习/缺陷跟踪","permalink":"http://yoursite.com/categories/期末复习/缺陷跟踪/"}],"tags":[{"name":"期末复习","slug":"期末复习","permalink":"http://yoursite.com/tags/期末复习/"},{"name":"缺陷跟踪","slug":"缺陷跟踪","permalink":"http://yoursite.com/tags/缺陷跟踪/"}]},{"title":"软件工程","slug":"软件工程","date":"2019-07-17T16:00:00.000Z","updated":"2019-10-11T00:06:20.735Z","comments":true,"path":"2019/07/18/软件工程/","link":"","permalink":"http://yoursite.com/2019/07/18/软件工程/","excerpt":"软件工程简答题1. 社会、健康、安全、法律、文化、环境对软件工程有什么影响？（举例子说明）","text":"软件工程简答题1. 社会、健康、安全、法律、文化、环境对软件工程有什么影响？（举例子说明） 答： 卓越工程师教育培养计划 金融危机会导致软件业风险的不确定增加。等等。。。 软件工程监理体系建设及其对软件产业影响研究 知识产权 软件工程环境 996ICU 隐私保护等等。 2. 以下是否是软件需求项？什么类别的需求项？ 目标软件必须用Java语言实现。约束性需求 目标软件必须有一个主控模块和分别移动、照相和岩石采集控制的三个子模块组成。否 目标软件必须在0.5秒内响应外部事件。非功能需求-性能需求 当目标软件与用户交互时，必须使用特定的菜单和对话框。否 3. 比较黑盒测试和白盒测试的优缺点。答： 黑盒测试的优点 比较简单，不需要了解程序内部的代码及实现。 与软件的内部实现无关。 从用户角度出发，能很容易的知道用户会用到哪些功能，会遇到哪些问题。 基于软件开发文档，所以也能知道软件实现了文档中的哪些功能。 在做软件自动化测试时较为方便。 黑盒测试的缺点 不可能覆盖所有的代码，覆盖率较低，大概只能达到总代码量的30%。 自动化测试的复用性较低。 白盒测试的优点 帮助软件测试人员增大代码的覆盖，提高代码的质量，发现代码中隐藏的问题。 白盒测试的缺点 程序运行会有很多不同的路径，不可能测试所有的运行路径。 测试基于代码，只能测试开发人员做的对不对，而不能知道设计的正确与否，可能会漏掉一些功能需求。 系统庞大时，测试开销会非常大。 4. 软件生存期模型各个模型的适用范围答： 瀑布模型适用范围：需求明确，小规模软件开发。 快速原型模型适用范围：用户需求不明确，需要通过构建原型来清楚地了解用户的真实需求。 增量模型适用范围：软件开发周期较长的软件，有持续的合作。 螺旋模型适用范围：内部软件开发的大规模软件项目。 喷泉模型适用模型：面向对象的软件开发过程。 5. 为什么要进行软件项目管理参考：任何项目都需要管理，只有认真地管理才能使项目成功地达到预期的目标。预期的目标应该包括以下方面： 达到项目预期的软件产品功能和性能要求，使用户认为这样的软件产品正是自己所期待的，也就是说软件产品达到了用户已认可的需求规格说明的要求。 时限要求。 项目开销限制在预算之内。 同时软件项目管理涉及的几个主要方面是人员、产品、过程和项目，即所谓的4P(People、Produce、Process、Project). 开发人员项目管理是对软件工作的管理，但归根结底是对人员行为的管理，就是对人员的管理。人的因素是软件工程的核心因素，对于这一核心因素的把握决定着项目的成败。在项目的人员管理上需要考虑的几个问题是：1). 利益相关方2). 团队负责人3). 团队集体 产品软件工程是软件项目的成果和预期的目标，然而，软件这种无形的产品在开发出来以前，要想准确地描述它的规模、工作量，甚至他的功能和性能是困难的。除此以外，软件需求的稳定性问题更增加了项目工作的难度。 产品的工作环境 产品的功能和性能 产品工作处理的是什么数据，经他处理后得到什么数据。 过程过程在软件工程项目中是重要的因素，它决定着项目中开展哪些活动以及对活动的要求和开展活动的顺序。 项目项目管理的任务是如何利用已有的资源，组织实施既定的项目，提交给用户适用的产品。在此我们将项目管理要开展的主要工作分为3类：1). 计划与计划管理，其中包括：项目策划及计划制定；项目估算；风险分析及风险管理；进度管理；计划跟踪与监督。2). 资源管理，包括：人员管理；成本管理。3). 成果要求管理，包括：需求管理；配置管理；质量管理。 从开发人员、产品、过程、项目四个方面进行论述 6. 为什么软件维护的费用一直那么高参考：软件维护不仅针对程序代码，而且还针对软件定义、开发的各个阶段生成的文档。而软件在设计阶段很难预料到这个软件交给谁，在什么时候进行什么样的维护工作。软件维护的依据只能靠软件文档和有关的设计信息。这样，软件维护人员不得不花费大量的劳动，用于软件系统的再分析和对软件信息的理解。因此软件的维护费用也就一直高居不下。 7. 软件生命周期，各个过程主要工作答： 可行性分析（研究）与计划阶段要确定该软件的开发目标和总的要求，要进行可行性分析、投资收益分析、制定开发计划，并完成可行性分析报告、开发文档等文档（输出）。 需求分析阶段由系统分析人员对被设计的系统进行系统分析，确定对该软件的各项功能、性能需求和设计约束，确定对文档编制的要求，作为本阶段工作的结果，输出有：软件需求规格说明(也称为：软件需求说明、软件规格说明)、数据要求说明和初步的用户手册应该编写出来。 设计阶段系统设计人员和程序设计人员应该在反复理解软件需求的基础上，提出多个设计，分析每个设计能履行的功能并进行相互比较，最后确定一个设计，包括该软件的结构、模块(或CSCI)的划分、功能的分配，以及处理流程。系统比较复杂的情况下，设计阶段应分解成概要设计阶段和详细设计阶段两个步骤。在一般情况下，完成的文档包括：结构设计说明、详细设计说明和测试计划初稿。 实现阶段要完成源程序的编码、编译(或汇编)和排错调试得到无语法错的程序清单，要开始编写进度日报、周报和月报(是否要有日报或周报，取决于项目的重要性和规模)，并且要完成用户手册、操作手册等面向用户的文档的编写工作，还要完成测试计划的编制。 测试阶段该程序将被全面地测试，已编制的文档将被检查审阅。一般要完成测试分析报告。作为开发工作的结束，所生产的程序、文档以及开发工作本身将逐项被评价，最后写出项目开发总结报告。 运行与维护阶段软件将在运行使用中不断地被维护，根据新提出的需求进行必要而且可能的扩充和删改、更新和升级。软件维护分为改正性维护、适应性维护和预防性维护，分别对应于前面的三个问题。改正性维护就是修改原有的缺陷、适应性维护就是使软件适应新的软硬件环境，预防性维护就是把今天的技术用在昨天的软件上，以期软件在明天还能使用。 8. 为什么程序员在进行单元测试时多以白盒测试为主，而软件测试工程师在进行系统集成测试多以黑盒测试为主？参考：白盒测试方法按照程序内部的结构测试程序，检验程序中的每条通路是否都能按预定要求正确工作，而不顾它的功能。 黑盒测试并不涉及程序的内部结构和内容特性，主要根据规格说明，只依靠被测试程序的输入和输出之间关系或程序的功能来设计测试用例。 论述题1. 用户最终要执行的使用的最终产品写出来的代码，只要在开发阶段做的好，产品就是一定成功的？ 2. 软件在交付的时候，如果软件在运行的时候没有问题就是高质量的软件 3. 从用户得到的原始需求不用分析就可以作为软件设计阶段的依据。","categories":[{"name":"期末复习","slug":"期末复习","permalink":"http://yoursite.com/categories/期末复习/"},{"name":"软件工程","slug":"期末复习/软件工程","permalink":"http://yoursite.com/categories/期末复习/软件工程/"}],"tags":[{"name":"期末复习","slug":"期末复习","permalink":"http://yoursite.com/tags/期末复习/"},{"name":"软件工程","slug":"软件工程","permalink":"http://yoursite.com/tags/软件工程/"}]},{"title":"解决git clone速度慢的问题","slug":"解决git clone速度慢的问题","date":"2019-07-16T16:00:00.000Z","updated":"2019-10-11T00:05:43.981Z","comments":true,"path":"2019/07/17/解决git clone速度慢的问题/","link":"","permalink":"http://yoursite.com/2019/07/17/解决git clone速度慢的问题/","excerpt":"解决方案","text":"解决方案 1. 在git内部设置代理 命令行 git config --global http.proxy socks5://127.0.0.1:1080 git config --global https.proxy socks5://127.0.0.1:1080 直接编辑相关文件 C:\\Users\\用户名文件夹下的 .gitconfig,点击打开。将以下内容添加进去。 [http] proxy = socks5://127.0.0.1:1080 [https] proxy = socks5://127.0.0.1:1080 2. 注意下载时是否是https3. 在使用代理下载时，会遇到git push需要每次输入密码。通过以下方式解决该问题。 设置记住密码（默认15分钟）： git config --global credential.helper cache 如果想自己设置时间，可以这样做： git config credential.helper &#39;cache --timeout=3600&#39; 这样就设置一个小时之后失效 长期存储密码： git config --global credential.helper store 参考 提高 git clone 速度 git设置代理、记住密码","categories":[{"name":"git","slug":"git","permalink":"http://yoursite.com/categories/git/"},{"name":"git clone速度慢","slug":"git/git-clone速度慢","permalink":"http://yoursite.com/categories/git/git-clone速度慢/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"git clone速度慢","slug":"git-clone速度慢","permalink":"http://yoursite.com/tags/git-clone速度慢/"}]},{"title":"整合Swagger","slug":"Spring Boot 整合Swagger","date":"2019-07-12T16:00:00.000Z","updated":"2019-10-11T00:13:16.340Z","comments":true,"path":"2019/07/13/Spring Boot 整合Swagger/","link":"","permalink":"http://yoursite.com/2019/07/13/Spring Boot 整合Swagger/","excerpt":"Swagger 是一款RESTFUL接口的文档在线自动生成+功能测试功能软件。本文简单介绍了在项目中集成swagger的方法和一些常见问题。 如果想深入分析项目源码，了解更多内容，见参考资料。Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。总体目标是使客户端和文件系统作为服务器以同样的速度来更新。文件的方法，参数和模型紧密集成到服务器端的代码，允许API来始终保持同步。Swagger 让部署管理和使用功能强大的API从未如此简单。","text":"Swagger 是一款RESTFUL接口的文档在线自动生成+功能测试功能软件。本文简单介绍了在项目中集成swagger的方法和一些常见问题。 如果想深入分析项目源码，了解更多内容，见参考资料。Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。总体目标是使客户端和文件系统作为服务器以同样的速度来更新。文件的方法，参数和模型紧密集成到服务器端的代码，允许API来始终保持同步。Swagger 让部署管理和使用功能强大的API从未如此简单。 整合pom.xml &lt;!-- swagger api文档 --&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.6.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.6.1&lt;/version&gt; &lt;/dependency&gt; SwaggerConfig.javapackage com.cleanhome.service.config; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import springfox.documentation.builders.ApiInfoBuilder; import springfox.documentation.builders.PathSelectors; import springfox.documentation.builders.RequestHandlerSelectors; import springfox.documentation.service.ApiInfo; import springfox.documentation.spi.DocumentationType; import springfox.documentation.spring.web.plugins.Docket; import springfox.documentation.swagger2.annotations.EnableSwagger2; /** * @author Yan * @date 2019/6/10 13:58 * * swaggerui配置文件 */ @Configuration @EnableSwagger2 public class SwaggerConfig { /** * 创建API应用 * apiInfo() 增加API相关信息 * 通过select()函数返回一个ApiSelectorBuilder实例,用来控制哪些接口暴露给Swagger来展现， * 本例采用指定扫描的包路径来定义指定要建立API的目录。 * * @return */ @Bean public Docket createRestApi() { return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage(&quot;com.cleanhome.service.controller&quot;)) .paths(PathSelectors.any()) .build(); } /** * 创建该API的基本信息（这些基本信息会展现在文档页面中） * 访问地址：http://项目实际地址/swagger-ui.html * @return */ private ApiInfo apiInfo() { return new ApiInfoBuilder() .title(&quot;XXXX&quot;) .description(&quot;XXXX&quot;) .termsOfServiceUrl(&quot;https://yanxin152133.github.io/&quot;) .contact(&quot;yan&quot;) .version(&quot;1.0&quot;) .build(); } } 使用package com.cleanhome.service.controller; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import com.cleanhome.service.bean.EjCustomer; import com.cleanhome.service.service.impl.IEjCustomerServiceImpl; import com.cleanhome.service.utils.Message; import com.cleanhome.service.utils.MessageUtil; import io.swagger.annotations.Api; import io.swagger.annotations.ApiImplicitParam; import io.swagger.annotations.ApiImplicitParams; import io.swagger.annotations.ApiOperation; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.propertyeditors.CustomDateEditor; import org.springframework.web.bind.WebDataBinder; import org.springframework.web.bind.annotation.*; import org.springframework.web.context.request.WebRequest; import java.text.DateFormat; import java.text.SimpleDateFormat; import java.util.Date; import java.util.List; import java.util.Map; /** * @author Yan、ysq * @date 2019/6/11 8:40 * 顾客 * 主要功能： * 1.查询顾客的所有信息 * 2.查询顾客数量 * 3.添加顾客信息 * 4.根据编号进行删除顾客信息 * 5.根据编号进行更新操作 */ @RestController @RequestMapping(&quot;/customer&quot;) @Api(value = &quot;/customer&quot;, description = &quot;顾客信息管理&quot;) public class EjCustomerController { Logger logger = LoggerFactory.getLogger(EjCustomerController.class); @Autowired private IEjCustomerServiceImpl ejCustomerService; @InitBinder public void initBinder(WebDataBinder binder, WebRequest request) { //转换日期 DateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, true));// CustomDateEditor为自定义日期编辑器 } //查询顾客的所有信息 @ApiOperation(value = &quot;查询顾客的所有信息&quot;) @GetMapping(&quot;findAll&quot;) public Message findAll() { List&lt;EjCustomer&gt; list = ejCustomerService.findAll(); logger.info(&quot;查询顾客所有信息成功&quot;); return MessageUtil.success(&quot;查询顾客所有信息成功&quot;, list); } //查询顾客数量 @ApiOperation(value = &quot;查询顾客数量&quot;) @GetMapping(&quot;findCustomer_Num&quot;) public Message findCustomer_Num() { int num = ejCustomerService.findCustomer_Num(); logger.info(&quot;查询顾客数量成功&quot;); return MessageUtil.success(&quot;查询顾客数量成功&quot;, num); } //查询当天新增顾客量 @ApiOperation(value = &quot;查询当天新增顾客量&quot;) @GetMapping(&quot;TodayCustomerNum&quot;) public Message TodayCustomerNum() { int num = ejCustomerService.TodayCustomerNum(); logger.info(&quot;查询当天新增顾客量成功&quot;); return MessageUtil.success(&quot;查询当天新增顾客量成功&quot;, num); } //添加顾客信息 @ApiOperation(value = &quot;添加顾客信息&quot;) @PostMapping(&quot;insert&quot;) @ApiImplicitParams({ @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;id&quot;, value = &quot;顾客编号&quot;, required = false, dataType = &quot;Integer&quot;), @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;account&quot;, value = &quot;顾客账号&quot;, required = true, dataType = &quot;Long&quot;), @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;password&quot;, value = &quot;顾客账号密码&quot;, required = true, dataType = &quot;String&quot;), @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;realname&quot;, value = &quot;顾客真实姓名&quot;, required = true, dataType = &quot;String&quot;), @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;status&quot;, value = &quot;状态&quot;, required = true, dataType = &quot;String&quot;), @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;photo&quot;, value = &quot;顾客头像&quot;, required = true, dataType = &quot;String&quot;), @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;telephone&quot;, value = &quot;顾客联系方式&quot;, required = true, dataType = &quot;String&quot;), @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;register_time&quot;, value = &quot;顾客注册时间&quot;, required = true, dataType = &quot;java.util.Date&quot;) }) public Message insert(EjCustomer ejCustomer) throws Exception { boolean isValid = ejCustomerService.isExits(ejCustomer.getAccount()); if (isValid) { try { ejCustomerService.insert(ejCustomer); logger.info(&quot;添加顾客信息成功&quot;); return MessageUtil.success(&quot;添加顾客信息成功&quot;); } catch (Exception e) { e.printStackTrace(); return MessageUtil.error(e.getMessage()); } } else { logger.warn(&quot;添加顾客信息失败&quot;); return MessageUtil.error(&quot;error&quot;); } } //根据顾客id删除用户信息 @ApiOperation(value = &quot;根据顾客id删除顾客信息&quot;) @GetMapping(&quot;deleteById&quot;) @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;id&quot;, value = &quot;顾客编号&quot;, required = true, dataType = &quot;Integer&quot;) public Message deleteById(Integer id) throws Exception { try { ejCustomerService.deleteById(id); logger.info(&quot;顾客编号为&quot; + id + &quot;删除成功&quot;); return MessageUtil.success(&quot;删除顾客信息成功&quot;); } catch (Exception e) { e.printStackTrace(); logger.warn(&quot;顾客信息删除失败&quot;); return MessageUtil.error(e.getMessage()); } } //根据顾客id进行更新操作 @ApiOperation(value = &quot;根据顾客id进行更新&quot;) @PostMapping(&quot;updateById&quot;) @ApiImplicitParams({ @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;id&quot;, value = &quot;顾客编号&quot;, required = true, dataType = &quot;Integer&quot;), @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;account&quot;, value = &quot;顾客账号&quot;, required = false, dataType = &quot;Long&quot;), @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;password&quot;, value = &quot;顾客账号密码&quot;, required = false, dataType = &quot;String&quot;), @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;realname&quot;, value = &quot;顾客真实姓名&quot;, required = false, dataType = &quot;String&quot;), @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;status&quot;, value = &quot;状态&quot;, required = false, dataType = &quot;String&quot;), @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;photo&quot;, value = &quot;顾客头像&quot;, required = false, dataType = &quot;String&quot;), @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;telephone&quot;, value = &quot;顾客联系方式&quot;, required = false, dataType = &quot;String&quot;), }) public Message updateById(EjCustomer ejCustomer) throws Exception{ try { ejCustomerService.updateById(ejCustomer); logger.info(&quot;顾客编号&quot;+ejCustomer.getId()+&quot;更新成功&quot;); return MessageUtil.success(&quot;更新顾客信息成功&quot;); }catch (Exception e){ e.printStackTrace(); logger.warn(&quot;顾客信息更新失败&quot;); return MessageUtil.error(e.getMessage()); } } }","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/categories/Spring-Boot/"},{"name":"Swagger","slug":"Spring-Boot/Swagger","permalink":"http://yoursite.com/categories/Spring-Boot/Swagger/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"},{"name":"Swagger","slug":"Swagger","permalink":"http://yoursite.com/tags/Swagger/"}]},{"title":"Spring Boot整合Druid","slug":"Spring Boot 整合Druid","date":"2019-06-29T16:00:00.000Z","updated":"2019-10-11T00:13:03.571Z","comments":true,"path":"2019/06/30/Spring Boot 整合Druid/","link":"","permalink":"http://yoursite.com/2019/06/30/Spring Boot 整合Druid/","excerpt":"Spring Boot整合Druid","text":"Spring Boot整合Druid pom.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-06-data-jdbc&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;spring-boot-06-data-jdbc&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--引入druid数据源--&gt; &lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.17&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; application.ymlspring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/jdbc username: root password: root type: com.alibaba.druid.pool.DruidDataSource # 数据源其他配置 initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，&#39;wall&#39;用于防火墙 filters: stat,wall maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourceStat: true connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500 DruidConfig.javapackage com.example.springboot.config; import com.alibaba.druid.pool.DruidDataSource; import com.alibaba.druid.support.http.StatViewServlet; import com.alibaba.druid.support.http.WebStatFilter; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.boot.web.servlet.FilterRegistrationBean; import org.springframework.boot.web.servlet.ServletRegistrationBean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import javax.sql.DataSource; import java.util.Arrays; import java.util.HashMap; import java.util.Map; /** * @author Yan * @date 2019/6/8 13:46 */ @Configuration public class DruidConfig { @ConfigurationProperties(prefix = &quot;spring.datasource&quot;) @Bean public DataSource druid(){ return new DruidDataSource(); } //配置Druid的监控 //1、配置一个管理后台的Servlet @Bean public ServletRegistrationBean statViewServlet(){ ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), &quot;/druid/*&quot;); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put(&quot;loginUsername&quot;,&quot;admin&quot;); initParams.put(&quot;loginPassword&quot;,&quot;123456&quot;); initParams.put(&quot;allow&quot;,&quot;&quot;);//默认就是允许所有访问 initParams.put(&quot;deny&quot;,&quot;192.168.15.21&quot;); //拒绝哪些ip访问 bean.setInitParameters(initParams); return bean; } //2、配置一个web监控的filter @Bean public FilterRegistrationBean webStatFilter(){ FilterRegistrationBean bean = new FilterRegistrationBean(); bean.setFilter(new WebStatFilter()); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put(&quot;exclusions&quot;,&quot;*.js,*.css,/druid/*&quot;); bean.setInitParameters(initParams); bean.setUrlPatterns(Arrays.asList(&quot;/*&quot;)); return bean; } }","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/categories/Spring-Boot/"},{"name":"整合Druid","slug":"Spring-Boot/整合Druid","permalink":"http://yoursite.com/categories/Spring-Boot/整合Druid/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"},{"name":"整合Druid","slug":"整合Druid","permalink":"http://yoursite.com/tags/整合Druid/"}]},{"title":"git使用","slug":"git使用","date":"2019-06-02T16:00:00.000Z","updated":"2019-10-11T00:09:16.734Z","comments":true,"path":"2019/06/03/git使用/","link":"","permalink":"http://yoursite.com/2019/06/03/git使用/","excerpt":"","text":"提交文件到GitHub具体步骤如下： 登录GitHub，复制git仓库的地址 [github_repository_url]。 执行 git clone [github_repository_url],将GitHub 的仓库克隆到本地。 进入到克隆的仓库目录，若目录是很久之前克隆出来，需要使用 git pull 以更新到GitHub中的最新文件。 执行 git add . 将所有改动添加到本地仓库中。 执行 git commit -m “这次提交的内容的描述，自行填写” 将改动提交到本地仓库。 执行 git push origin master 将本地的改动提交到GitHub，master 为主分支。 重写历史git add Title git commit -m &quot;ceshi&quot; git commit --amend ##重写上次提交的信息 分支首先，先创建dev,然后切换到dev分支： git checkout -b dev git checkout 命令加上-b参数表示创建并切换，相当于一下两条命令： git branch dev git checkout dev 然后用git branch命令查看当前分支： git branch * dev master git branch命令会列出所有分支，当前分支前面会标一个*号。 之后提交同上步。 合并分支git merge dev git merge命令用于合并指定分支到当前分支 删除分支git branch -d dev","categories":[{"name":"版本控制","slug":"版本控制","permalink":"http://yoursite.com/categories/版本控制/"},{"name":"git","slug":"版本控制/git","permalink":"http://yoursite.com/categories/版本控制/git/"}],"tags":[{"name":"版本控制","slug":"版本控制","permalink":"http://yoursite.com/tags/版本控制/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"Spring MVC和MyBatis开发环境准备","slug":"Spring MVC和MyBatis开发环境准备","date":"2019-05-15T16:00:00.000Z","updated":"2019-10-11T00:14:13.209Z","comments":true,"path":"2019/05/16/Spring MVC和MyBatis开发环境准备/","link":"","permalink":"http://yoursite.com/2019/05/16/Spring MVC和MyBatis开发环境准备/","excerpt":"Spring MVC和MyBatis开发环境准备准备 jdk Intellij IDEA Tomcat Maven MySql","text":"Spring MVC和MyBatis开发环境准备准备 jdk Intellij IDEA Tomcat Maven MySql JDK 安装下载JDK建议使用1.8及以上的版本。官方下载路径：jdk下载路地址 安装双击下载软件，一路单击下一步即可。 配置环境变量Windows：右击【我的电脑】→【属性】→【高级系统设置】→【环境变量】→【系统变量】→【新建】，接着如下图所示： 在【系统变量】的path中添加 %JAVA_HOME%\\bin。 验证，如下图所示： Intellij IDEA下载路径：indea U 激活（针对学生的免费使用计划）参考：Intellij IDEA的下载和使用（针对学生的免费使用计划） Tomcat的安装与配置下载下载链接：Tomcat 8.0其他版本可以查看该页面：下载页面 下载完成后对文件进行解压，解压路径自行设置。 Intellij IDEA 配置 Tomcat步骤如下图： Maven 的安装和配置下载地址：Maven 配置 在Maven的安装目录新建文件夹repository,用来作为本地仓库。 如下图： MySql参考：MySQL 安装| 菜鸟教程","categories":[{"name":"SSM","slug":"SSM","permalink":"http://yoursite.com/categories/SSM/"},{"name":"开发环境准备","slug":"SSM/开发环境准备","permalink":"http://yoursite.com/categories/SSM/开发环境准备/"}],"tags":[{"name":"Spring MVC和MyBatis开发环境准备","slug":"Spring-MVC和MyBatis开发环境准备","permalink":"http://yoursite.com/tags/Spring-MVC和MyBatis开发环境准备/"}]},{"title":"LoadRunner","slug":"LoadRunner","date":"2019-05-10T16:00:00.000Z","updated":"2019-10-11T00:12:01.452Z","comments":true,"path":"2019/05/11/LoadRunner/","link":"","permalink":"http://yoursite.com/2019/05/11/LoadRunner/","excerpt":"LoadRunner 11.0准备： LoadRunner 11.0 安装包 LoadRunner 11.0 破解相关文件","text":"LoadRunner 11.0准备： LoadRunner 11.0 安装包 LoadRunner 11.0 破解相关文件 下载： LoadRunner 11.0 安装包（迅雷下载）：http://www.genilogix.com/downloads/loadrunner/loadrunner-11.iso LoadRunner 11.0 破解相关文件 安装步骤 打开LoadRunner 11.0 安装包文件夹，点击setup.exe。 点击LoadRunner完整安装程序，接着按提示进行下去，当它提示缺省文件的时候可以直接打开“附加组件”进入“Monitor Probe for Microsoft COM+ Server Components”这个文件夹，运行“Com_Plus_Probe.exe”文件即可。 安装成功即进入主界面，进入的时候会有一个提示框出现，意思就是你拥有10天的试用权限。 破解 打开LoadRunner 11.0 破解相关文件，将mlr5lprg.dll和lm70.dll这两个文件复制替换到LoadRunner安装目录的/bin文件下。 以管理员身份运行deletelicense.exe 管理员身份运行LoadRunner。 点击“configuration-&gt;loadRunner License”进入界面，现在你就可以new你自己的license了。下面是不同数量并发的代码：10000个并发：AEABEXFR-YTIEKEKJJMFKEKEKWBRAUNQJU-KBYGB提供一个超级license 最高支持6.5w个并发：AEACFSJI-YJKJKJJKEJIJD-BCLBR。 参考loadRunner 安装及破解 LoadRunner 11.0安装+汉化+破解 loadRunner破解不成功的几个原因","categories":[{"name":"软件测试","slug":"软件测试","permalink":"http://yoursite.com/categories/软件测试/"},{"name":"LoadRunner","slug":"软件测试/LoadRunner","permalink":"http://yoursite.com/categories/软件测试/LoadRunner/"}],"tags":[{"name":"软件测试","slug":"软件测试","permalink":"http://yoursite.com/tags/软件测试/"},{"name":"LoadRunner","slug":"LoadRunner","permalink":"http://yoursite.com/tags/LoadRunner/"}]},{"title":"BugFree安装","slug":"BugFree","date":"2019-04-21T16:00:00.000Z","updated":"2019-10-11T00:06:59.555Z","comments":true,"path":"2019/04/22/BugFree/","link":"","permalink":"http://yoursite.com/2019/04/22/BugFree/","excerpt":"BugFree准备工作：（Windows环境下） XAMPP 版本在5.x.x bugfree_v3.0.1 不要用最新版本的XAMPP，切记。","text":"BugFree准备工作：（Windows环境下） XAMPP 版本在5.x.x bugfree_v3.0.1 不要用最新版本的XAMPP，切记。 下载XAMPP bugfree提取码: ff5d XAMPP 安装双击exe文件傻瓜式安装。 安装 bugfree1.在上一步安装XAMPP时路径C:\\xampp\\htdocs\\下新建文件夹bugfree,将下载bugfree文件解压后的内容复制进去。同时在新建一个BugFile文件夹，用于下一步操作。2.打开XAMPP主界面上的前两个start按钮。3.打开浏览器输入localhost/bugfree,如下图： 4.上图中的全部为绿色的勾勾仅为成功。然后点击继续。5.按照下图中进行配置。 6.然后修改C:\\xampp\\htdocs\\bugfree\\protected\\config中的main.php。全部替换即可。 &lt;?php return array ( &#39;basePath&#39; =&gt; &#39;C:\\\\xampp\\\\htdocs\\\\bugfree\\\\protected\\\\config\\\\..&#39;, &#39;name&#39; =&gt; &#39;BugFree 3.0.1&#39;, &#39;preload&#39; =&gt; array ( 0 =&gt; &#39;log&#39;, ), &#39;language&#39; =&gt; &#39;zh_cn&#39;, &#39;theme&#39; =&gt; &#39;classic&#39;, &#39;defaultController&#39; =&gt; &#39;site&#39;, &#39;timeZone&#39; =&gt; &#39;Asia/Shanghai&#39;, &#39;import&#39; =&gt; array ( 0 =&gt; &#39;application.models.*&#39;, 1 =&gt; &#39;application.components.*&#39;, 2 =&gt; &#39;application.service.*&#39;, ), &#39;modules&#39; =&gt; array ( &#39;gii&#39; =&gt; array ( &#39;class&#39; =&gt; &#39;system.gii.GiiModule&#39;, &#39;password&#39; =&gt; &#39;123456&#39;, &#39;ipFilters&#39; =&gt; array ( 0 =&gt; &#39;127.0.0.1&#39;, 1 =&gt; &#39;::1&#39;, ), ), ), &#39;components&#39; =&gt; array ( &#39;user&#39; =&gt; array ( &#39;allowAutoLogin&#39; =&gt; true, ), &#39;request&#39; =&gt; array ( &#39;enableCookieValidation&#39; =&gt; true, ), &#39;cache&#39; =&gt; array ( &#39;class&#39; =&gt; &#39;CDbCache&#39;, &#39;connectionID&#39; =&gt; &#39;db&#39;, ), &#39;db&#39; =&gt; array ( &#39;pdoClass&#39; =&gt; &#39;NestedPDO&#39;, &#39;connectionString&#39; =&gt; &#39;mysql:host=localhost;dbname=bugfree;port=3306&#39;, &#39;emulatePrepare&#39; =&gt; true, &#39;username&#39; =&gt; &#39;root&#39;, &#39;password&#39; =&gt; &#39;&#39;, &#39;charset&#39; =&gt; &#39;utf8&#39;, &#39;tablePrefix&#39; =&gt; &#39;bf_&#39;, ), &#39;errorHandler&#39; =&gt; array ( &#39;errorAction&#39; =&gt; &#39;site/error&#39;, ), &#39;log&#39; =&gt; array ( &#39;class&#39; =&gt; &#39;CLogRouter&#39;, &#39;routes&#39; =&gt; array ( 0 =&gt; array ( &#39;class&#39; =&gt; &#39;CFileLogRoute&#39;, &#39;levels&#39; =&gt; &#39;info, error, warning&#39;, &#39;categories&#39; =&gt; &#39;bugfree.*&#39;, ), ), ), ), &#39;params&#39; =&gt; array ( &#39;uploadPath&#39; =&gt; &#39;../BugFile&#39;, &#39;picPreviewApp&#39; =&gt; &#39;http://::1/BugFile&#39;, &#39;allUserGroupId&#39; =&gt; 1, &#39;ldap&#39; =&gt; array ( &#39;host&#39; =&gt; &#39;&#39;, &#39;port&#39; =&gt; &#39;&#39;, &#39;base&#39; =&gt; &#39;&#39;, &#39;user&#39; =&gt; &#39;&#39;, &#39;pass&#39; =&gt; &#39;&#39;, ), &#39;mail&#39; =&gt; array ( &#39;on&#39; =&gt; &#39;1&#39;, &#39;from_address&#39; =&gt; &#39;bugfree-noreply@test.com&#39;, &#39;from_name&#39; =&gt; &#39;BugFree&#39;, &#39;send_method&#39; =&gt; &#39;SMTP&#39;, &#39;send_params&#39; =&gt; array ( &#39;host&#39; =&gt; &#39;&#39;, &#39;smtp_auth&#39; =&gt; false, &#39;username&#39; =&gt; &#39;&#39;, &#39;password&#39; =&gt; &#39;&#39;, ), ), ), ) ?&gt; 7.刷新之后就会出现登录界面。","categories":[{"name":"软件缺陷","slug":"软件缺陷","permalink":"http://yoursite.com/categories/软件缺陷/"},{"name":"BugFree","slug":"软件缺陷/BugFree","permalink":"http://yoursite.com/categories/软件缺陷/BugFree/"}],"tags":[{"name":"软件缺陷","slug":"软件缺陷","permalink":"http://yoursite.com/tags/软件缺陷/"},{"name":"BugFree","slug":"BugFree","permalink":"http://yoursite.com/tags/BugFree/"}]},{"title":"qtp破解","slug":"qtp","date":"2019-04-19T16:00:00.000Z","updated":"2019-10-11T00:12:47.292Z","comments":true,"path":"2019/04/20/qtp/","link":"","permalink":"http://yoursite.com/2019/04/20/qtp/","excerpt":"qtp安装与破解准备： QTP 10.0 破解文件","text":"qtp安装与破解准备： QTP 10.0 破解文件 下载 链接: https://pan.baidu.com/s/19TGLWjd_znKFM8RZkj1ITg 提取码: 9wjv 安装 qtp 选择 QTP10.iso,解压后点击文件目录中的 setup.exe,双击运行。按照图片顺序进行操作。 破解1.在c:\\program files\\common files\\mercury interactive目录下新建一个文件夹：License Manager注：64位操作系统在c:\\program files(x86)\\common files\\mercury interactive以下步骤以此类推。 2.将下载的文件中的qtp破解解压，将mgn-mqt8.2.exe复制到qtp的安装路径的bin文件夹中，然后以管理员身份运行。 3.打开c:\\program files\\common files\\mercury interactive\\License Manager中的lservrc文件。 4.将lservrc文件中的内容（将”QuickTestPro”之前的所有字符复制进去，不包括”QuickTestPro”字符）粘贴到如下图中。","categories":[{"name":"软件测试","slug":"软件测试","permalink":"http://yoursite.com/categories/软件测试/"},{"name":"qtp","slug":"软件测试/qtp","permalink":"http://yoursite.com/categories/软件测试/qtp/"}],"tags":[{"name":"软件测试","slug":"软件测试","permalink":"http://yoursite.com/tags/软件测试/"},{"name":"qtp","slug":"qtp","permalink":"http://yoursite.com/tags/qtp/"}]},{"title":"Hexo主题casper使用教程","slug":"Hexo主题casper使用教程","date":"2019-04-16T16:00:00.000Z","updated":"2019-10-11T00:10:52.733Z","comments":true,"path":"2019/04/17/Hexo主题casper使用教程/","link":"","permalink":"http://yoursite.com/2019/04/17/Hexo主题casper使用教程/","excerpt":"Hexo主题casper使用教程demo","text":"Hexo主题casper使用教程demo 安装下载git clone https://github.com/xzhih/hexo-theme-casper.git themes/hexo-casper 更改主题为casper把Hexo根目录的配置文件_config.yml中的theme改为hexo-casper。 升级建议先备份以下再执行下面的操作。 cd themes/casper git pull 添加统一的文章模板参数把下面的内容添加到Hexo根目录下的scaffolds/post.md。 cover_img: # 在文章摘要上显示 feature_img: # 在文章详细页面上置顶 description: # 文章描述 keywords: # 关键字 自定义配置编辑themes/hexo-casper/_config.yml进行配置。 # Config rss: # link favicon: https://i.loli.net/2017/11/26/5a19c0b50432e.png blog_logo: header_image: https://i.loli.net/2017/11/26/5a19c56faa29f.jpg bio: This is a demo post_toc: true # 菜单 menu: About: /about Archives: /archives # 其他的可以按照上面的模板添加 # 作者 author_image: # 链接 author_bio: # 描述 author_location: # 地址 # 社交链接 social: facebook: https://www.facebook.com twitter: https://www.twitter.com twitter: https://twitter.com facebook: https://facebook telegram: bilibili: youtube: # 插件（显示在网站底部） widgets: recent_posts: true category: true tagcloud: true # 这是个简洁的主题，我认为3个就够了 # 文章图片相册（点击图片可以放大） # https://github.com/sachinchoolur/lightgallery.js lightgallery: true # 懒加载 # 首页已经默认开启，其他页面在此开启 # https://github.com/dinbror/blazy lazyload: true # 搜索功能 local_search: true # Valine 评论系统 # https://valine.js.org comment: false valine: notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code appId: # your leancloud application appid appKey: # your leancloud application appkey placeholder: Just go go # comment box placeholder avatar: mm # gravatar style pageSize: 10 # pagination size # PWA # 你需要在 hexo 目录的 source 文件夹里创建一个 manifest.json 文件 manifest: false service_workers: false navColor: &#39;3c484e&#39; # Baidu 链接提交 baidu: false # Google Analytics googleAnalytics: false GA_TRACKING_ID: UA-XXXXXXXXXX-1 本地搜索功能安装npm install hexo-generator-search --save 配置在Hexo根目录下中的_config.yml进行配置。 search： path：search.xml field：post content：true path-文件路径。默认为search.xml。如果文件扩展名为.json，则输出格式为JSON。否则将导出XML格式文件。filed-要搜索的文件范围。 post（默认）-所有帖子 page -所有页面 all -所有帖子和页面 content-是否包含每篇文章的全部内容。默认为true。如果false，生成的结果仅覆盖没有主体的标题和其他元信息。 排除索引要将某个帖子或页面排除在索引之外，您只需indexing: false在其前端的顶部插入设置，例如： title: &quot;Code Highlight&quot; date: &quot;2014-03-15 20:17:16&quot; tags: highlight categories: Demo description: &quot;A collection of Hello World applications from helloworld.org.&quot; toc: true indexing: false ---","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/categories/Hexo/"},{"name":"Hexo主题casper使用教程","slug":"Hexo/Hexo主题casper使用教程","permalink":"http://yoursite.com/categories/Hexo/Hexo主题casper使用教程/"}],"tags":[{"name":"Hexo主题casper使用教程","slug":"Hexo主题casper使用教程","permalink":"http://yoursite.com/tags/Hexo主题casper使用教程/"}]},{"title":"hexo-theme-indigo","slug":"hexo-theme-indigo","date":"2019-04-15T16:00:00.000Z","updated":"2019-10-11T00:10:34.876Z","comments":true,"path":"2019/04/16/hexo-theme-indigo/","link":"","permalink":"http://yoursite.com/2019/04/16/hexo-theme-indigo/","excerpt":"hexo-theme-indigo 主题demo","text":"hexo-theme-indigo 主题demo 主题安装安装需确认Hexo版本在 3.0 以上，以及Node版本在6.x以上，在Hexo根目录，执行以下命令： git clone git@github.com:yscoder/hexo-theme-indigo.git themes/indigo 切换主题在Hexo根目录下的_config.yml文件中修改，如下： theme: indigo 注：记得保存。 依赖安装Less主题默认使用 less 作为 css 预处理工具。 npm install hexo-renderer-less --save Feed用于生成 rss。 npm install hexo-generator-feed --save Json-content用于生成静态站点数据，用作站内搜索的数据源。 npm install hexo-generator-json-content --save QRCode(可选)用于生成微信分享二维码。可选，不安装时会请求 jiathis Api 生成二维码。 npm install hexo-helper-qrcode --save 开启分类页仅 card theme 支持。 hexo new page categories 修改 hexo/source/categories/index.md 的元数据 layout: categories comments: false --- 开启标签页hexo new page tags 修改 hexo/source/tags/index.md 的元数据 layout: tags comments: false --- 常见问题文章截断在Markdown中加 添加多个标签tags: [a, b, c] 或 tags: - a - b - c 分类categories: [a, b, c] 更改站点配色编辑 themes\\indigo\\source\\css_partial\\variable.less，更改对应的颜色变量。配色参考：Material Design Color Palette Generator注意：使用自定义配色时需把主题配置中的 cdn 关闭，cdn: false。 其他参考：https://github.com/yscoder/hexo-theme-indigo/wiki/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98 站点配置编辑站点配置文件 \\themes\\landscape的_config.yml文件。 启动主题theme: indigo 基本配置左侧菜单menu: home: text: 主页 url: / archives: url: /archives tags: url: /tags github: url: https://github.com/yscoder target: _blank weibo: url: http://www.weibo.com/ysweb target: _blank link: text: 测试 url: / 添加新菜单项时，在 menu 下增加子属性即可。属性说明如下： menu: link: # fontawesome图标，省略前缀，本主题前缀为 icon-，必须 text: About # 菜单显示的文字，如果省略即默认与图标一致，首字母会转大写 url: /about # 链接，绝对或相对路径，必须 target: _blank # 是否跳出，省略则在当前页面打开 favicon站点 logo，显示在浏览器当前标签页左上角。 favicon: /favicon.ico 头像位于左侧菜单上方 avatar: /img/logo.jpg email头像下方 email: 634206017@qq.com color设置 Android L Chrome 浏览器状态栏颜色，不需要可去除此项或设为 false。 color: &#39;#3F51B5&#39; 其他参考：https://github.com/yscoder/hexo-theme-indigo/wiki/%E9%85%8D%E7%BD%AE","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/categories/Hexo/"},{"name":"hexo-theme-indigo","slug":"Hexo/hexo-theme-indigo","permalink":"http://yoursite.com/categories/Hexo/hexo-theme-indigo/"}],"tags":[{"name":"hexo-theme-indigo","slug":"hexo-theme-indigo","permalink":"http://yoursite.com/tags/hexo-theme-indigo/"}]},{"title":"Rocket.chat","slug":"Docker搭建Rocket.chat","date":"2019-03-22T16:00:00.000Z","updated":"2019-10-11T00:08:58.377Z","comments":true,"path":"2019/03/23/Docker搭建Rocket.chat/","link":"","permalink":"http://yoursite.com/2019/03/23/Docker搭建Rocket.chat/","excerpt":"Docker 搭建 Rocket.chat","text":"Docker 搭建 Rocket.chat 安装 Docker 参考 Ubuntu 安装 Docker Rocket.chat 搭建获取镜像请输入以下命令： docker pull rocket.chat 启动 首先启动一个mongo实例 docker run --name db -d mongo:3.0 --smallfiles 启动Rocket.chat链接到这个mongo实例 docker run --name rocketchat --link db -d rocket.chat 如果想直接在主机上的标准端口访问实例 docker run --name rocketchat -p 80:3000 --env ROOT_URL=http://localhost --link db -d rocket.chat","categories":[{"name":"Docker","slug":"Docker","permalink":"http://yoursite.com/categories/Docker/"},{"name":"Rocket.chat","slug":"Docker/Rocket-chat","permalink":"http://yoursite.com/categories/Docker/Rocket-chat/"}],"tags":[{"name":"Rocket.chat","slug":"Rocket-chat","permalink":"http://yoursite.com/tags/Rocket-chat/"}]},{"title":"deepin","slug":"deepin","date":"2019-03-20T16:00:00.000Z","updated":"2019-10-11T00:07:49.101Z","comments":true,"path":"2019/03/21/deepin/","link":"","permalink":"http://yoursite.com/2019/03/21/deepin/","excerpt":"Deepin无线网络极慢的解决方案初次安装，出现无线网络网速极慢的状况。","text":"Deepin无线网络极慢的解决方案初次安装，出现无线网络网速极慢的状况。 更改文件参数vim /etc/modprobe.d/iwlwifi.conf 将该文件中的11n_disable=1改为11n_disable=8 驱动安装查看驱动型号输入以下命令 lspci|grep Wireless 例如下图中的型号： 型号为：Intel Corporation Intel Dual Band Wireless-AC 3165 Plus Bluetooth (rev 99) 下载相对应的驱动下载地址：英特尔® 无线适配器的 Linux* 支持 安装输入以下命令： tar -zxvf iwlwifi-7265-ucode-25.30.14.0.tgz sudo cp iwlwifi-*.ucode /lib/firmware sudo reboot 一般情况下是可以解决该问题的。 electorn-ssr下载地址下载地址：electron-ssr也可以根据喜好自己下载：列表 配置一般情况下安装后是无法使用electron-ssr的，需要进行配置。如图（二选一即可）： node.js安装主要讲两个方式： 第一种方式下载下载地址：node.js根据个人习惯进行下载。 安装输入以下命令： tar xvJf node-v10.15.3-linux-x64.tar.xz //解压 cd node-v10.15.3-linux-x64/bin/ ./node -v 设置全局ln -s /home/kun/mysofltware/node-v0.10.28-linux-x64/bin/node /usr/local/bin/node ln -s /home/kun/mysofltware/node-v0.10.28-linux-x64/bin/npm /usr/local/bin/npm # /home/kun/mysofltware/node-v0.10.28-linux-x64/bin/node为自己存放文件的地址 /usr/local/bin/npm和/usr/local/bin/node不需要更改 第二种方式通过命令进行安装，输入以下命令： sudo apt-get install nodejs sudo apt-get install npm 配置Clion更新sudo apt update gcc、g++sudo apt-get install build-essential sudo apt-get install g++ 设置环境变量 sudo vim /etc/profile ## 将以下内容填写进去 export CC=/usr/bin/gcc export CXX=/usr/bin/g++ 验证是否安装成功 gcc --version g++ --version cmake下载下载列表：cmake下载地址:[cmake-3.11.3.tar.gz]https://cmake.org/files/v3.11/cmake-3.11.3.tar.gz 安装新建一个“cmake”目录 cd /home mkdir Cmake 解压 cd /home/Cmake tar -xzvf cmake-3.11.3.tar.gz 进入cmake 目录 cd cmake-3.11.3 编译安装 ### 最好使用root用户 ./bootstrap &amp;&amp; make &amp;&amp; make install 验证是否安装成功 cmake -version 配置Clion如图所示： deepin下idea中文异常输入以下命令 su passwd aptitude search uming aptitude install fonts-arphic-uming 之后重新启动idea（Netbeans也适用） 安装 Docker参考链接：deepin安装Docker Android Studio: /dev/kvm device permission denied安装 qemu-kvm输入以下命令： sudo apt install qemu-kvm 检查/dev/kvm 使用的所有权输入以下命令： ls -al /dev/kvm 结果为： crw-rw---- 1 root kvm 10, 232 3月 11 10:36 /dev/kvm 检查组中的用户kvm，使用： grep kvm /etc/group 添加用户到kvm中，请使用： sudo adduser yourname kvm 再检查 grep kvm /etc/group 最后重启或注销。","categories":[{"name":"deepin","slug":"deepin","permalink":"http://yoursite.com/categories/deepin/"},{"name":"配置","slug":"deepin/配置","permalink":"http://yoursite.com/categories/deepin/配置/"}],"tags":[{"name":"deepin","slug":"deepin","permalink":"http://yoursite.com/tags/deepin/"}]},{"title":"CentOS7+Hadoop-2.9.2+Hbase-1.4.9+MapReduce编程","slug":"CentOS 7+Hadoop-2.9.2+Hbase-1.4.9+MapReduce编程","date":"2019-01-09T16:00:00.000Z","updated":"2019-10-11T00:07:31.756Z","comments":true,"path":"2019/01/10/CentOS 7+Hadoop-2.9.2+Hbase-1.4.9+MapReduce编程/","link":"","permalink":"http://yoursite.com/2019/01/10/CentOS 7+Hadoop-2.9.2+Hbase-1.4.9+MapReduce编程/","excerpt":"所用软件及环境 Centos 7 jdk1.8.0_181 hadoop-2.9.2 Hbase-1.4.9 idea U","text":"所用软件及环境 Centos 7 jdk1.8.0_181 hadoop-2.9.2 Hbase-1.4.9 idea U 注：全程使用root用户 规划 组件 版本 路径 jdk 1.8.0_181 /usr/local/java Hadoop 2.9.2 /usr/local/hadoop Hbase 1.4.9 /usr/local/hbase 节点 node01 node02 node03 注：节点IP根据实际情况自行配置 Hadoop、jdk、Hbase下载下载地址点击即可下载 Hadoop-2.9.2jdk-1.8.0_181Hbase-1.4.9 配置1.主机名修改 在node01上输入 hostnamectl --static set-hostname node01 2.添加各个节点的IP输入： vim /etc/hosts 添加各个节点信息 &lt;!-- 下列的IP需根据自己的主机确定，不唯一 --&gt; 192.168.130.130 node01 192.168.130.133 node02 192.168.130.135 node03 3.防火墙设置 若主机中未安装iptables,执行以下命令进行安装 yum install iptables-services 执行iptables -L -n -v命令可以查看iptables配置，执行以下命令永久关闭主机的iptables： chkconfig iptables off 同时关闭主机的iptables和firewalld并设置开机不启动，执行以下命令： systemctl stop iptables systemctl disable iptables systemctl stop firewalld systemctl disable firewalld 执行systemctl status iptables和systemctl status firewalld可以查看防火墙已经关闭。 4.时钟同步 执行以下命令安装ntdate yum install ntpdate 执行以下命令同步时针 ntpdate us.pool.ntp.org 添加时针同步的定时任务，执行以下命令 crontab -e 接着输入以下内容，设置每天凌晨5点同步时针 0 5 * * * /usr/sbin/ntpdate cn.pool.ntp.org 执行以下命令重启服务并设置开机自启： service crond restart systemctl enable crond.service 5.SSH免密登录 首先执行以下以下命令，可以生成.ssh隐藏文件夹 ssh localhost 接着执行 cd .ssh ssh-keygen -t rsa #遇到提示一路回车就行 ll #会看到 id_rsa id_rsa.pub 两文件前为私钥，后为公钥 cat id_rsa.pub &gt;&gt; authorized_keys #把公钥内容追加到authorized_keys文件中 chmod 600 authorized_keys #修改文件权限，重要不要忽略 在最后的克隆node01得到的node02,node03主机以及node01上可通过ssh node01/node02/node03/node04测试是否可以免密登录若能连接即为成功 6.安装并配置jdk 通过 git 将已下载好的jdk1.8.0_181 发送给各个节点，执行以下命令 cd C:/Users//Yan/Downloads #C:/Users//Yan/Downloads为本人jdk1.8.0_181下载后的路径 scp jdk1.8.0_181 root@192.168.130.130:/usr/local/java #输入密码后即可将jdk1.8.0_181发送给node01,192.168.130.130为自己node01的IP cd /usr/local/java进入该目录后执行 tar -zxvf jdk-8u181-linux-x64.tar.gz 添加环境变量,执行 vim /etc/profile 添加以下配置 export JAVA_HOME=/usr/local/java/jdk1.8.0_181 export JRE_HOME=$JAVA_HOME/jre export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar export PATH=.:$JAVA_HOME/bin:$PATH 之后执行以下命令使配置生效 source /etc/profile 可通过 java -version 查看jdk版本 安装 Hadoop 并配置 执行以下命令 cd /usr/local/hadoop tar -zxvf hadoop-2.9.2.tar.gz #解压 添加环境变量,执行 vim /etc/profile 在该文件中添加以下内容 export HADOOP_HOME=/usr/local/hadoop/hadoop-2.9.2 export PATH=$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbin 执行 source /etc/profile 使配置生效同时创建Hadoop相关配置目录 mkdir -p /data/hadoop/hdfs/name /data/hadoop/hdfs/data /var/log/hadoop/tmp 修改相关文件 执行以下命令 cd /usr/local/hadoop/hadoop-2.9.2/etc/hadoop hadoop-env.shexport JAVA_HOME=/usr/local/java/jdk1.8.0_181 #一定要写真实路径 core-site.xml&lt;configuration&gt; &lt;!-- define the default file system host and port --&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://node01:9000/&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; hdfs-site.xml&lt;configuration&gt; &lt;!-- set namenode storage path--&gt; &lt;!-- storage node info --&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt; &lt;value&gt;file:///root/hdfs/namenode&lt;/value&gt; &lt;description&gt;NameNode directory for namespace and transaction logs storage.&lt;/description&gt; &lt;/property&gt; &lt;!-- set datanode storage path--&gt; &lt;!-- storage data --&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt; &lt;value&gt;file:///root/hdfs/datanode&lt;/value&gt; &lt;description&gt;DataNode directory&lt;/description&gt; &lt;/property&gt; &lt;!-- set the number of copies, default 3, reset to 2 --&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;2&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; mapred-site.xml&lt;configuration&gt; &lt;!-- specify the frame name --&gt; &lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; slavesnode02 node03 node04 yarn-site.xml&lt;configuration&gt; &lt;!-- Ancillary services running on the NodeManager. You need to configure &quot;mapreduce_shuffle&quot; to run the MapReduce program. --&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt; &lt;/property&gt; &lt;!-- The class corresponding to the auxiliary service in the NodeManager. --&gt; &lt;!-- &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services.mapreduce_shuffle.class&lt;/name&gt; &lt;value&gt;org.apache.hadoop.mapred.ShuffleHandler&lt;/value&gt; &lt;/property&gt; --&gt; &lt;!-- Configuration name node --&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt; &lt;value&gt;node01&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; 启动 Hadoop初始化 执行以下命令 cd /usr/local/hadoop/hadoop-2.9.2/bin ./hdfs namenode -format 等待一会后，不报错返回 “Exiting with status 0” 为成功，“Exiting with status 1”为失败切勿多次执行 克隆 对node01进行克隆操作进而得到node02,node03,node04修改node02,node03,node04的主机名，以及检查/etc/hosts文件中的各个节点对应的IP地址是否有误同时也要检查自己配置的/etc/profile文件是否已经生效 启动Hadoop输入以下命令 sudo -s #若是root用户可省略 cd /usr/local/hadoop/hadoop-2.9.2/sbin ./start-all.sh 查看Hadoop进程输入命令jps若出现6个进程则为配置正确在浏览器输入192.168.130.130：8088则可以看到在浏览器输入192.168.130.130：50070则可以看到即配置成功 停止Hadoop./stop-all.sh #在/usr/local/hadoop/hadoop-2.9.2/sbin目录下 安装 Hbase 并配置 执行以下命令 cd /usr/local/hbase/ &lt;!-- 解压 --&gt; tar -zxvf hbase-1.4.9-bin.tar.gz &lt;!-- 创建目录 --&gt; cd hbase-1.4.9/ mkdir logs mkdir pids mkdir tmp 配置/etc/profileexport HBASE_HOME=/usr/local/hbasehbase-1.4.9 export PATH=$HBASE_HOME/bin:$PATH source /etc/profile #使配置立即生效 hbase-env.sh#内容 export JAVA_HOME=/usr/local/java/jdk1.8.0_181 export HBASE_CLASSPATH=/usr/local/hbase/hbase-1.4.9/conf # 此配置信息，设置由hbase自己管理zookeeper，不需要单独的zookeeper。 export HBASE_MANAGES_ZK=true export HBASE_HOME=/usr/local/hbase/hbase-1.4.9 export HADOOP_HOME=/usr/local/hadoop/hadoop-2.9.2 #Hbase日志目录 export HBASE_LOG_DIR=/usr/local/hbase/hbase-1.4.9/logs hbase-site.xml&lt;configuration&gt; &lt;property&gt; &lt;name&gt;hbase.rootdir&lt;/name&gt; &lt;value&gt;hdfs://node01:9000/hbase&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.cluster.distributed&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.master&lt;/name&gt; &lt;value&gt;node01:60000&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt; &lt;value&gt;node01:2181,node02:2181,node03:2181&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; regionserversnode01 node02 node03 拷贝给其他节点scp -r /usr/local/hbase root@node02:/usr/local/ scp -r /usr/local/hbase root@node03:/usr/local/ 启动HBase在node01上启动 执行 cd /usr/local/hbase/hbase-1.4.9/bin ./start-hbase.sh 验证 在每个节点使用jps命令查看 node01上是否有HMaster进程node02,node03上是否有HRegionServer进程 通过node:16010查看HBase集群相关情况,如下图所示： 500 为初始化，稍等即可 wordcount 输入以下命令(root用户下) cd /home/hadoop #hadoop为自己创建的用户名，不固定 touch README.txt vim README.txt #下面为README.txt的内容 hello c hello java hello python hadoop fs -mkdir /wordcount hadoop fs -mkdir /wordcount/input hadoop fs -put /home/hadoop/README.txt /wordcount/input cd /usr/local/hadoop/hadoop-2.9.2/share/hadoop/mapreduce/ hadoop jar hadoop-mapreduce-examples-2.9.2.jar wordcount /wordcount/input /wordcount/output 出现以下信息即为成功： 2018-12-29 20:38:15,997 INFO mapreduce.Job: map 100% reduce 0% 2018-12-29 20:38:24,174 INFO mapreduce.Job: map 100% reduce 100% 2018-12-29 20:38:28,259 INFO mapreduce.Job: Job job_1546086772385_0001 completed successfully 2018-12-29 20:38:29,164 INFO mapreduce.Job: Counters: 55 File System Counters FILE: Number of bytes read=50 FILE: Number of bytes written=429541 FILE: Number of read operations=0 FILE: Number of large read operations=0 FILE: Number of write operations=0 HDFS: Number of bytes read=144 HDFS: Number of bytes written=28 HDFS: Number of read operations=8 HDFS: Number of large read operations=0 HDFS: Number of write operations=2 Job Counters Failed map tasks=3 Launched map tasks=4 Launched reduce tasks=1 Other local map tasks=3 Data-local map tasks=1 Total time spent by all maps in occupied slots (ms)=38093 Total time spent by all reduces in occupied slots (ms)=5732 Total time spent by all map tasks (ms)=38093 Total time spent by all reduce tasks (ms)=5732 Total vcore-milliseconds taken by all map tasks=38093 Total vcore-milliseconds taken by all reduce tasks=5732 Total megabyte-milliseconds taken by all map tasks=39007232 Total megabyte-milliseconds taken by all reduce tasks=5869568 Map-Reduce Framework Map input records=5 Map output records=6 Map output bytes=56 Map output materialized bytes=50 Input split bytes=110 Combine input records=6 Combine output records=4 Reduce input groups=4 Reduce shuffle bytes=50 Reduce input records=4 Reduce output records=4 Spilled Records=8 Shuffled Maps =1 Failed Shuffles=0 Merged Map outputs=1 GC time elapsed (ms)=152 CPU time spent (ms)=2050 Physical memory (bytes) snapshot=517804032 Virtual memory (bytes) snapshot=5624598528 Total committed heap usage (bytes)=336592896 Peak Map Physical memory (bytes)=293904384 Peak Map Virtual memory (bytes)=2790219776 Peak Reduce Physical memory (bytes)=223899648 Peak Reduce Virtual memory (bytes)=2834378752 Shuffle Errors BAD_ID=0 CONNECTION=0 IO_ERROR=0 WRONG_LENGTH=0 WRONG_MAP=0 WRONG_REDUCE=0 File Input Format Counters Bytes Read=34 File Output Format Counters Bytes Written=28 查看统计结果 hdfs dfs -ls /wordcount/output hdfs dfs -cat /wordcount/output/part-r-00000 MapReduce编程pom.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.hadoop&lt;/groupId&gt; &lt;artifactId&gt;wordcount&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;commons-beanutils&lt;/groupId&gt; &lt;artifactId&gt;commons-beanutils&lt;/artifactId&gt; &lt;version&gt;1.9.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-common&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-hdfs&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-mapreduce-client-common&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-mapreduce-client-core&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; src/main/java/WordcountMapper.javaimport org.apache.hadoop.io.IntWritable; import org.apache.hadoop.io.LongWritable; import org.apache.hadoop.io.Text; import org.apache.hadoop.mapreduce.Mapper; import java.io.IOException; /** * Created by zxk on 2017/6/29. */ public class WordcountMapper extends Mapper&lt;LongWritable, Text, Text, IntWritable&gt; { protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException { //得到输入的每一行数据 String line = value.toString(); //通过空格分隔 String[] words = line.split(&quot; &quot;); //循环遍历输出 for (String word : words) { context.write(new Text(word), new IntWritable(1)); } } } src/main/java/WordcountReducer.javaimport org.apache.hadoop.io.IntWritable; import org.apache.hadoop.io.Text; import org.apache.hadoop.mapreduce.Reducer; import java.io.IOException; /** * Created by zxk on 2017/6/29. */ public class WordcountReducer extends Reducer&lt;Text, IntWritable, Text, IntWritable&gt; { protected void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context) throws IOException, InterruptedException { Integer count = 0; for (IntWritable value : values) { count += value.get(); } context.write(key, new IntWritable(count)); } } src/main/java/WordCountMapReduce.java import org.apache.hadoop.conf.Configuration; import org.apache.hadoop.fs.Path; import org.apache.hadoop.io.IntWritable; import org.apache.hadoop.io.Text; import org.apache.hadoop.mapreduce.Job; import org.apache.hadoop.mapreduce.lib.input.FileInputFormat; import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat; /** * Created by zxk on 2017/6/29. */ public class WordCountMapReduce { public static void main(String[] args) throws Exception { //创建配置对象 Configuration conf = new Configuration(); //创建job对象 Job job = Job.getInstance(conf, &quot;wordcount&quot;); //设置运行job的类 job.setJarByClass(WordCountMapReduce.class); //设置mapper 类 job.setMapperClass(WordcountMapper.class); //设置reduce 类 job.setReducerClass(WordcountReducer.class); //设置map输出的key value job.setMapOutputKeyClass(Text.class); job.setMapOutputValueClass(IntWritable.class); //设置reduce 输出的 key value job.setOutputKeyClass(Text.class); job.setOutputValueClass(IntWritable.class); //设置输入输出的路径 FileInputFormat.setInputPaths(job, new Path(args[0])); FileOutputFormat.setOutputPath(job, new Path(args[1])); //提交job boolean b = job.waitForCompletion(true); if (!b) { System.out.println(&quot;wordcount task fail!&quot;); } } } 编译打包 在idea中打jar包可以参考这里 点击 运行&lt;!-- 一些命令与worcount命令相同不再重复 --&gt; hadoop jar hadoop-demo.jar WordCountMapReduce /wordcount/input /wordcount/output 参考 在centos7上搭建hadoop集群CentOS 7搭建Apache Hadoop 3.1.1集群Linux上安装Hadoop集群(CentOS7+hadoop-2.8.0)Centos7虚拟机 搭建 Hadoop3.1.1 教程CentOS 7下安装集群HBase1.2.4windows下idea编写WordCount程序，并打jar包上传到hadoop集群运行 推荐 使用 Docker 搭建 Hadoop 集群","categories":[{"name":"大数据","slug":"大数据","permalink":"http://yoursite.com/categories/大数据/"},{"name":"Hadoop Hbase MapReduce编程","slug":"大数据/Hadoop-Hbase-MapReduce编程","permalink":"http://yoursite.com/categories/大数据/Hadoop-Hbase-MapReduce编程/"}],"tags":[{"name":"大数据","slug":"大数据","permalink":"http://yoursite.com/tags/大数据/"},{"name":"Hadoop Hbase MapReduce编程","slug":"Hadoop-Hbase-MapReduce编程","permalink":"http://yoursite.com/tags/Hadoop-Hbase-MapReduce编程/"}]},{"title":"Hexo yilia 添加目录页面","slug":"Hexo yilia 添加目录页面","date":"2018-12-16T16:00:00.000Z","updated":"2019-10-11T00:09:57.242Z","comments":true,"path":"2018/12/17/Hexo yilia 添加目录页面/","link":"","permalink":"http://yoursite.com/2018/12/17/Hexo yilia 添加目录页面/","excerpt":"步骤 1.添加 categories 页面 2.添加 categories 链接 3.修改 yilia 主题 4.多层分类 5.效果 6.参考文档","text":"步骤 1.添加 categories 页面 2.添加 categories 链接 3.修改 yilia 主题 4.多层分类 5.效果 6.参考文档 1 添加 categories 页面1.1 新建 categories 页面 输入命令： hexo new page categories 该命令在 source 目录下生成一个 categories 目录，categories 目录下有一个 index.md 文件。 1.2 修改 index.md 文件--- title: 文章分类 date: 2018-10-19 11:22:21 type: &quot;categories&quot; layout: &quot;categories&quot; comments: false #关闭评论 --- 2 添加 categories 链接 若主题为 yilia ，则打开 yilia/_config.yml ，修改为： menu: 主页: / 相册: / 分类: /categories 3 修改 yilia 主题3.1 新建yilia/layout/categories.ejs&lt;article class=&quot;article article-type-post show&quot;&gt; &lt;header class=&quot;article-header&quot;&gt; &lt;h1 class=&quot;article-title&quot; itemprop=&quot;name&quot;&gt; &lt;%= page.title %&gt; &lt;/h1&gt; &lt;/header&gt; &lt;% if (site.categories.length){ %&gt; &lt;div class=&quot;category-all-page article-type-post show&quot;&gt; &lt;h3&gt;共计&amp;nbsp;&lt;%= site.categories.length %&gt;&amp;nbsp;个分类&lt;/h3&gt; &lt;ul class=&quot;category-list&quot;&gt; &lt;% site.categories.sort(&#39;name&#39;).each(function(item){ %&gt; &lt;% if(item.posts.length){ %&gt; &lt;li class=&quot;category-list-item&quot;&gt; &lt;a href=&quot;&lt;%- config.root %&gt;&lt;%- item.path %&gt;&quot; title=&quot;&lt;%= item.name %&gt;&quot;&gt;&lt;%= item.name %&gt;&lt;sup&gt;[&lt;%= item.posts.length %&gt;]&lt;/sup&gt;&lt;/a&gt; &lt;/li&gt; &lt;% } %&gt; &lt;% }); %&gt; &lt;/ul&gt; &lt;/div&gt; &lt;% } %&gt; &lt;/article&gt; 3.2 修改 yilia\\source\\main.0cf68a.css，将下面的内容添加进去category-all-page { margin: 30px 40px 30px 40px; position: relative; min-height: 70vh; } .category-all-page h2 { margin: 20px 0; } .category-all-page .category-all-title { text-align: center; } .category-all-page .category-all { margin-top: 20px; } .category-all-page .category-list { margin: 0; padding: 0; list-style: none; } .category-all-page .category-list-item-list-item { margin: 10px 15px; } .category-all-page .category-list-item-list-count { color: $grey; } .category-all-page .category-list-item-list-count:before { display: inline; content: &quot; (&quot;; } .category-all-page .category-list-item-list-count:after { display: inline; content: &quot;) &quot;; } .category-all-page .category-list-item { margin: 10px 10px; } .category-all-page .category-list-count { color: $grey; } .category-all-page .category-list-count:before { display: inline; content: &quot; (&quot;; } .category-all-page .category-list-count:after { display: inline; content: &quot;) &quot;; } .category-all-page .category-list-child { padding-left: 10px; } 4 多层分类4.1 修改yilia/layout/categories.ejs为：&lt;article class=&quot;article article-type-post show&quot;&gt; &lt;header class=&quot;article-header&quot; style=&quot;border-bottom: 1px solid #ccc&quot;&gt; &lt;h1 class=&quot;article-title&quot; itemprop=&quot;name&quot;&gt; &lt;%= page.title %&gt; &lt;/h1&gt; &lt;/header&gt; &lt;% if (site.categories.length){ %&gt; &lt;div class=&quot;category-all-page&quot;&gt; &lt;h2&gt;共计&amp;nbsp;&lt;%= site.categories.length %&gt;&amp;nbsp;个分类&lt;/h2&gt; &lt;%- list_categories(site.categories, { show_count: true, class: &#39;category-list-item&#39;, style: &#39;list&#39;, depth: 2, separator: &#39;&#39; }) %&gt; &lt;/div&gt; &lt;% } %&gt; &lt;/article&gt; 4.2 修改自己的文章--- title: Hexo yilia 添加目录页面 tags: Hexo yilia 添加目录 toc: true categories: [Hexo,创建目录] --- 5 效果 如下图： 6 参考文档 Hexo添加categories页面","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/categories/Hexo/"},{"name":"创建目录","slug":"Hexo/创建目录","permalink":"http://yoursite.com/categories/Hexo/创建目录/"}],"tags":[{"name":"Hexo yilia 添加目录","slug":"Hexo-yilia-添加目录","permalink":"http://yoursite.com/tags/Hexo-yilia-添加目录/"}]},{"title":"GitHub+Hexo搭建个人博客","slug":"GitHub+Hexo搭建个人博客","date":"2018-12-11T16:00:00.000Z","updated":"2019-10-11T00:09:38.213Z","comments":true,"path":"2018/12/12/GitHub+Hexo搭建个人博客/","link":"","permalink":"http://yoursite.com/2018/12/12/GitHub+Hexo搭建个人博客/","excerpt":"搭建步骤 1.GitHub 创建个人仓库 2.安装Git 3.安装Node.js 4.安装Hexo 5.美化 6.部署","text":"搭建步骤 1.GitHub 创建个人仓库 2.安装Git 3.安装Node.js 4.安装Hexo 5.美化 6.部署 1 GitHub 创建个人仓库1.1 创建仓库（用户名.github.io) 1 登录GitHub,如果没有的话请先注册。 2 登录之后点击GitHub 中的 New repository创建新的仓库. 3 仓库名应为：用户名.github.io 比如： 2 安装Git2.1 安装Git 1 安装Git。 2 下载安装成功后进行将自己的Github账号与Git进行绑定. 2.2 配置 1 打开Git,并配置。输入以下命令： git config --global user.name &quot;自己注册GitHub的用户名&quot; git config --global user.email &quot;注册GitHub时所用的邮箱&quot; 2.3 ssh 1 设置user.name和user.email配置信息之后进行生成ssh密匙文件 ssh-keygen -t rsa -C &quot;####@####.com&quot; 2 然后找到该命令生成的id_rsa.pub密匙。路径为 C:\\Users\\Admin\\.ssh 3 打开该文件，推荐使用 Visual Studio Code 打开 2.4 GitHub 添加密匙 1 复制文件中的所有内容，然后进入 GitHub_Settings_Deploy keys 界面，点击右边的Add deploy key 如图所示： 2 新建 new SSH Key 注： title可自定义内容，Key为之前复制的密匙 2.5 检测 1 以上步骤完成后， 检测GitHub公匙是否成功，输入下面的命令： ssh git@github.com ssh连接成功 3 安装Node.js3.1 安装Node.js 1 下载并安装Node.js,根据自己的喜好下载不同的版本 3.2 检测是否安装成功 1 检测Node.js是否安装成功 node -v 2 检测nopm是否安装成功 npm -v 4 安装Hexo4.1 创建 1 创建一个文件夹，创建完成之后选择该文件夹并按住shift右键,如下图所示： 4.2 添加Hexo 1 依次输入,参考Hexo官方文档 npm install hexo-cli -g hexo init npm install hexo server 4.3 预览 1 在浏览器输入localhost:4000 2 若出现错误，参考以下： 使用localhost:4000访问本地blog一直无响应使用localhost:4000访问本地blog一直无响应使用localhost:4000访问本地blog一直无响应 5 美化5.1 挑选主题 1 Hexo官网提供的主题 2 我使用的是yilia，我的博客 5.2 下载主题 1 在根目录打开Git，输入 git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 5.3 更新主题cd thems/yilia git pull 5.4 配置主题 1 根目录打开_config.yml配置文件 2 将 themes:##### 改为 theme: yilia 5.5 个性化主题 1 打开 themes 下的 yilia 文件夹中的 _config.yml 2 配置主题（添加头像，图标及其他） # Header menu: 主页: / 相册: /photos # SubNav subnav: #github: &quot;#&quot; #weibo: &quot;#&quot; #rss: &quot;#&quot; #zhihu: &quot;#&quot; #qq: &quot;#&quot; #weixin: &quot;#&quot; #jianshu: &quot;#&quot; #douban: &quot;#&quot; #segmentfault: &quot;#&quot; #bilibili: &quot;#&quot; #acfun: &quot;#&quot; #mail: &quot;#&quot; #facebook: &quot;#&quot; #google: &quot;#&quot; #twitter: &quot;#&quot; #linkedin: &quot;#&quot; #rss: /atom.xml url: # # 是否需要修改 root 路径 # 如果您的网站存放在子目录中，例如 http://yoursite.com/blog， # 请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。 root: / # Content # 文章太长，截断按钮文字 excerpt_link: more # 文章卡片右下角常驻链接，不需要请设置为false show_all_link: &#39;展开全文&#39; # 数学公式 mathjax: false # 是否在新窗口打开链接 open_in_new: false # 打赏 # 打赏type设定：0-关闭打赏； 1-文章对应的md文件里有reward:true属性，才有打赏； 2-所有文章均有打赏 reward_type: 0 # 打赏wording reward_wording: &#39;谢谢你请我吃糖果&#39; # 支付宝二维码图片地址，跟你设置头像的方式一样。比如：/assets/img/alipay.jpg alipay: # 微信二维码图片地址 weixin: # 目录 # 目录设定：0-不显示目录； 1-文章对应的md文件里有toc:true属性，才有目录； 2-所有文章均显示目录 toc: 1 # 根据自己的习惯来设置，如果你的目录标题习惯有标号，置为true即可隐藏hexo重复的序号；否则置为false toc_hide_index: true # 目录为空时的提示 toc_empty_wording: &#39;目录，不存在的…&#39; # 是否有快速回到顶部的按钮 top: true # Miscellaneous baidu_analytics: &#39;&#39; google_analytics: &#39;&#39; #路径为E:\\Blog\\source favicon: /assets/img/head.png #你的头像url 路径为E:\\Blog\\source avatar: /assets/img/face.jpg #是否开启分享 share_jia: true #评论：1、多说；2、网易云跟帖；3、畅言；4、Disqus；5、Gitment #不需要使用某项，直接设置值为false，或注释掉 #具体请参考wiki：https://github.com/litten/hexo-theme-yilia/wiki/ #1、多说 duoshuo: false #2、网易云跟帖 wangyiyun: false #3、畅言 changyan_appid: false changyan_conf: false #4、Disqus 在hexo根目录的config里也有disqus_shortname字段，优先使用yilia的 disqus: false #5、Gitment gitment_owner: false #你的 GitHub ID gitment_repo: &#39;&#39; #存储评论的 repo gitment_oauth: client_id: &#39;&#39; #client ID client_secret: &#39;&#39; #client secret # 样式定制 - 一般不需要修改，除非有很强的定制欲望… style: # 头像上面的背景颜色 header: &#39;#4d4d4d&#39; # 右滑板块背景 slider: &#39;linear-gradient(200deg,#a0cfe4,#e8c37e)&#39; # slider的设置 slider: # 是否默认展开tags板块 showTags: false # 智能菜单 # 如不需要，将该对应项置为false # 比如 #smart_menu: # friends: false smart_menu: innerArchive: &#39;所有文章&#39; friends: &#39;友链&#39; aboutme: &#39;关于我&#39; friends: 友情链接: # aboutme: # 注：可以根据这个自己修改，记得保存 6 部署6.1 安装Git插件 1 为Hexo安装Git插件 npm install hexo-deployer-git --save 2 修改根目录下的 _config.yml 配置文件。 deploy: type: git repository: https://github.com/yanxin152133/yanxin152133.github.io.git branch: master 6.2 部署 1 打开Git，输入： hexo d 2 成功的标志","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/categories/Hexo/"},{"name":"搭建","slug":"Hexo/搭建","permalink":"http://yoursite.com/categories/Hexo/搭建/"}],"tags":[{"name":"GitHub Hexo 个人博客","slug":"GitHub-Hexo-个人博客","permalink":"http://yoursite.com/tags/GitHub-Hexo-个人博客/"}]},{"title":"Android studio安装","slug":"Android studio安装","date":"2018-11-06T16:00:00.000Z","updated":"2019-10-11T00:06:44.256Z","comments":true,"path":"2018/11/07/Android studio安装/","link":"","permalink":"http://yoursite.com/2018/11/07/Android studio安装/","excerpt":"准备 1.配置环境变量 2.安装 3.创建HelloWorld","text":"准备 1.配置环境变量 2.安装 3.创建HelloWorld 配置环境变量 为什么首先要配置环境变量呢？配置环境变量可以防止之后Android studio安装SDK时安装到默认位置，减少C盘的占用空间。 新建 变量名 ANDROID_HOME ，值为 自己创建的放置SDK的路径 安装 首先下载 Android studio &gt;下载完成直接打开。 如果不想安装到C盘也可以选择其他的。 等待一段时间。 点击 cancle 选择喜欢的主题 之后就是漫长的等待… 等待总会有结果的。 创建第一个 Android 程序 HelloWorld 点击上图中的 Start a new Android Studio project Application name 填写 HelloWorldCompany domain 按照系统默认的就行Project location 存放自己代码的位置，可自定义。 系统默认即可 一般选择 Empty Activity 点击 Finish。 等待红线部分加载完毕。加载完成后点击工具栏-Bulid—Bulid Bundle(s)/APK(s)-Bulid APK(s)。之后可以选择自己手机运行自己的程序。也可以选择下图中的自行安装模拟器运行。 之后再补充…","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"Android studio安装","slug":"Android/Android-studio安装","permalink":"http://yoursite.com/categories/Android/Android-studio安装/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Android studio安装","slug":"Android-studio安装","permalink":"http://yoursite.com/tags/Android-studio安装/"}]},{"title":"Hexo yilia 添加Valine","slug":"Hexo yilia 添加Valine","date":"2018-10-20T16:00:00.000Z","updated":"2019-10-11T00:10:15.933Z","comments":true,"path":"2018/10/21/Hexo yilia 添加Valine/","link":"","permalink":"http://yoursite.com/2018/10/21/Hexo yilia 添加Valine/","excerpt":"步骤 1.Valine 介绍 2.注册LeanCloud 3.配置 4.参考文档","text":"步骤 1.Valine 介绍 2.注册LeanCloud 3.配置 4.参考文档 Valine 介绍 Valine- 一款快速、简洁且高效的无后端评论系统。 Valine 诞生于2017年8月7日，是一款基于Leancloud的快速、简洁且高效的无后端评论系统。理论上支持但不限于静态博客，目前已有Hexo、Jekyll、Typecho、Hugo 等博客程序在使用Valine。 特性 快速安全Emoji 😉无后端实现MarkDown 全语法支持轻量易用(~15kb gzipped)文章阅读量统计 v1.2.0+ 注册 LeanCloud 注册 LeanCloud 注册完成后创建一个应用。然后打开设置-应用Key。如下图： 复制图中的 App ID App key Master Key 作为备用 配置 _config.yml #6、Valine https://valine.js.org valine: appid: #Leancloud应用的appId appkey: #Leancloud应用的appKey verify: false #验证码 notify: false #评论回复提醒 avatar: mm #评论列表头像样式：&#39;&#39;/mm/identicon/monsterid/wavatar/retro/hide placeholder: Just go go #评论框占位符 layout/_partial/article.ejs &lt;% if (theme.valine &amp;&amp; theme.valine.appid &amp;&amp; theme.valine.appkey){ %&gt; &lt;section id=&quot;comments&quot; style=&quot;margin:10px;padding:10px;background:#fff;&quot;&gt; &lt;%- partial(&#39;post/valine&#39;, { key: post.slug, title: post.title, url: config.url+url_for(post.path) }) %&gt; &lt;/section&gt; &lt;% } %&gt; &lt;% } %&gt; layout/_partial/post/valine.ejs &lt;div id=&quot;vcomment&quot; class=&quot;comment&quot;&gt;&lt;/div&gt; &lt;script src=&quot;//cdn1.lncld.net/static/js/3.0.4/av-min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;//unpkg.com/valine/dist/Valine.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var notify = &#39;&lt;%= theme.valine.notify %&gt;&#39; == true ? true : false; var verify = &#39;&lt;%= theme.valine.verify %&gt;&#39; == true ? true : false; window.onload = function() { new Valine({ el: &#39;.comment&#39;, notify: notify, verify: verify, app_id: &quot;&lt;%= theme.valine.appid %&gt;&quot;, app_key: &quot;&lt;%= theme.valine.appkey %&gt;&quot;, placeholder: &quot;&lt;%= theme.valine.placeholder %&gt;&quot;, avatar:&quot;&lt;%= theme.valine.avatar %&gt;&quot; }); } &lt;/script&gt; 参考文档 1 为你的Hexo加上评论系统-Valine2 新增对Valine评论系统的支持","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/categories/Hexo/"},{"name":"Valine评论","slug":"Hexo/Valine评论","permalink":"http://yoursite.com/categories/Hexo/Valine评论/"}],"tags":[{"name":"Hexo yilia Valine","slug":"Hexo-yilia-Valine","permalink":"http://yoursite.com/tags/Hexo-yilia-Valine/"}]},{"title":"Ubuntu18.04 安装 Docker","slug":"Ubuntu18.04 安装 Docker","date":"2018-08-11T16:00:00.000Z","updated":"2019-10-11T00:14:38.369Z","comments":true,"path":"2018/08/12/Ubuntu18.04 安装 Docker/","link":"","permalink":"http://yoursite.com/2018/08/12/Ubuntu18.04 安装 Docker/","excerpt":"准备工作系统要求Docker CE 支持以下版本的 Ubuntu 操作系统： Artful 17.10(Docker CE 17.11 Edge) Zesty 17.04 Xenial 16.04(LTS) Trusty 14.04(LTS) 推荐使用 LTS 版本的，在Ubuntu发行版中，LTS是长期支持版本，会更稳定。","text":"准备工作系统要求Docker CE 支持以下版本的 Ubuntu 操作系统： Artful 17.10(Docker CE 17.11 Edge) Zesty 17.04 Xenial 16.04(LTS) Trusty 14.04(LTS) 推荐使用 LTS 版本的，在Ubuntu发行版中，LTS是长期支持版本，会更稳定。 卸载旧版本旧版本的 Docker 称为 docker 或者 docker-engine，使用以下命令卸载旧版本： sudo apt-get remove docker \\ docker-engine \\ docker.io 安装与验证从 Ubuntu 14.04 开始，一部分内核模块移到了可选内核模块包 (linux-image-extra-*) ，以减少内核软件包的体积。正常安装的系统应该会包含可选内核模块包，而一些裁剪后的系统可能会将其精简掉。AUFS 内核驱动属于可选内核模块的一部分，作为推荐的 Docker 存储层驱动，一般建议安装可选内核模块包以使用 AUFS。 如果系统没有安装可选内核模块的话，可以执行下面的命令来安装可选内核模块包：(操作均为普通用户下) sudo apt-get update sudo apt-get install \\ linux-image-extra-$(uname -r) \\ linux-image-extra-virtual Ubuntu 16.04 + 上的 Docker CE 默认使用 overlay2 存储层驱动,无需手动配置。 使用APT安装由于 apt 源使用 HTTPS 以确保软件下载过程中不被篡改。因此，我们首先需要添加使用 HTTPS 传输的软件包以及 CA 证书。 sudo apt-get update sudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ software-properties-common 鉴于国内网络问题，强烈建议使用国内源，官方源请在注释中查看。为了确认所下载软件包的合法性，需要添加软件源的 GPG 密钥。 (任选其一即可) curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add - 官方源 curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - 然后，我们需要向 source.list 中添加 Docker 软件源 sudo add-apt-repository \\ &quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu \\ $(lsb_release -cs) \\ stable&quot; # 官方源 # $ sudo add-apt-repository \\ # &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \\ # $(lsb_release -cs) \\ # stable&quot; 安装 Docker CEsudo apt update sudo apt install docker-ce 建立 docker 用户组建立docker组: sudo groupadd docker 将当前用户加入docker组： sudo usermod -aG docker $USER 更换国内Docker仓库创建文件： sudo vim /etc/docker/daemon.json 加入以下内容： { &quot;registry-mirrors&quot;: [ &quot;https://docker.mirrors.ustc.edu.cn&quot; ] } 然后重启系统。 验证输入以下命令： docker run hello-world 若输出以下内容则为成功。 Unable to find image &#39;hello-world:latest&#39; locally latest: Pulling from library/hello-world ca4f61b1923c: Pull complete Digest: sha256:be0cd392e45be79ffeffa6b05338b98ebb16c87b255f48e297ec7f98e123905c Status: Downloaded newer image for hello-world:latest Hello from Docker! This message shows that your installation appears to be working correctly. To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal. To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bash Share images, automate workflows, and more with a free Docker ID: https://cloud.docker.com/ For more examples and ideas, visit: https://docs.docker.com/engine/userguide/ 参考Ubuntu 下安装 DockerDocker —— 从入门到实践","categories":[{"name":"Docker","slug":"Docker","permalink":"http://yoursite.com/categories/Docker/"},{"name":"安装","slug":"Docker/安装","permalink":"http://yoursite.com/categories/Docker/安装/"}],"tags":[{"name":"Docker安装","slug":"Docker安装","permalink":"http://yoursite.com/tags/Docker安装/"}]},{"title":"bugzilla","slug":"buzilla","date":"2018-05-21T16:00:00.000Z","updated":"2019-10-11T00:07:16.152Z","comments":true,"path":"2018/05/22/buzilla/","link":"","permalink":"http://yoursite.com/2018/05/22/buzilla/","excerpt":"bugzilla准备 系统：Windows 7 MySql 5.5.62及以上 Bugzilla 4.2及以上 ActivePerl 5.24.3.2404及以上 XAMPP 7.1.29及以上","text":"bugzilla准备 系统：Windows 7 MySql 5.5.62及以上 Bugzilla 4.2及以上 ActivePerl 5.24.3.2404及以上 XAMPP 7.1.29及以上 下载MySql 5.5.62下载地址：MySql 5.5.62 Bugzilla 4.2下载地址：Bugzilla 4.2 ActivePerl 5.24.3.2404下载地址：ActivePerl 5.24.3.2404 XAMPP 7.1.29下载地址：XAMPP 7.1.29 安装XAMPP 7.1.29参考：https://www.jianshu.com/p/07455416d68c ActivePerl 5.24.3.2404双击activeperl安装界面，一直点击next直至完成安装，activeperl的选项都是默认的选项，依照默认安装即可。 验证perl是否安装成功cmd界面运行perl -v，出现版本号即为成功。如下图： MySql 5.5.62步骤大致如下图： 路径设置为C:\\MySql,因为Bugzilla默认的引导路径为这个。 Bugzilla 4.2 解压Bugzilla 4.2文件，将解压后的内容复制到C:\\xampp\\htdocs\\bugzilla文件夹下，若没有则先建一个文件夹。 win+R 打开cmd窗口，同时进入到C:\\xampp\\htdocs\\bugzilla目录下。 输入checksetup.pl命令。如下图： 安装perl模块，使用perl install XXX进行安装未安装的perl模块。如下图所示： 可能会有一些模块无法安装，可以直接忽略。再次运行checksetup.pl命令，可能会需要安装DDB-MySql这个模块，安装之后再次运行checksetup.pl命令，出现下图则未成功。 编辑C:\\xampp\\htdocs\\bugzilla下的localconfig文件。 打开localconfig文件，将其中的$db_port = 0;改为$db_port = 3306; $index_html = 0;改为$index_html = 1。 打开MySQL 5.5 Command Line Client。下面在MySQL服务器中创建一个bugs数据库，和一个bugs用户，以及为该用户授予相应的权限，命令如下：create database bugs; 创建一个数据库bugscreate user bugs@localhost; 创建一个用户bugsgrant all on bugs.* to bugs@’localhost’; 为用户bugs授权flush privileges; 刷新用户权限 在命令行下再次运行checksetup.pl将会生成和数据库有关的数据表。但是可能会出现报错，显示的是无法找到什么什么的表，这时候只需要把上一步创建的数据库bugs删除再重新创建即可，若无法解决自行查找资料。生成数据表后会要求填入主机的地址服务器地址，管理员名字和账号（该账号是一个email地址）以及管理员登陆的密码。（自由发挥） 将C:\\xampp\\htdocs\\bugzilla下的后缀名为.cgi的文件中的 #!/usr/bin/perl 改为#!”C:\\Perl64\\bin\\perl.exe”。 运行打开XAMPP界面的Apache,在浏览器中输入http://localhost/bugzilla。","categories":[{"name":"软件缺陷","slug":"软件缺陷","permalink":"http://yoursite.com/categories/软件缺陷/"},{"name":"bugzilla","slug":"软件缺陷/bugzilla","permalink":"http://yoursite.com/categories/软件缺陷/bugzilla/"}],"tags":[{"name":"软件缺陷","slug":"软件缺陷","permalink":"http://yoursite.com/tags/软件缺陷/"},{"name":"bugzilla","slug":"bugzilla","permalink":"http://yoursite.com/tags/bugzilla/"}]}]}