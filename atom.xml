<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yan&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-08-15T08:32:25.803Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker搭建PHP、apache环境</title>
    <link href="http://yoursite.com/2019/08/12/Docker%E6%90%AD%E5%BB%BAPHP%E3%80%81apache%E7%8E%AF%E5%A2%83/"/>
    <id>http://yoursite.com/2019/08/12/Docker搭建PHP、apache环境/</id>
    <published>2019-08-12T04:57:11.090Z</published>
    <updated>2019-08-15T08:32:25.803Z</updated>
    
    <content type="html"><![CDATA[<h1 id="拉取Ubuntu镜像"><a href="#拉取Ubuntu镜像" class="headerlink" title="拉取Ubuntu镜像"></a>拉取Ubuntu镜像</h1><p>输入命令：   </p><pre><code class="bash">$ docker pull ubuntu</code></pre><a id="more"></a><h1 id="运行Ubuntu容器"><a href="#运行Ubuntu容器" class="headerlink" title="运行Ubuntu容器"></a>运行Ubuntu容器</h1><ol><li>确认是否已下载好镜像，输入命令：</li></ol><pre><code class="bash">$ docker images</code></pre><ol start="2"><li>上述命令之后如果出现以下情况，即为下载好了。</li></ol><pre><code class="bash">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZEubuntu              latest              3556258649b2        2 weeks ago         64.2MB</code></pre><ol start="3"><li>运行，输入命令：     </li></ol><pre><code class="bash">$ docker run -it -d --name ubuntu -p 80:80 ubuntu</code></pre><p>–name自定义容器名，-p指定端口映射，前者为虚拟机端口，后者为容器端口,成功后返回id<br>查看所有启动的容器。</p><ol start="4"><li>查看所有容器。</li></ol><pre><code class="bash">$ docker ps -a</code></pre><ol start="5"><li>如果是以下情况，则为运行成功。</li></ol><pre><code class="bash">CONTAINER ID        IMAGE               COMMAND             CREATED              STATUS              PORTS                  NAMESd5d8952f48b2        ubuntu              &quot;/bin/bash&quot;         About a minute ago   Up About a minute   0.0.0.0:8088-&gt;80/tcp   ubuntu</code></pre><h1 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h1><p>输入以下命令：    </p><pre><code class="bash">$ docker exec -it ubuntu /bin/bash</code></pre><h1 id="安装Apache2和PHP7-2"><a href="#安装Apache2和PHP7-2" class="headerlink" title="安装Apache2和PHP7.2"></a>安装Apache2和PHP7.2</h1><h2 id="配置软件源"><a href="#配置软件源" class="headerlink" title="配置软件源"></a>配置软件源</h2><p>输入以下命令：</p><pre><code class="bash"># sed -i &#39;s/archive.ubuntu.com/mirrors.ustc.edu.cn/g&#39; /etc/apt/sources.list# apt update</code></pre><h2 id="检查PHP和Apache模块"><a href="#检查PHP和Apache模块" class="headerlink" title="检查PHP和Apache模块"></a>检查PHP和Apache模块</h2><p>输入以下命令：     </p><pre><code class="bash"># apt list | grep libapache2-mod-php*</code></pre><p>结果为以下情况即为可以安装Apache2和PHP7.2</p><pre><code class="bash">WARNING: apt does not have a stable CLI interface. Use with caution in scripts.libapache2-mod-php/bionic,bionic 1:7.2+60ubuntu1 alllibapache2-mod-php7.2/bionic-updates,bionic-security 7.2.19-0ubuntu0.18.04.1 amd64</code></pre><h2 id="安装Apache2和PHP7-2-1"><a href="#安装Apache2和PHP7-2-1" class="headerlink" title="安装Apache2和PHP7.2"></a>安装Apache2和PHP7.2</h2><ul><li>安装</li></ul><pre><code class="bash"># apt install php7.2 libapache2-mod-php7.2</code></pre><ul><li>在安装过程需要设置php的时区，输入相对应的号码即可。</li><li>验证是否安装成功。</li></ul><pre><code class="bash">root@dd29dc7f7771:/# php -vPHP 7.2.19-0ubuntu0.18.04.1 (cli) (built: Jun  4 2019 14:48:12) ( NTS )Copyright (c) 1997-2018 The PHP GroupZend Engine v3.2.0, Copyright (c) 1998-2018 Zend Technologies    with Zend OPcache v7.2.19-0ubuntu0.18.04.1, Copyright (c) 1999-2018, by Zend Technologiesroot@dd29dc7f7771:/# apache2 -vServer version: Apache/2.4.29 (Ubuntu)Server built:   2019-07-16T18:14:45</code></pre><ul><li>配置 ServerName</li></ul><pre><code class="bash"># vi /etc/apache2/apache2.conf## 添加一行ServerName localhost</code></pre><ul><li>启动</li></ul><pre><code class="bash"># service apache2 start</code></pre><h2 id="查看PHP环境信息以及相关模块"><a href="#查看PHP环境信息以及相关模块" class="headerlink" title="查看PHP环境信息以及相关模块"></a>查看PHP环境信息以及相关模块</h2><p>在 <strong>/var/www/html</strong> 目录下新建文件phpinfo.php并添加如下代码：</p><pre><code class="php">&lt;?php    phpinfo();?&gt;</code></pre><p>通过浏览器输入<strong>IP/phpinfo.php</strong>访问。</p><p><a href="http://139.159.236.98/php/chap01/sec01/phpinfo.php" target="_blank" rel="noopener">Demo</a></p><h2 id="安装php-mysqli模块"><a href="#安装php-mysqli模块" class="headerlink" title="安装php-mysqli模块"></a>安装php-mysqli模块</h2><ul><li>安装</li></ul><pre><code class="bash"># apt install php-mysqli</code></pre><ul><li>使用命令打开<strong>vi /etc/php/7.2/apache2/php.ini</strong>去掉<strong>extension=mysqli.dll</strong>前面的<code>；</code>号，保存退出。</li><li>重新启动apache</li></ul><pre><code class="bash"># service apache2 restart</code></pre><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><h2 id="phpmyadmin"><a href="#phpmyadmin" class="headerlink" title="phpmyadmin"></a>phpmyadmin</h2><p>命令如下：     </p><pre><code class="bash"># apt install wget    ## 如果已有可忽略# cd /avr/www/html# wget https://files.phpmyadmin.net/phpMyAdmin/4.9.0.1/phpMyAdmin-4.9.0.1-all-languages.zip     ## 下载phpmyadmin# apt install zip    ## 如果已有可忽略# unzip phpMyAdmin-4.9.0.1-all-languages.zip     ##解压# mv phpMyAdmin-4.9.0.1-all-languages phpmyadmin     ##重命名## 配置phpmyadmin连接远程数据库# vim /phpMyAdmin/libraries/config.default.php## 将  $cfg[&#39;Servers&#39;][$i][&#39;host&#39;] = ‘localhost’ 中的loaclhost改为自己的远程数据库IP</code></pre><p>在浏览器输入IP/phpmyadmin即可查看。<br><a href="http://139.159.236.98/phpmyadmin/" target="_blank" rel="noopener">Demo</a></p><h1 id="使用模板"><a href="#使用模板" class="headerlink" title="使用模板"></a>使用模板</h1><pre><code>## 首先需要创建一个目录作为映射目录# mkdir www## 拉取镜像# docker pull yancccccc/php-apache## 运行# docker run -it -d --name php-apache -p 80:80 -v $PWD/www:/var/www/html yancccccc/php-apache## 启动apache# docker exec -it php-apache /bin/bash# service apache2 start# exit## 安装phpmyadmin则将目录改为刚才创建的映射目录即可，其它步骤不需要改变。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;拉取Ubuntu镜像&quot;&gt;&lt;a href=&quot;#拉取Ubuntu镜像&quot; class=&quot;headerlink&quot; title=&quot;拉取Ubuntu镜像&quot;&gt;&lt;/a&gt;拉取Ubuntu镜像&lt;/h1&gt;&lt;p&gt;输入命令：   &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ docker pull ubuntu
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
      <category term="PHP、apache" scheme="http://yoursite.com/categories/Docker/PHP%E3%80%81apache/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
      <category term="PHP、apache" scheme="http://yoursite.com/tags/PHP%E3%80%81apache/"/>
    
  </entry>
  
  <entry>
    <title>PHP入门</title>
    <link href="http://yoursite.com/2019/08/01/PHP%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2019/08/01/PHP入门/</id>
    <published>2019-08-01T12:41:00.188Z</published>
    <updated>2019-08-15T09:15:20.163Z</updated>
    
    <content type="html"><![CDATA[<h1 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h1><p>仓库地址：<a href="https://github.com/yanxin152133/PHP.git" target="_blank" rel="noopener">GitHub</a></p><p><strong>环境</strong>：      </p><ul><li>Apache/2.4.39 (Win64)</li><li>PHP 7.3.6</li><li>PhpStorm 2019.2</li><li>MySQL 5.6</li></ul><p><strong>软件安装路径</strong></p><ul><li>Apache <strong>D:\server\apache</strong></li><li>PHP <strong>D:\server\php7</strong></li></ul><h1 id="演示地址"><a href="#演示地址" class="headerlink" title="演示地址"></a>演示地址</h1><p><a href="http://139.159.236.98/php/" target="_blank" rel="noopener">Demo</a></p><h1 id="PHP手册"><a href="#PHP手册" class="headerlink" title="PHP手册"></a>PHP手册</h1><p>文件名为<strong>php_manual_zh.chm</strong>即为PHP手册。</p><p>打不开参考下面链接：    </p><ul><li><a href="https://blog.csdn.net/qq_14998713/article/details/52155834" target="_blank" rel="noopener">解决win10中无法打开CHM文件的方法</a></li></ul><h1 id="搭建环境（Windows）"><a href="#搭建环境（Windows）" class="headerlink" title="搭建环境（Windows）"></a>搭建环境（Windows）</h1><h2 id="较早版本Apache-下载"><a href="#较早版本Apache-下载" class="headerlink" title="较早版本Apache 下载"></a>较早版本Apache 下载</h2><p>下载地址：<a href="https://archive.apache.org/dist/httpd/binaries/win32/" target="_blank" rel="noopener">Apache msi</a><br><a id="more"></a><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://live.staticflickr.com/65535/47942980403_d6cb5a4b44_b.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure></p><h2 id="较早版本Apache-安装"><a href="#较早版本Apache-安装" class="headerlink" title="较早版本Apache 安装"></a>较早版本Apache 安装</h2><ol><li>双击下载的文件。</li><li>相关配置。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://live.staticflickr.com/65535/47943015906_fd90108b4a_z.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure></li><li>选择自定义安装模式<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://live.staticflickr.com/65535/47942997977_460a18ec9d_z.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure></li></ol><h3 id="Apache-目录结构说明"><a href="#Apache-目录结构说明" class="headerlink" title="Apache 目录结构说明"></a>Apache 目录结构说明</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://live.staticflickr.com/65535/47942998182_e4d3bab27e_z.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="Apache-httpd-exe介绍"><a href="#Apache-httpd-exe介绍" class="headerlink" title="Apache-httpd.exe介绍"></a>Apache-httpd.exe介绍</h3><p>Httpd.exe的详细应用      </p><ol><li><p>服务器进程：运行之后才能够使用。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://live.staticflickr.com/65535/47978909873_f73c0d5d20_z.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure></li><li><p>用来查看Apache具有哪些功能以及配置文件是否有错：httpd或者httpd.exe（文件所在目录）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://live.staticflickr.com/65535/47978911057_67194e20c5_z.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure></li><li><p>查看使用的模块：httpd -M</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://live.staticflickr.com/65535/47979212733_7e7d0c55bc_b.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure></li><li><p>验证配置文件是否有效：httpd -t</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://live.staticflickr.com/65535/47979219121_af7c01dac5_b.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure></li></ol><h2 id="Apache-2-4-39-Win64-下载与安装"><a href="#Apache-2-4-39-Win64-下载与安装" class="headerlink" title="Apache/2.4.39 (Win64)下载与安装"></a>Apache/2.4.39 (Win64)下载与安装</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>下载地址： <a href="https://httpd.apache.org/download.cgi" target="_blank" rel="noopener">Apache/2.4.39 (Win64)</a></p><p><img src="https://live.staticflickr.com/65535/48443791046_79bba8ccdc_b.jpg" alt></p><p>点击之后以<strong>Apache Lounge</strong>为例进行下载</p><p><img src="https://live.staticflickr.com/65535/48443950892_a0944b542c_b.jpg" alt></p><p>之后根据自己安装的是哪个vc对应进行下载</p><h3 id="安装、运行、卸载"><a href="#安装、运行、卸载" class="headerlink" title="安装、运行、卸载"></a>安装、运行、卸载</h3><ol><li>对下载的文件进行解压，选择自己需要安装的地方。</li><li>打开conf\httpd.conf，将所有的<strong>c:/Apache24</strong> 替换为自己的安装目录。</li><li>以<strong>管理员身份</strong>运行<strong>CMD</strong>，进入<strong>\bin 目录</strong>（httpd.exe所在目录）。</li><li>输入 httpd.exe -k install -n “Apache24”  进行安装。</li><li>至此，安装基本完成。到安装目录下的bin目录中找到 ApacheMonitor.exe ,双击运行,启动apache服务。</li><li>如果要卸载这个服务 先要停止这个服务，然后输入httpd.exe -k uninstall –n “Apache24”进行卸载。</li></ol><h2 id="PHP-安装"><a href="#PHP-安装" class="headerlink" title="PHP 安装"></a>PHP 安装</h2><h3 id="下载-1"><a href="#下载-1" class="headerlink" title="下载"></a>下载</h3><p>下载地址：<a href="https://windows.php.net/download#php-7.3" target="_blank" rel="noopener">PHP 7.3 (7.3.7)</a>     </p><p><strong>关于php下载时VC各版本的区别和Non Thread Safe、Thread safe的简单辨析</strong></p><p>参考：<a href="https://blog.csdn.net/yeweiyang16/article/details/71108427" target="_blank" rel="noopener">php下载时VC各版本的区别和Non Thread Safe、Thread safe的简单辨析</a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol><li>解压缩</li><li>将压缩包放到E:/server/,同时重命名为PHP7</li></ol><h2 id="配置-Apache-加载-PHP-模块"><a href="#配置-Apache-加载-PHP-模块" class="headerlink" title="配置 Apache 加载 PHP 模块"></a>配置 Apache 加载 PHP 模块</h2><p><strong>需改内容之后都需要重启apache</strong></p><ol><li>Apache 加载 PHP 模块：在Apache的主配置文件中加载对应的PHP提供的模块</li></ol><p>在apache安装目录的<strong>conf目录</strong>下对<strong>httpd.conf</strong>进行添加一下内容：     </p><pre><code>#加载PHPLoadModule php7_module &#39;D:/server/php7/php7apache2_4.dll&#39;</code></pre><ol start="2"><li>验证</li></ol><p><strong>需改内容之后都需要重启apache</strong></p><pre><code class="shell">Microsoft Windows [版本 10.0.17763.615](c) 2018 Microsoft Corporation。保留所有权利。C:\Users\Yan&gt;D:D:\&gt;cd server\apache\binD:\server\apache\bin&gt;httpd.exe -tAH00558: httpd.exe: Could not reliably determine the server&#39;s fully qualified domain name, using fe80::3993:9c4f:39af:664d. Set the &#39;ServerName&#39; directive globally to suppress this messageSyntax OKD:\server\apache\bin&gt;httpd.exe -MAH00558: httpd.exe: Could not reliably determine the server&#39;s fully qualified domain name, using fe80::3993:9c4f:39af:664d. Set the &#39;ServerName&#39; directive globally to suppress this messageLoaded Modules: core_module (static) win32_module (static) mpm_winnt_module (static) http_module (static) so_module (static) actions_module (shared) alias_module (shared) allowmethods_module (shared) asis_module (shared) auth_basic_module (shared) authn_core_module (shared) authn_file_module (shared) authz_core_module (shared) authz_groupfile_module (shared) authz_host_module (shared) authz_user_module (shared) autoindex_module (shared) cgi_module (shared) dir_module (shared) env_module (shared) include_module (shared) isapi_module (shared) log_config_module (shared) mime_module (shared) negotiation_module (shared) setenvif_module (shared) php7_module (shared)   ##需要出现这个即可</code></pre><ol start="3"><li><p>Apache 分配工作给PHP模块：如果是PHP代码就交给PHP处理（通过文件后缀名.php进行识别）</p></li><li><p>在apache安装目录的<strong>conf目录</strong>下对<strong>httpd.conf</strong>进行添加一下内容：     </p></li></ol><pre><code># 分配给PHPAddType application/x-httpd-php .php</code></pre><p><strong>需改内容之后都需要重启apache</strong></p><ol start="5"><li>将PHP的配置文件加载到Apache配置文件中，使之共同生效。</li></ol><ul><li>在Apache中指定PHP配置文件所在路径</li></ul><p><strong>httpd.conf</strong>中添加：   </p><pre><code>#加载PHP配置文件PHPIniDir &#39;D:/server/php7&#39;</code></pre><ul><li><p>php.ini 文件是默认不存在的，是以development和production格式存在，需要格式化。</p></li><li><p>将php安装目录中的<strong>php.ini-development</strong>文件复制一个副本并重名为<strong>php.ini</strong>,然后重启Apache。</p></li></ul><p>说明：PHP的配置文件已经加入到Apache的配置项中，意味着php.ini的修改需要Apache重启才会生效。</p><h2 id="httpd-conf"><a href="#httpd-conf" class="headerlink" title="httpd.conf"></a>httpd.conf</h2><pre><code>#加载PHPLoadModule php7_module &#39;D:/server/php7/php7apache2_4.dll&#39;#加载PHP配置文件PHPIniDir &#39;D:/server/php7&#39;# 分配给PHPAddType application/x-httpd-php .php</code></pre><h2 id="配置PhpStorm"><a href="#配置PhpStorm" class="headerlink" title="配置PhpStorm"></a>配置PhpStorm</h2><p>首先使用PhpStorm打开自己的项目，然后<strong>File | Settings | Build, Execution, Deployment | Deployment</strong>。</p><p>配置如下图：    </p><p><img src="https://live.staticflickr.com/65535/48510854551_028b46b36c_h.jpg" alt></p><p><img src="https://live.staticflickr.com/65535/48510854501_13337df58c_h.jpg" alt></p><p><img src="https://live.staticflickr.com/65535/48511036182_0b8832317c_b.jpg" alt></p><p><strong>Folder</strong>为apache的资源文件部署位置。</p><p><img src="https://live.staticflickr.com/65535/48511036087_789e0cb919_b.jpg" alt></p><p><strong>Local path</strong>为自己项目的位置，<strong>Deployment path</strong>为部署到apache中的映射文件名称，<strong>Web path</strong>为自己运行项目后需要输入到浏览器的路径名。多练习练习总会找到自己无法解决的关键。</p><p><img src="https://live.staticflickr.com/65535/48510856301_8bbe50b2a2_b.jpg" alt></p><p>这一步是将自己的代码同步到apache的htdocs文件夹下，<strong>只需点击一次即可之后会自动同步。</strong></p><h3 id="同步自己的代码到远程服务器"><a href="#同步自己的代码到远程服务器" class="headerlink" title="同步自己的代码到远程服务器"></a>同步自己的代码到远程服务器</h3><ul><li>搭建自己的远程服务器环境</li></ul><p>参考以下文章：    </p><ul><li><p><a href="https://yanxin152133.github.io/2019/08/12/Docker%E6%90%AD%E5%BB%BAPHP%E3%80%81apache%E7%8E%AF%E5%A2%83/" target="_blank" rel="noopener">docker搭建php、apache</a></p></li><li><p>配置phpstorm</p><ul><li>首先使用PhpStorm打开自己的项目，然后<strong>File | Settings | Build, Execution, Deployment | Deployment</strong>。</li><li>点击<code>+</code></li><li>其他步骤如下图所示</li></ul></li></ul><p><img src="https://live.staticflickr.com/65535/48525752431_76f90221a3_b.jpg" alt></p><p><img src="https://live.staticflickr.com/65535/48525912012_7ddf7da41f_b.jpg" alt></p><p><img src="https://live.staticflickr.com/65535/48525911917_c42d4a5eb7_b.jpg" alt></p><p><img src="https://live.staticflickr.com/65535/48525752271_e63a5138d9_b.jpg" alt></p><p><img src="https://live.staticflickr.com/65535/48525752171_6a6167224a_b.jpg" alt></p><p><img src="https://live.staticflickr.com/65535/48525752106_fb77e430f5_b.jpg" alt></p><p>这个时候上传的选项就要选择远程服务器那个选项，而不是图中的本地的选项。<strong>上图只是展示与本地不一样的地方</strong></p><h2 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h2><p>为了方便安装，使用docker来搭建MySQL环境。没有条件的可以百度自行安装MySQL。</p><h3 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h3><p>参考：     </p><ul><li><a href="https://yanxin152133.github.io/2019/05/26/Ubuntu18.04%20%E5%AE%89%E8%A3%85%20Docker/" target="_blank" rel="noopener">Ubuntu18.04 安装 Docker</a></li></ul><h3 id="安装MySQL-1"><a href="#安装MySQL-1" class="headerlink" title="安装MySQL"></a>安装MySQL</h3><p>输入以下命令：    </p><pre><code class="bash">## 拉取官方的镜像,标签为5.6docker pull mysql:5.6## 运行docker run --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.6 --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci## -p 3306:3306：将容器的 3306 端口映射到主机的 3306 端口。## e MYSQL_ROOT_PASSWORD=123456：初始化 root 用户的密码。## --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci：解决中文问题## 进入MySQLdocker exec -it mysql bash## 登录MySQLmysql -u root -p## 然后输入密码</code></pre><h3 id="MySQL的目录结构说明（Windows）"><a href="#MySQL的目录结构说明（Windows）" class="headerlink" title="MySQL的目录结构说明（Windows）"></a>MySQL的目录结构说明（Windows）</h3><p><img src="https://live.staticflickr.com/65535/48444297712_23161d2721_b.jpg" alt></p><p><strong>bin目录</strong></p><p><img src="https://live.staticflickr.com/65535/48444166761_0c2857d850_b.jpg" alt></p><blockquote><p>软件设计结构：C/S和B/S<br>C/S:Client客户端/Server服务端，用户需要安装客户端产品才能访问服务器，而且只能访问一种软件（当前自己）<br>B/S:Browser浏览器和/Server服务端，用户只需要安装浏览器，就可以访问所有的服务器（B/S架构服务）</p></blockquote><h3 id="MySQL的访问流程"><a href="#MySQL的访问流程" class="headerlink" title="MySQL的访问流程"></a>MySQL的访问流程</h3><blockquote><p>MySQL是一款C/S架构的软件，需要通过客户端来访问服务（MySQL其实也提供了其他模式的访问：通过一些插件扩展来充当客户端）</p></blockquote><ol><li>启用MySQL客户端：mysql.exe,该软件本身可以通过CMD控制台运行。</li><li><p>MySQL客户端访问服务端需要进行寻找匹配：连接认证<br>连接：ip和端口确认，如果是本地都可以省略。</p><p> -h 主机地址—-》 -hlocalhost(可以是IP)<br> -P 端口—》-P3306<br> 认证：通过用户名和密码进入服务器<br> -u 用户名—》-uroot,不可以省略（匿名用户除外）<br> -p 密码—》-proot</p></li><li><p>退出命令：\q</p></li></ol><p><strong>注意：通常连接认证的时候密码不建议明文，可以在输入-p之后回车，系统会再次让输入密码，这个时候就是密文</strong></p><h2 id="PHP连接MySQL数据库"><a href="#PHP连接MySQL数据库" class="headerlink" title="PHP连接MySQL数据库"></a>PHP连接MySQL数据库</h2><p><strong>PHP7正式移除了mysql 扩展，推荐使用mysqli或者pdo_mysql</strong></p><h3 id="php7配置mysqli或者pdo-mysql和使用mysqli或者pdo-mysql连接MySQL"><a href="#php7配置mysqli或者pdo-mysql和使用mysqli或者pdo-mysql连接MySQL" class="headerlink" title="php7配置mysqli或者pdo_mysql和使用mysqli或者pdo_mysql连接MySQL"></a>php7配置mysqli或者pdo_mysql和使用mysqli或者pdo_mysql连接MySQL</h3><h4 id="我是该用-MySQLi-，还是-PDO"><a href="#我是该用-MySQLi-，还是-PDO" class="headerlink" title="我是该用 MySQLi ，还是 PDO?"></a>我是该用 MySQLi ，还是 PDO?</h4><blockquote><p>如果你需要一个简短的回答，即 “你习惯哪个就用哪个”。<br>MySQLi 和 PDO 有它们自己的优势：<br>PDO 应用在 12 种不同数据库中， MySQLi 只针对 MySQL 数据库。<br>所以，如果你的项目需要在多种数据库中切换，建议使用 PDO ，这样你只需要修改连接字符串和部分查询语句即可。 使用 MySQLi, 如果不同数据库，你需要重新编写所有代码，包括查询。<br>两者都是面向对象, 但 MySQLi 还提供了 API 接口。<br>两者都支持预处理语句。 预处理语句可以防止 SQL 注入，对于 web 项目的安全性是非常重要的。</p></blockquote><ul><li>首先配置<strong>php.ini</strong>文件</li><li>编辑<strong>php.ini</strong><ul><li>将 <strong>;extension=mysqli</strong> 改为<strong>extension=mysqli</strong>。有的版本中会是 <strong>;extension=php_mysqli.dll</strong>，原理都是将前面的 <strong>;</strong> 去掉</li><li>将 <strong>;extension=pdo_mysql</strong> 改为<strong>extension=pdo_mysql</strong>。有的版本中会是 <strong>;extension=php_pdo.dll</strong>，原理都是将前面的 <strong>;</strong> 去掉</li></ul></li><li>再次编辑<strong>php.ini</strong><ul><li>将 <strong>extension_dir = “ext”</strong>改为 <strong>extension_dir = “D:/server/php7/ext”</strong>，<strong>D:/server/php7/ext</strong>为自己<strong>安装php</strong>的<strong>绝对路径</strong></li></ul></li><li><strong>重启apache服务</strong></li><li>编辑<strong>index.php</strong></li></ul><pre><code class="php">&lt;?php    phpinfo();?&gt;</code></pre><ul><li>浏览器输入：<a href="http://localhost:80/index.php" target="_blank" rel="noopener">http://localhost:80/index.php</a></li><li>验证</li></ul><p><img src="https://live.staticflickr.com/65535/48461097092_ed8fd6cd37_b.jpg" alt></p><p><img src="https://live.staticflickr.com/65535/48461096952_19ff034f6c_b.jpg" alt></p><ul><li>数据库连接（三种方式）</li><li>MySQLi - 面向对象</li></ul><pre><code class="php">&lt;?php$servername = &quot;localhost&quot;;$username = &quot;username&quot;;$password = &quot;password&quot;;// 创建连接$conn = new mysqli($servername, $username, $password);// 检测连接if ($conn-&gt;connect_error) {    die(&quot;连接失败: &quot; . $conn-&gt;connect_error);} echo &quot;连接成功&quot;;?&gt;</code></pre><ul><li>MySQLi - 面向过程</li></ul><pre><code class="php">&lt;?php$servername = &quot;localhost&quot;;$username = &quot;username&quot;;$password = &quot;password&quot;;// 创建连接$conn = mysqli_connect($servername, $username, $password);// 检测连接if (!$conn) {    die(&quot;Connection failed: &quot; . mysqli_connect_error());}echo &quot;连接成功&quot;;?&gt;</code></pre><ul><li>PDO</li></ul><pre><code class="php">&lt;?php$servername = &quot;localhost&quot;;$username = &quot;username&quot;;$password = &quot;password&quot;;try {    $conn = new PDO(&quot;mysql:host=$servername;&quot;, $username, $password);    echo &quot;连接成功&quot;; }catch(PDOException $e){    echo $e-&gt;getMessage();}?&gt;</code></pre><p>参考链接：     </p><ul><li><a href="https://www.runoob.com/php/php-mysql-connect.html" target="_blank" rel="noopener">PHP 连接 MySQL</a></li></ul><h2 id="设定PHP的系统时区"><a href="#设定PHP的系统时区" class="headerlink" title="设定PHP的系统时区"></a>设定PHP的系统时区</h2><ul><li>编辑<strong>php.ini</strong>     </li><li>修改为以下内容</li></ul><pre><code class="ini">date.timezone = PRC</code></pre><ul><li>重启Apache服务</li></ul><p><img src="https://live.staticflickr.com/65535/48461241292_16bb9f32e5_b.jpg" alt></p><h1 id="PHP标记与注释"><a href="#PHP标记与注释" class="headerlink" title="PHP标记与注释"></a>PHP标记与注释</h1><h2 id="PHP语法初步"><a href="#PHP语法初步" class="headerlink" title="PHP语法初步"></a>PHP语法初步</h2><p>PHP是一种运行在服务器端的脚本语言，可以嵌入到HTML中。</p><h2 id="PHP代码标记"><a href="#PHP代码标记" class="headerlink" title="PHP代码标记"></a>PHP代码标记</h2><p>在PHP历史发展中，可以使用多种标记来区分PHP脚本。</p><ul><li>ASP标记：&lt;% php 代码 %&gt;</li><li>短标记：&lt;? php代码 ?&gt;</li></ul><p>以上两种基本弃用，如果需要使用则需要在配置文件中开启。</p><ul><li>脚本标记：&lt; script language=”php”&gt;php代码&lt;/ script &gt;</li></ul><pre><code class="php">&lt;html&gt;&lt;body&gt;    &lt;b&gt;        &lt;script language=&quot;php&quot;&gt;            &lt;!--脚本标记--&gt;            echo &#39;hello world&#39;;        &lt;/script&gt;    &lt;/b&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>注：移除了 ASP 和 script PHP 标签</p><ul><li>标准标记（常用）：&lt;?php php代码?&gt;</li></ul><pre><code class="php">&lt;html&gt;&lt;body&gt;    &lt;b&gt;        &lt;?php            echo &#39;hello world&#39;;        ?&gt;    &lt;/b&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="PHP注释"><a href="#PHP注释" class="headerlink" title="PHP注释"></a>PHP注释</h2><blockquote><p>习惯：所有的代码在写的过程中都必须进行注释。</p></blockquote><p>PHP注释分为两种：行注释和块注释。</p><ul><li><p>行注释：一次注释一行<br>  <code>//</code>：后面跟的所有内容都是注释<br>  <code>#</code>：与<code>//</code>一样</p></li><li><p>块注释：一次注释多行<br>  <code>/**/</code>:<code>**</code>之间的全部都是注释。</p></li></ul><p>代码示例：    </p><pre><code class="php">&lt;?php   // 在脚本开始前：会对脚本功能进行简单阐述   //  注释的内容会在PHP解析的过程中忽略    // 块注释    /*     * @功能说明：注释说明     * @作者：XXX     * @版本：Version01     */    echo &#39;hello world&#39;;?&gt;</code></pre><h2 id="PHP语句分隔符"><a href="#PHP语句分隔符" class="headerlink" title="PHP语句分隔符"></a>PHP语句分隔符</h2><p>语句分隔符：在PHP中，代码是以行为单位，系统需要通过判断行的结束，该结束通常都是一个符号：分号”<code>;</code>“(<strong>英文状态下的分号</strong>)。</p><p>代码示例：     </p><pre><code class="php">&lt;?php/** * Create by PhpStorm * Date: 2019/8/6 * Time: 21:38 * Features: 语句分隔符 */    // 语句结束符    // 动手试一下前一个语句不加语句结束符的概况和后一个语句不加语句结束符的概况    // echo &#39;hello world&#39;    echo &#39;hello world&#39;;?&gt;</code></pre><p>特殊说明：     </p><ol><li>PHP标记结束符<code>?&gt;</code>有自带语句结束符的效果，最后一行PHP代码可以没有语句结束符”<code>;</code>“。</li><li>PHP中其实很多代码的书写并不是嵌入到HTML中，而是单独存在，通常书写习惯中就不建议使用标记结束符<code>?&gt;</code>，PHP会自动从开始到最后全部认为是PHP代码，从而解析。</li></ol><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><blockquote><p>PHP是一种动态网站开发的脚本语言,动态语言特点是交互性，会有数据的传递，而PHP作为”中间人“，需要进行数据的传递，传递的前提就是PHP能自己存储数据（临时存储）。</p></blockquote><h2 id="变量的基本概念"><a href="#变量的基本概念" class="headerlink" title="变量的基本概念"></a>变量的基本概念</h2><blockquote><p>变量来源于数学，是计算机语言中<strong>能储存计算结果</strong>或能表示值抽象概念。<strong>变量可以通过变量名访问</strong>。在指令式语言中，<strong>变量通常是可变的</strong>。</p></blockquote><ol><li>变量是用来存储数据的。</li><li>变量是存在名字的。</li><li>变量是通过名字来访问的：数据</li><li>变量是可以改变的：数据。</li></ol><h2 id="变量的使用"><a href="#变量的使用" class="headerlink" title="变量的使用"></a>变量的使用</h2><blockquote><p>PHP中的所有变量都必须使用”<code>$</code>“符号。</p></blockquote><ol><li>定义：在系统中增加对应的变量名字（内存中）</li><li>赋值：可以将数据赋值给变量名（可以在定义的同时完成）</li><li>可以通过变量名访问存储的数据</li><li>可以将变量从内存中删除</li></ol><p>代码示例：     </p><pre><code class="php">&lt;?php/* * Create by PhpStorm * Author: Yan * Date: 2019/8/6 * Time: 22:03 * Features: 定义变量 * */    // 变量    // 定义变量：在PHP中不需要任何关键字诋毁能够以变量（赋值）    $var1;    //定义变量    $var1=1;    $var2=1;    //定义同时赋值    // 访问变量    echo $var2; //通过var2变量名字找到存储的内容1，然后输出    //修改变量    $var2=2;    echo &#39;&lt;hr/&gt;&#39;,$var2;    // 删除变量：使用unset(变量名字)    unset($var2);    echo $var2;    // 第一，文件末尾的 ? &gt;可以省略    // 第二，该脚本若被其他脚本包含，所以该脚本不需要结束，否则会报错，因为是要和其他脚本衔接，只有在php代码后面需要写html的才使用闭合标签。?&gt;</code></pre><h2 id="变量命名规则"><a href="#变量命名规则" class="headerlink" title="变量命名规则"></a>变量命名规则</h2><ol><li>在PHP中变量名必须以“<code>$</code>”符号开始；</li><li>名字由字母、数字和下划线“<code>_</code>”构成，但是不能以数字开头；</li><li>在PHP中本身还允许中文变量（不建议）　　　　　</li></ol><p>代码示例：　　　　</p><pre><code class="php">    // 变量命名规则    $var_1;$var_var_1;$_var1;   //正确格式    $1var;     //不正确格式    // 中文变量    $中国=‘china’;</code></pre><h2 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h2><blockquote><p>预定义变量：提前定义的变量，系统定义的变量，存储许多需要用到的数据（预定义变量都是数组）。</p></blockquote><ul><li><code>$_GET</code>：获取所有表单以get方式提交的数据</li><li><code>$_POST</code>：POST提交的数据都会保存在此</li><li><code>$_REQUEST</code>：GET和POST提交的都会保存</li><li><code>$GLOBALS</code>：PHP中所有的全局变量</li><li><code>$_SERVER</code>：服务器信息</li><li><code>$_SESSION</code>：session会话数据</li><li><code>$_COOKIE</code>：cookie会话数据</li><li><code>$_ENV</code>：环境信息</li><li><code>$_FILES</code>：用户上传的文件信息</li></ul><h2 id="可变变量"><a href="#可变变量" class="headerlink" title="可变变量"></a>可变变量</h2><blockquote><p>可变变量：如果 一个变量保存的值 刚好是另外一个变量的名字，那么可以直接通过访问一个变量得到另外一个变量的值：在变量前面在多加一个<code>$</code>符号。</p></blockquote><p>代码示例：       </p><pre><code class="php">&lt;?php    /*    * Create by PhpStorm    * Author: Yan    * Date: 2019/8/7    * Time: 15:15    * Features: 可变变量    */    // 可变变量    // 定义两个变量    $a = &#39;b&#39;;    $b = &#39;bb&#39;;    echo $$a;    // 1、找到$a，解析结果：b    // 2、将前面的$符号与结果  b绑定：$b    // 3、解析 ?&gt;</code></pre><h2 id="变量传值"><a href="#变量传值" class="headerlink" title="变量传值"></a>变量传值</h2><blockquote><p>将一个变量赋值给另外一个变量：变量传值。</p></blockquote><p>变量传值一共有两个方式：值传递 ，引用传递。</p><ul><li>值传递：将变量保存的值赋值一份，然后将新的值给另外一个变量保存。（两个变量没有关系）</li></ul><p><img src="https://live.staticflickr.com/65535/48478623067_44b462675f_b.jpg" alt></p><ul><li>引用传递：将变量保存的值所在的内存地址，传递给另外一个变量：两个变量指向同一块内存空间。（两个变量是同一个值）</li></ul><p><img src="https://live.staticflickr.com/65535/48478474166_16933fb2d4_b.jpg" alt></p><p>在内存中，通常有以下几个分区：      </p><ul><li>栈区：程序可以操作的内存部分（不存数据，运行程序代码），少但是快</li><li>代码段：存储程序的内部部分（不执行）</li><li>数据段：存储普通数据 （全局区和静态区）</li><li>堆区：存储复杂数据，大但是效率低</li></ul><p>代码示例：      </p><pre><code class="php">&lt;?php/* * Create by PhpStorm * Author: Yan * Date: 2019/8/7 * Time: 16:04 * Features: 变量传值 */    // 变量传值     // 值传递    $a=10;    $b=$a;    $b=5;    echo $a,$b,&#39;&lt;/br&gt;&#39;;    //引用传递    $c=10;    $d=&amp;$c;    $c=5;    echo $c,$d,&#39;&lt;/br&gt;&#39;;?&gt;</code></pre><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><blockquote><p>常量与变量 一样，都是用来保存数据的。</p></blockquote><h2 id="常量基本概念"><a href="#常量基本概念" class="headerlink" title="常量基本概念"></a>常量基本概念</h2><blockquote><p>常量：const/constant，是一种在程序运行当中，不可改变的量（数据）。<br>常量一旦定义，通常数据不可改变（用户级别）。</p></blockquote><h2 id="常量定义形式"><a href="#常量定义形式" class="headerlink" title="常量定义形式"></a>常量定义形式</h2><p>在PHP中常量有两种定义方式（5.3之后才有两种）：</p><ul><li>使用定义常量的函数:<code>define(&#39;常量名&#39;,常量值);</code></li><li>5.3之后才有的：<code>const 常量名=值;</code></li></ul><p>代码示例：     </p><pre><code class="php">&lt;?php/* * Create by PhpStorm * Author: Yan * Date: 2019/8/7 * Time: 16:27 * Features: 常量 */    // 常量    // 使用函数定义常量:define    define(&#39;PI&#39;,3.14);    // 使用const关键字定义    const PII=3;?&gt;</code></pre><p>常量名字的命名规则：    </p><ol><li>常量不需要使用“<code>$</code>”符号，一旦使用系统就会认为是变量</li><li>常量的名字组成由字母、数字和下划线组成，不能以数字开头</li><li>常量的名字通常是以大写字母为主（与变量以示区别）</li><li>常量命名的规则比变量要松散，可以使用一些特殊字符，该方式只能使用define定义</li></ol><p>代码示例：     </p><pre><code class="php">&lt;?php/* * Create by PhpStorm * Author: Yan * Date: 2019/8/7 * Time: 16:27 * Features: 常量 */    // 常量    // 使用函数定义常量:define    define(&#39;PI&#39;,3.14);    // 使用const关键字定义    const PII=3;    // 定义特使常量    define(&#39;-_-&#39;,&#39;small&#39;);    // const -_-=&#39;smali&#39;;   //错误?&gt;</code></pre><p>注意细节：     </p><ol><li>define和const定义的常量是由区别的：在于访问权限区别。</li><li>定义常量通常不区分大写写，但是可以区分，可以参照define函数的第三个参数。</li></ol><h2 id="常量使用形式"><a href="#常量使用形式" class="headerlink" title="常量使用形式"></a>常量使用形式</h2><blockquote><p>常量的使用与变量一样：不可改变值（在定义的时候必须赋值）。</p></blockquote><blockquote><p>有的时候还需要使用另外一种形式来访问（针对的是特殊名字的常量），需要用到另外一个访问常量的函数：<code>constant(&#39;常量名&#39;)</code>。</p></blockquote><blockquote><p>说明：常量和变量的使用</p><ol><li>凡是数据会可能变化的，那么肯定使用变量</li><li>数据不一定会变，可以使用常量或者变量（变量居多）</li><li>数据不允许被修改的，一定用常量</li></ol></blockquote><p>代码示例：     </p><pre><code class="php">&lt;?php/* * Create by PhpStorm * Author: Yan * Date: 2019/8/7 * Time: 16:27 * Features: 常量 */    // 常量    // 使用函数定义常量:define    define(&#39;PI&#39;,3.14);    // 使用const关键字定义    const PII=3;    // 定义特使常量    define(&#39;-_-&#39;,&#39;small&#39;);    // const -_-=&#39;smali&#39;;   //错误    // 使用常量    echo PI;    // echo -_-;    //特殊符号不能直接使用    echo constant(&#39;-_-&#39;);?&gt;</code></pre><h2 id="系统常量"><a href="#系统常量" class="headerlink" title="系统常量"></a>系统常量</h2><blockquote><p>系统常量：系统帮助用户定义的常量，用户可以直接使用。</p></blockquote><p><strong>常用的几个系统常量</strong></p><p><code>PHP_VERSION</code>:PHP版本号<br><code>PHP_INT_SIZE</code>:整型大小<br><code>PHP_INT_MAX</code>:整型能表示的最大值(PHP中整型是允许出现负数的：带符号)</p><p>代码示例：    </p><pre><code class="php">&lt;?php    // 系统常量    echo &#39;&lt;/br&gt;&#39;,PHP_VERSION,&#39;&lt;/br&gt;&#39;,PHP_INT_SIZE,&#39;&lt;/br&gt;&#39;,PHP_INT_MAX;?&gt;</code></pre><p>在PHP中还有一些特殊的常量，他们由双下划线开始+常量名+双下划线结束，这种常量称之为系统魔术常量：魔术常量的值通常会跟着环境变化，但是用户改变不了。     </p><p><code>__DIR__</code>:当前被执行的脚本所在电脑的绝对路径<br><code>__FILE__</code>:当前被执行的脚本所在的电脑的绝对路径（带自己文件的名字）<br><code>___LINE__</code>:当前所属的行数<br><code>_NAMESPACE__</code>:当前所属的命名空间<br><code>__CLASS__</code>:当前所属的类<br><code>__METHOD__</code>:当前所属的方法</p><p>代码示例：    </p><pre><code class="php">&lt;?php    // 魔术常量    echo &#39;&lt;hr/&gt;&#39;;    echo __DIR__,&#39;&lt;br/&gt;&#39;,__FILE__,&#39;&lt;br/&gt;&#39;,__LINE__,&#39;&lt;br/&gt;&#39;;    echo __LINE__;?&gt;</code></pre><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><blockquote><p>数据类型：data type,在PHP中指的是存储的数据本身的类型，而不是变量的类型。PHP是一种弱类型语言，变量本身没有数据类型。</p></blockquote><h2 id="PHP的八种数据类型"><a href="#PHP的八种数据类型" class="headerlink" title="PHP的八种数据类型"></a>PHP的八种数据类型</h2><blockquote><p>在PHP中将数据分为三大类八小类：</p><ul><li>简单（基本）数据类型:4个小类<ul><li>整型：int/integer，系统分配4个字节存储，表示整数类型（有前提）</li><li>浮点型：float/double，系统分配8个字节存储，表示小数或者整型存不下的整数</li><li>字符串型：string，系统根据实际长度分配，表示字符串（引号）</li><li>布尔类型：bool/boolean，表示布尔类型，只有两个值：true和false</li></ul></li><li>复合数据类型：2个小类<ul><li>对象类型：object，存放对象（面向对象）</li><li>数组类型：array，存储多个数据（一次性）</li></ul></li><li>特殊数据类型：2个小类<ul><li>资源类型：resource，存放资源数据（PHP外部数据，如数据库、文件）</li><li>空类型：NULL，只有一个值就是NULL（不能运算）</li></ul></li></ul></blockquote><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><blockquote><p>类型转换：在很多的条件下，需要指定的数据类型，需要外部数据（当前PHP取得的数据），转换成目标数据类型。</p></blockquote><p>在PHP中有两种类型转换方式：    </p><ol><li>自动转换：系统根据需求自己判定，自己转换（用的比较多，效率偏低）</li><li>强制（手动）转换：认为 根据需要的目标类型转换</li></ol><p>强制转换规则：在变量之前增加一个括号<code>()</code>，然后在里面写上对应类型：int/integer….其中NULL类型用到<code>unset()</code>。</p><p>在转换过程中，用的比较多的就是转布尔类型（判断）和转数值类型（算术运算）。</p><p>其他类型转布尔类型：true或者false，在PHP中比较少类型换变成false</p><p><img src="https://live.staticflickr.com/65535/48486081426_2e19c56fa6_b.jpg" alt></p><p>其他类型转数值的说明     </p><ol><li>布尔true为1，false为0</li><li>字符串转数值有自己的规则<br>2.1 以字母开头的字符串，永远为0<br>2.2 以数字开头的字符串，取到碰到字符串为止（不会同时包含两个小数点）</li></ol><p>代码示例：     </p><pre><code class="php">&lt;?php/* * Create by PhpStorm * Author: Yan * Date: 2019/8/8 * Time: 15:06 * Features: 数据类型 */    // 数据类型    // 创建数据    $a=&#39;abc1.1.1&#39;;    $b=&#39;1.1.1.abc&#39;;    // 自动转换    echo $a+$b;    //算术运算，系统先转换成数值类型（整型和浮点型），然后运算    //强制转换    echo &#39;&lt;br/&gt;&#39;,(float)$a,(float)$b;?&gt;</code></pre><h2 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h2><blockquote><p>通过一组类型判断函数，来判断变量，最终返回这个变量所保存数据的数据类型（相同结果为true，失败为false）：是一组以is_开头后面跟类型名字的函数：<code>is_XXX(变量名)</code></p></blockquote><p><strong>bool类型不能用<code>echo</code>来查看，可以使用 <code>var_dump</code>结构来查看</strong></p><pre><code class="php">var_dump(变量1，变量2....)</code></pre><p>还有一组函数可以用来获取以及设定数据（变量）的类型</p><p><code>gettype(变量名)</code>：获取类型，得到的是该类型对应的字符串<br><code>settype(变量名,类型)</code>：设定数据类型：与强制转换不同</p><ol><li>强制转换（类型）变量名，是对数据值复制的内容进行处理（不会处理实际存储的内容）</li><li>settype会直接改变数据本身</li></ol><p>代码示例：     </p><pre><code class="php">&lt;?php/* * Create by PhpStorm * Author: Yan * Date: 2019/8/8 * Time: 15:06 * Features: 数据类型 */    // 数据类型    // 创建数据    $a=&#39;abc1.1.1&#39;;    $b=&#39;1.1.1.abc&#39;;    // 自动转换    echo $a+$b;    //算术运算，系统先转换成数值类型（整型和浮点型），然后运算    //强制转换    echo &#39;&lt;br/&gt;&#39;,(float)$a,(float)$b;    // 判断数据类型    echo &#39;&lt;hr/&gt;&#39;;    var_dump(is_int($a));        //false    var_dump(is_string($a));     //true    echo &#39;&lt;hr/&gt;&#39;;    echo gettype($a);    // 设置类型    echo &#39;&lt;hr/&gt;&#39;;    var_dump(settype($b,&#39;int&#39;));    echo gettype($b),$b;?&gt;</code></pre><h2 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h2><blockquote><p>整数类型：保存整数数值（范围限制），4个字节存储数据，最大就是32位：42亿多。但是在PHP中默认是有符号类型（区分正负数）</p></blockquote><p>在PHP中提供了四种整型的定义方式：十进制定义，二进制定义，八进制定义，十六进制定义。</p><pre><code class="php">$a=120;   //十进制$b=0b110;   //二进制$c=0120;     //八进制$d=0x120;    //十六进制</code></pre><p>代码示例：     </p><pre><code class="php">&lt;?php/* * Create by PhpStorm * Author: Yan * Date: 2019/8/8 * Time: 19:58 * Features: 简单数据类型：整型、浮点型和布尔型 */    // 定义四种整形数据    $a1=110;    $a2=0b110;    $a3=0110;    $a4=0x110;    echo $a1,&#39;~&#39;,$a2,&#39;~&#39;,$a3,&#39;~&#39;,$a4,&#39;&lt;hr/&gt;&#39;;    //默认的PHP输出数值都会自动转换成十进制输出?&gt;</code></pre><ul><li>十进制：逢十进一，能够出现的数字是0-9；</li><li>二进制：逢二进一，能够出现的数字是0-1；</li><li>八进制：逢八进一，能够出现的数字是0-7；</li><li>十六进制：逢十六进一，能够出现的数字是0-9以及a-f，a表示10，依次类推。</li></ul><p><strong>进制转换</strong>：手动转换</p><p>十进制转二进制：除2倒取余。<br>十进制转二进制：取出最大的2的N次方，直到结果为0。<br>二进制到十进制之间的转换：从右侧开始，将对应的第几位作为2的指数，然后将所有的结果相加。     </p><p><strong>PHP中不需要用户这么复杂的去计算，提供了很多的函数进行转换</strong></p><ul><li><code>decbin()</code>:十进制转二进制</li><li><code>decoct()</code>:十进制转八进制</li><li><code>dechex()</code>:十进制转十六进制</li></ul><p>代码示例：     </p><pre><code class="php">&lt;?php    // 利用进制函数运算    var_dump(decbin(107));?&gt; </code></pre><h2 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h2><blockquote><p>浮点型：小数类型以及超过整型所能存储范围的整数（不保证精度），精度范围大概在15个有效数字左右。</p></blockquote><p>浮点型定义有两种方式：</p><pre><code>$f=1.23;$f=1.23e10;    //科学计数法，其中e表示底10，1.23x10^10</code></pre><p>代码示例：     </p><pre><code class="php">&lt;?php    // 浮点数    $f1=1.23;    $f2=1.23e10;    $f3=PHP_INT_MAX+1;   //整型超过自身存储的大小之后会用浮点型存储。    echo &#39;&lt;hr/&gt;&#39;;    var_dump($f1,$f2,$f3);?&gt;</code></pre><p>简单说明浮点数为什么同样的字节数存储数据，但是却能表示更大的数据呢？</p><pre><code>00000000 00000000 00000000 00000000 -&gt;11111111 11111111 11111111 11111111(整型最大值：所有位都是有效数据)浮点数:**中的七位算的结果都是10的指数，后面三个字节存储表示具体数值00000000 00000000 00000000 00000000 -&gt;1*1111111* 11111111 11111111 11111111</code></pre><p><strong>尽量不要用浮点数做精确判断：浮点数保存的数据不够精确，而且在计算机中 凡是小数基本存的都不准确。</strong></p><p>代码示例：     </p><pre><code class="php">&lt;?php    //浮点数判断    $f4=0.7;    $f5=2.1;    $f6=$f5/3;    echo &#39;&lt;hr/&gt;&#39;;    var_dump($f4==$f6);?&gt;</code></pre><h2 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h2><blockquote><p>布尔类型：两个值true和false，通常是用于判断比较</p></blockquote><p>代码示例：    </p><pre><code class="php">&lt;?php    // 布尔类型    echo &#39;&lt;hr/&gt;&#39;;    $b1=true;    $b2=false;    var_dump($b1,$b2);?&gt;</code></pre><p>在进行某些数据判断的时候，需要特别注意类型转换</p><ul><li><code>empty()</code>:判断数据的值是否为空<code>“”</code>，不是<code>NULL</code>，如果为空返回true，不为空返回false</li><li><code>isset()</code>:判断数据存储的变量本身是否存在，存在变量返回true，不存在返回false</li></ul><p><img src="https://live.staticflickr.com/65535/48486081426_2e19c56fa6_b.jpg" alt></p><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><blockquote><p>运算符：operator,是一种将数据进行运算的特殊符号，在PHP中一共有十种运算符之多。</p></blockquote><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>赋值运算 ：符号是“<code>=</code>”,表示将右边的结果（可以是变量、数据、常量和其他匀速出来的结果），保存道内存的某个位置，然后将位置的内存地址赋值给左侧的变量（常量）。</p><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>算术运算：基本算术操作</p><ul><li><code>+</code>:执行数据累加</li><li><code>-</code>:数据相减</li><li><code>*</code>:键盘上没有乘法符号，使用<code>*</code>代替，两个数相乘</li><li><code>/</code>:正斜杠代替，表示两个数相除</li><li><code>%</code>:取余（模）运算，两个数（整数）相除，保留余数</li></ul><p>在进行除法运算或者取余运算的时候，对应的被除数（第二个数）不能为0。</p><p>代码示例：     </p><pre><code class="php">&lt;?php/* * Create by PhpStorm * Author: Yan * Date: 2019/8/9 * Time: 13:54 * Features: 运算符 */    // 运算符    // 算术运算符    $a=$b=10;     //连贯赋值运算：两个不同变量    $c=0;    var_dump($a/0);       //错误，被除数不能为0?&gt;</code></pre><h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><p>比较运算：比较两个数据的大小，或者两个内容是否相同。返回的结果都是 布尔类型：满足返回true，不满足返回false。</p><ul><li><code>&gt;</code>:左边大于右边，返回结果 true</li><li><code>&gt;=</code>:左边大于或者等于右边</li><li><code>&lt;</code>:左边小于右边</li><li><code>&lt;=</code>:左边小于或者等于右边</li><li><code>==</code>:左边的与右边的相同（大小相同）</li><li><code>!=</code>:左边的与右边的不同（大小不同）</li><li><code>===</code>:全等于，左边与右边相同：大小以及数据的类型都要相同</li><li><code>!==</code>:不全等于，只要大小或者类型不同</li></ul><p>代码示例：    </p><pre><code class="php">&lt;?php    //比较运算符    $a=&#39;123&#39;; //字符串    $b=123;    //整型    //判断相等    var_dump($a==$b);    echo &#39;&lt;hr/&gt;&#39;;    // 全等判断    var_dump($a===$b);?&gt;</code></pre><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><blockquote><p>逻辑运算：针对不同的结果进行匹配，满足条件返回true，不满足返回false</p></blockquote><ul><li><code>&amp;&amp;</code>:逻辑与，左边的条件与右边的条件同时成立（两边的结果都为true）</li><li><code>||</code>:逻辑或，左边的条件或者右边的条件只要 有一个 满足即可</li><li><code>!</code>:逻辑非，对已有条件进行取反，本身为true，取反结果就是false</li></ul><p>代码示例：     </p><pre><code class="php">&lt;?php    // 逻辑运算符    echo &#39;&lt;hr/&gt;&#39;;    $a = &#39;weekend&#39;;    $b = &#39;goods&#39;;    // 逻辑与    var_dump($a == &#39;weekend&#39; &amp;&amp; $b == &#39;good&#39;);    echo &#39;&lt;hr/&gt;&#39;;    // 逻辑或    var_dump($a == &#39;weekend&#39; || $b == &#39;good&#39;);    echo &#39;&lt;hr/&gt;&#39;;    // 逻辑非    var_dump($b==&#39;good&#39;);    var_dump(!($b==&#39;good&#39;));?&gt;</code></pre><p><strong>逻辑非和逻辑或又称为短路运算：如果第一个表达式结果已经满足条件了，那么就不会运行逻辑运算符后的表达式：在书写代码的时候，尽量将出现概率最高的（能够直接判断出结果）的表达式放到第一位。</strong></p><h2 id="连接运算符"><a href="#连接运算符" class="headerlink" title="连接运算符"></a>连接运算符</h2><blockquote><p>连接运算：是PHP中将多个字符串拼接的一种符号。</p></blockquote><ul><li><code>.</code>:将两个字符串拼接到一起</li><li><code>.=</code>:符合运算，将左边的内容与右边的内容连接起来，然后重新赋值给左边变量，如<code>A.=b -----&gt;  A=A.b</code></li></ul><p>代码示例：    </p><pre><code class="php">&lt;?php    // 连接运算符    $a=&#39;hello&#39;;    $b=123;    echo $a.$b;   //将a变量和b变量连接起来    echo &#39;&lt;hr/&gt;&#39;;    $a.=$b;     // $a=$a.$b    echo $a;?&gt;</code></pre><h2 id="错误抑制符"><a href="#错误抑制符" class="headerlink" title="错误抑制符"></a>错误抑制符</h2><blockquote><p>在PHP中有一些错误可以提前预知 ，但是这些错误可能无法避免，但是又比希望报错给用户看，可以使用错误抑制符处理。</p></blockquote><ul><li><code>@</code>:在可能出错的表达式前面使用@符号即可。</li></ul><p>错误抑制符通常在生产环境（上线 ）会用到，在开发的时候不会用：系统本身 最好没有任何错误。</p><p>代码示例：    </p><pre><code class="php">&lt;?php    // 错误抑制符    $a = 10;    $b = 0;    $a / $b;    @($a / $b);?&gt;</code></pre><h2 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h2><blockquote><p>三目运算：有三个表达式参与的运算（简单的分支结构缩写）</p></blockquote><p>语法格式：    </p><pre><code>表达式1?表达式2:表达式3;</code></pre><p>运算：如果表达式1成立，那么执行表达式2，否则执行表达式3；</p><p><strong>注意：如果表达式本身比较复杂，建议使用括号包起来</strong></p><p>代码示例：    </p><pre><code class="php">&lt;?php    //三木运算符    $a = 10;    $b = $a &gt; 10 ? 100 : 0;    echo $b;?&gt;</code></pre><p>三木运算可以进行符合三木运算：三木运算中的表达式2和3都可以是另外一个三目运算。</p><pre><code>表达式1?(表达式2?表达式4:表达式5):(表达式3?表达式6:表达式7);</code></pre><h2 id="自操作运算符"><a href="#自操作运算符" class="headerlink" title="自操作运算符"></a>自操作运算符</h2><blockquote><p>自操作：自己操作自己的运算符</p></blockquote><ul><li><code>++</code>:在原来的值上+1</li><li><code>--</code>:在原来的值上-1</li></ul><p>在PHP中自操作符是可以放到变量前或者后：前置自操作和后自操作。</p><p><strong>后置自操作（<code>a++</code>）：先把自己所保存的值留下来，然后改变自己，自己给别人的值是原来的值。</strong></p><p><strong>前置自操作(<code>++a</code>)：先把自己改变，然后把改变后的值给别人。</strong></p><p>代码示例：     </p><pre><code class="php">&lt;?php    // 自操作符    $a=$b=1;    $a++;   //独立操作，不参与其他运算    ++$b;   //独立操作，不参与其他运算    echo $a,$b;    echo &#39;&lt;hr/&gt;&#39;;    echo $a++,++$b;   //$a和$b不只是独立运算，还参与了输出操作?&gt;</code></pre><p>衍生符号：类似自操作。</p><ul><li><code>+=</code>:左边的结果与右边的结果相加，然后赋值给左边</li><li><code>-=</code>:左边的减去右边的结果，然后赋值给左边</li><li><code>*=</code>:乘法操作</li><li><code>/=</code>:除法操作</li><li><code>%=</code>:模操作</li></ul><p><strong>注意：右边是一个整体，如<code>$a+=$b;  =====&gt;   $a=$a+($b);</code></strong></p><p>代码示例：     </p><pre><code class="php">&lt;?php    $a = 10;    $b = 5;    $a += $b;       //$a=$a+$b=15;    $a-=$b-1;       //$a=$a-($b-1)    echo $a,&#39;&lt;br/&gt;&#39;,$b;?&gt;</code></pre><p><strong>如果进行除法或者取余运算，那么要考虑右边表达式的结果是否为0（为0出错）。</strong></p><h2 id="计算机码"><a href="#计算机码" class="headerlink" title="计算机码"></a>计算机码</h2><blockquote><p>计算机码：计算机在实际存储数据的时候，采用的编码规则（二进制规则）<br>计算机码：原码、反码和补码，数值本身最左边一位是用来充当符号位：正数为0，负数为1</p></blockquote><ul><li>原码：数据本身从二进制转换成二进制得到的结果<ul><li>正数：左边符号位为0（正数的原码、反码、补码就是原码本身）</li><li>负数：左边符号位为1</li></ul></li><li>反码：针对负数，符号位不变，其他位取反</li><li>补码：针对负数，反码+1</li></ul><p>系统中存在两个0：+0和-0<br>+0：00000000<br>-0：10000000   原码<br>取反 11111111<br>补码 00000000</p><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><blockquote><p>位运算：取出计算机中最小的单位（位bit）进行计算</p></blockquote><ul><li><code>&amp;</code>:按位与，两个位都为1，结果为1，否则为0</li><li><code>|</code>:按位或，两个有一个为1，结果为1</li></ul><p>代码示例：     </p><pre><code class="php">&lt;?php    /*     * Create by PhpStorm     * Author: Yan     * Date: 2019/8/9     * Time: 22:22     * Features: 位运算     */    // 位运算    $a = 5;    $b = -5;    /*     * 5原码：00000101     *     *     * -5原码：10000101     * 取反：11111010    反码：符号位不变，其他位取反     * 求补：11111011   补码：反码+1     */    // 按位与    var_dump($a &amp; $b);     /*      * 取出系统存储的结果进行与操作      * 5  00000101      * -5 11111011      * &amp;  00000001   //最终结果      * 转换：判断符号位，0表示正数，1表示负数（补码）      */?&gt;</code></pre><p><strong>注意</strong><br><strong>1. 系统进行任何位运算的时候都是使用的补码</strong><br><strong>2. 运算结束之后都必须转换成原码才是最终要显示的数据</strong></p><ul><li><code>~</code>:按位非，一个位如果为1则变成0，否则反之</li></ul><p>代码示例：    </p><pre><code class="php">&lt;?php    /*     * Create by PhpStorm     * Author: Yan     * Date: 2019/8/9     * Time: 22:22     * Features: 位运算     */    // 位运算    $a = 5;    $b = -5;    /*     * 5原码：00000101     *     *     * -5原码：10000101     * 取反：11111010    反码：符号位不变，其他位取反     * 求补：11111011   补码：反码+1     */    echo &#39;&lt;hr/&gt;&#39;;    // 按位非    var_dump(~$b);    /*     * -5 11111011    补码     * 取反   00000100     * 原码   00000100     */?&gt;</code></pre><ul><li><code>^</code>:按位异或，两个相同则为0，不同则为1</li><li><code>&lt;&lt;</code>:按位左移，整个位（32位），向左移动一位，右边补0</li><li><code>&gt;&gt;</code>:按位右移，整个位（32位）向右移动一位，左边补符号位对应内容（正数补0，负数补1）</li></ul><p>代码示例：    </p><pre><code class="php">&lt;?php    /*     * Create by PhpStorm     * Author: Yan     * Date: 2019/8/9     * Time: 22:22     * Features: 位运算     */    // 位运算    $a = 5;    $b = -5;    /*     * 5原码：00000101     *     *     * -5原码：10000101     * 取反：11111010    反码：符号位不变，其他位取反     * 求补：11111011   补码：反码+1     */    echo &#39;&lt;hr/&gt;&#39;;    // 按位右移    var_dump($b &gt;&gt; 1);    var_dump($b &gt;&gt; 2);    /*     * -5   11111011    补码     * &gt;&gt;2    11111110    //运算结果：补码     * -1     11111101       //反码     * 取反    1000010      //原码：-2     */?&gt;</code></pre><p><strong>按位左移：乘以2的操作</strong><br><strong>按位右移：除以2的操作（不完全正确）：整数除2会出现小数</strong>     </p><h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><blockquote><p>运算符优先级：在多种运算符同时存在的时候，如何结合运算。</p></blockquote><p><img src="https://live.staticflickr.com/65535/48496217207_41006ba77b_b.jpg" alt></p><h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><blockquote><p>流程控制：代码执行的方向。</p></blockquote><h2 id="控制分类"><a href="#控制分类" class="headerlink" title="控制分类"></a>控制分类</h2><ul><li>顺序结构：代码从上往下，顺序执行。（代码执行的最基本结构）</li><li>分支结构：给定一个条件，同时有多种可执行代码（块），然后会根据条件执行某一段代码。</li><li>循环结构：在某个条件控制范围内，指定的代码（块）可以重复执行。</li></ul><h2 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h2><blockquote><p>顺序结构：最基本结构，所有代码默认是从上往下依次执行</p></blockquote><h2 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h2><blockquote><p>在PHP中 ，分支结构主要有两种：if分支和switch分支</p></blockquote><h3 id="if分支"><a href="#if分支" class="headerlink" title="if分支"></a>if分支</h3><blockquote><p>if：如果的意思，给定一个条件，同时为该条件设置多种（两种 ）情况，然后通过条件判断来实现具体的执行段。</p></blockquote><p>基本语法：if分支PHP也是提供多种方式来实现。</p><ul><li>最简if：只有一段代码，但是可以选择是否执行。</li></ul><pre><code>if(条件表达式){    //满足条件所要执行的内容;    //顺序结构}</code></pre><ul><li>基础if：有两面性，满足条件或者不满足条件都有对应的执行代码。</li></ul><pre><code>if(条件表达式){    //满足条件后执行的代码段}else{    //不满足条件执行的代码段}</code></pre><ul><li>复杂if结构：在判断条件之后，通常就有两种结果：满足或者不满足，在不满足之后还可以再次进行条件判断。</li></ul><pre><code>if(条件表示式1){    //满足条件表达式1的代码段}elseif(条件表达式2){    //不满足表达式1条件，但是满足表达式2的代码}...//可以使用多个elseif来进行再次条件筛选else{    //全部不满足要执行的代码}</code></pre><p><strong>注意：</strong></p><ul><li>如果条件特别多才会采用复合if形式</li><li>如果条件比较单一（同一条件），会采用elseif复合方式</li><li>如果判断条件不一致，建议使用嵌套语法（不宜有太多层嵌套：影响代码美观）</li></ul><p><strong>if分支，适用于所有的条件判断（分支结构）。</strong></p><p>代码示例：     </p><pre><code class="php">&lt;?php    /*     * Create by PhpStorm     * Author: Yan     * Date: 2019/8/10     * Time: 23:09     * Features: if分支     */    // 分支结构：if分支    //最简if    $day = &#39;weekend&#39;;    // 如果是星期天就出去玩    if ($day == &#39;sunday&#39;) {        echo &#39;go out&#39;;    }    // 基本if判断    // 如果是星期天就出去玩，否则上班    if ($day == &#39;sunday&#39;) {        echo &#39;go out play&#39;;    } else {        // 不满足条件        echo &#39;work&#39;;    }    // 复合if结构    // 如果是星期天就出去玩，否则不能，但是如果是星期六，那么可以在家玩    echo &#39;&lt;hr/&gt;&#39;;    $day = &#39;saturday&#39;;    if ($day == &#39;sunday&#39;) {        echo &#39;go out&#39;;    } else {        // 包含全部不满足情况        // 重新进行判断        if ($day == &#39;saturday&#39;) {            echo &#39;play at home&#39;;        } else {            echo &#39;work&#39;;        }    }    echo &#39;&lt;hr/&gt;&#39;;    if ($day == &#39;sunday&#39;) {        echo &#39;go out&#39;;    } elseif ($day == &#39;saturday&#39;) {        echo &#39;play at home&#39;;    } else {        echo &#39;work&#39;;    }?&gt;</code></pre><h3 id="switch分支"><a href="#switch分支" class="headerlink" title="switch分支"></a>switch分支</h3><blockquote><p>switch分支：有一组情形存在，同过一条件，通常有多个值，但是每一个值都会有对应不同的代码执行。</p></blockquote><p>switch判断方式：是将条件放到分支结构内部判断</p><p>switch基本语法：     </p><pre><code>switch(条件表达式){    // 所有条件判断：逐个进行    case 值1:       //当前条件表达式的结果与值1相等（==）        要执行的代码段;        break;     //在switch中，如果条件匹配成功，那么系统就不会再次匹配条件，会自动顺序执行向下的所有代码（case代码除外），需要中断执行：break表示中断switch（结束）    case 值2:        要执行的代码段;        break;    ....    //可以使用类似else的语法：都不匹配    default:        //匹配失败的代码        break;}</code></pre><p>代码示例：   </p><pre><code class="php">&lt;?php    /*     * Create by PhpStorm     * Author: Yan     * Date: 2019/8/10     * Time: 23:30     * Features: switch 分支     */    //switch分支    // 根据日期做不同的事情    $day=1;    //从1到7做不同的事情    switch ($day){        //$day条件一定是个具体的值        case 1:    //$day==1            echo &#39;1&#39;;            break;        case 2:            echo &#39;2&#39;;            break;        case 3:            echo &#39;3&#39;;            break;        case 4:            echo &#39;4&#39;;            break;        case 5:            echo &#39;5&#39;;            break;        default:            echo &#39;error&#39;;            break;    }?&gt;</code></pre><p><strong>if和switch的选择</strong></p><ol><li>if能做所有的分支结构事情</li><li>switch处理的是条件比较多，同时比较单一，而且是固定值匹配的分支结构</li></ol><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><blockquote><p>循环结构：代码段在一定的控制下，可以多次执行。</p></blockquote><p>在PHP中循环结构有以下几种：     </p><ul><li>for循环：通过条件、起始和终止判断执行</li><li>while循环：通过判断条件终止</li><li>do-while循环：跟while差不多</li><li>foreach循环：专门针对数组</li></ul><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>for循环基本语法</p><pre><code>for(条件表达式1;条件表达式2;条件表达式3){    // 条件表达式1：定义初始化条件，可以有多种赋值语句存在，使用逗号分隔即可    // 条件表达式2：边界判定，限定循环执行的次数    // 条件表达式3：用来执行条件变化    // 循环体}</code></pre><p><strong>for循环执行原理：</strong></p><ol><li>执行条件表达式1：定义初始化条件（执行依次）。</li><li>执行条件表达式2：判断条件（N次）。<br>2.1. 满足条件：执行循环体。<br>2.2. 不满足条件：循环结束。</li><li>执行循环体：（N次）。</li><li>执行条件表达式3：循环变量变化（N次）。</li><li>执行条件表达式2：判断条件（N次）。</li><li>重复执行3-4-2步骤：直到第2步不满足条件结束循环。</li></ol><p>for循环中条件表达式1的多变量定义：    </p><p>代码示例：     </p><pre><code class="php">&lt;?php    /*     * Create by PhpStorm     * Author: Yan     * Date: 2019/8/11     * Time: 15:07     * Features: for循环     */    // 循环结构：for循环    // 从1到10输出：初始为1，结果为10    for ($i = 1; $i &lt;= 10; $i++) {        // 输出        echo $i,&#39;&lt;br/&gt;&#39;;    }    // 最后：$i=11    echo $i;    &lt;?php    echo &#39;&lt;hr&gt;&#39;;    // 从1到10输出（10通常是动态得到的）    for ($i = 1, $end = 10; $i &lt;= $end; $i++) {        // 输出        echo $i, &#39;&lt;br/&gt;&#39;;    }?&gt;</code></pre><p>for循环特殊使用：for循环中对应的括号（条件）可以一个都没有—》(死循环)。<strong>一定要避免出现</strong></p><p>代码示例：    </p><pre><code class="php">&lt;?php    // 无条件for循环    for (;;){        echo &#39;hello world&#39;,&#39;&lt;br/&gt;&#39;;    }?&gt;</code></pre><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p>while循环基本语法：    </p><pre><code>条件初始化while(条件表达式){    // 条件表达式就是判断边界条件    循环体;     //循环条件的变化}</code></pre><p><strong>for与while的选择：</strong></p><ol><li>如果是基于固定已知条件（数值而且有规律的变化），使用for循环</li><li>while可以做灵活的条件判定（while用的比较多）</li></ol><p>代码示例：    </p><pre><code class="php">&lt;?php    /*     * Create by PhpStorm     * Author: Yan     * Date: 2019/8/11     * Time: 15:30     * Features: while循环     */    // while循环    //定义条件    $i=1;    // 循环判定执行    while ($i&lt;=10){        //循环体        echo $i++,&#39;&lt;br/&gt;&#39;;        // 循环条件变更        // $i++;    }?&gt;</code></pre><h3 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do-while循环"></a>do-while循环</h3><blockquote><p>do-while：看着很像while，while首先进行条件判定然后执行循环体，有可能出现第一次就条件不满足，那么就会直接失败（循环体一次都不执行）。do-while就是先干了再说（执行循环体），后判断条件。（至少会执行一次循环体）</p></blockquote><p>do-while基本语法：    </p><pre><code>do{    // 循环体}while(条件表达式);</code></pre><p>代码示例：     </p><pre><code class="php">&lt;?php    /*     * Create by PhpStorm     * Author: Yan     * Date: 2019/8/11     * Time: 15:37     * Features: do-while循环     */    // do-while循环结构    // 输出1到10之间的偶数（条件判定加入）    // 定义基础条件    $i = 1;    // 循环判定    do {        // 执行输出        if ($i % 2 != 1){            // 是偶数            echo $i,&#39;&lt;br/&gt;&#39;;   //条件变更        }        //条件变更        $i++;    }while($i&lt;=10);?&gt;</code></pre><h3 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h3><ul><li>循环控制：在循环内部对循环本身进行控制</li><li><p>中断控制：重新开始循环，循环体中还有其他内容，也再执行</p><ul><li>continue层级；    //默认是1（循环可以多层嵌套）</li></ul></li><li><p>终止控制：循环直接结束</p><ul><li>break层级；   //默认是1</li></ul></li></ul><p>代码示例：     </p><pre><code class="php">&lt;?php    /*     * Create by PhpStorm     * Author: Yan     * Date: 2019/8/11     * Time: 15:50     * Features: 循环控制     */    // 循环控制    // 需求：输出1到100之间5的倍数    $i=1;    while ($i&lt;=100){        // 判断:是否是5的倍数        if ($i%5!=0){            // 说明当前$i不是5的倍数            //重新循环            $i++;            //重新循环            // continue;   //系统重新跳到循环开始处            //终止循环            break;        }        // 输出数值        echo $i++,&#39;&lt;br/&gt;&#39;;    }    echo $i;?&gt;</code></pre><p><strong>因为循环经常性会碰到嵌套（循环中间包含循环），如果再循环内部有些条件下，明确可以直到当前循环（或者说外部循环）不需要继续执行了，那么就是可以使用循环控制来实现：其中内部循环也可以控制到外部，就是通过使用层级参数。</strong></p><pre><code>continue 2;   //当前自己循环后面内部不再执行，同时外部循环如果还有循环体也不再执行，重新来过；break2;     //当前自己循环结束，同时外部也结束（如果还有外部影响，继续执行）</code></pre><h2 id="流程控制替代语法"><a href="#流程控制替代语法" class="headerlink" title="流程控制替代语法"></a>流程控制替代语法</h2><blockquote><p>流程控制替代语法：分支和循环结构的替代语法</p></blockquote><p>PHP本身是嵌入到HTML中的脚本语言，需要再HTML中书写一些关于判断或者循环的结构语法，必须符合PHP标签规范，需要HTML与PHP进行混搭，如果使用原始的PHP代码那么会非常不美观。</p><p>需求：打印一个九九乘法表，使用表格展示。</p><p>在PHP书写到HTML中的这些大括号{}非常不美观，所以PHP提供了一种替代机制，让其可以不用书写大括号：   </p><pre><code>for(;;){ }     ----&gt;for(;;):  endfor</code></pre><p>代码示例：    </p><pre><code class="php">&lt;table border=1&gt;    &lt;?php for ($i = 1; $i &lt; 10; $i++) { ?&gt;        &lt;tr&gt;            &lt;?php for ($j = 1; $j &lt;= $i; $j++) { ?&gt;                &lt;td&gt;                    &lt;?php echo $i . &#39;*&#39; . $j . &#39;=&#39; . $i * $j; ?&gt;                &lt;/td&gt;            &lt;?php } ?&gt;        &lt;/tr&gt;    &lt;?php } ?&gt;&lt;/table&gt;&lt;table border=1&gt;    &lt;?php for ($i = 1; $i &lt; 10; $i++) :?&gt;        &lt;tr&gt;            &lt;?php for ($j = 1; $j &lt;= $i; $j++) : ?&gt;                &lt;td&gt;                    &lt;?php echo $i . &#39;*&#39; . $j . &#39;=&#39; . $i * $j; ?&gt;                &lt;/td&gt;            &lt;?php endfor; ?&gt;        &lt;/tr&gt;    &lt;?php endfor ?&gt;&lt;/table&gt;</code></pre><p>PHP中具体有哪些替代语法呢？PHP应该在HTML中只做数据输出，输出通常伴有条件判断和循环操作，因此PHP提供了对应分支结构和循环结构的替代方法：全部都是对应的一个模式：</p><ul><li>左大括号<code>{</code>使用<code>冒号</code>代替；</li><li>右大括号<code>}</code>使用<code>end+对应的其实标记</code>替代；</li><li>if:<code>if():  endif;</code></li><li>switch:<code>switch():  endswitch;</code></li><li>for:<code>fot():  endfor</code></li><li>while:<code>while():  endwhile</code></li><li>foreach:<code>foreach():  endforeach</code></li></ul><h1 id="常用系统函数"><a href="#常用系统函数" class="headerlink" title="常用系统函数"></a>常用系统函数</h1><h2 id="有关输出的函数"><a href="#有关输出的函数" class="headerlink" title="有关输出的函数"></a>有关输出的函数</h2><ul><li><code>print()</code>:类似于echo输出提供的内容，本质是一种结构（不是函数）,返回1，可以不需要使用括号。</li><li><code>print_r()</code>:类似于var_dump，但是比var_dump简单，不会输出数据的类型，只会输出值（数组打印使用比较多）。</li></ul><p>代码示例：     </p><pre><code class="php">&lt;?php    /*     * Create by PhpStorm     * Author: Yan     * Date: 2019/8/13     * Time: 15:02     * Features: 系统函数     */    // 系统函数    //输出相关    echo print (&#39;hello world&lt;br/&gt;&#39;);    print &#39;hello world&lt;br/&gt;&#39;;    $a=&#39;hello world&lt;br/&gt;&#39;;    print_r($a);?&gt;</code></pre><h2 id="有关时间的函数"><a href="#有关时间的函数" class="headerlink" title="有关时间的函数"></a>有关时间的函数</h2><p><code>date()</code>:按照指定格式对应的时间戳（从1970年格林威治时间开始计算的秒数），如果没有指定特定的时间戳，那么就是默认解释当前时间戳。<br><code>time()</code>:获取当前时间对应的时间戳<br><code>microtime()</code>:获取微秒级别的时间<br><code>strtotime()</code>:按照规定格式的字符串转换成时间戳。</p><p>代码示例：     </p><pre><code class="php">&lt;?php    /*     * Create by PhpStorm     * Author: Yan     * Date: 2019/8/13     * Time: 15:02     * Features: 系统函数     */    // 系统函数    // 时间函数    echo date(&#39;Y 年 m 月 d 日 H:i:s&#39;, 12345678), &#39;&lt;hr/&gt;&#39;;    echo time(), &#39;&lt;hr/&gt;&#39;;    echo microtime(), &#39;&lt;hr/&gt;&#39;;    echo strtotime(&quot;now&quot;), &quot;\n&quot;;    echo strtotime(&quot;10 September 2000&quot;), &quot;\n&quot;;    echo strtotime(&quot;+1 day&quot;), &quot;\n&quot;;    echo strtotime(&quot;+1 week&quot;), &quot;\n&quot;;    echo strtotime(&quot;+1 week 2 days 4 hours 2 seconds&quot;), &quot;\n&quot;;    echo strtotime(&quot;next Thursday&quot;), &quot;\n&quot;;    echo strtotime(&quot;last Monday&quot;), &quot;\n&quot;;?&gt;</code></pre><h2 id="有关数字的函数"><a href="#有关数字的函数" class="headerlink" title="有关数字的函数"></a>有关数字的函数</h2><h2 id="有关函数的函数"><a href="#有关函数的函数" class="headerlink" title="有关函数的函数"></a>有关函数的函数</h2><h1 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h1><blockquote><p>文件包含：在一个PHP脚本中，去将另外一个文件（PHP）包含进来，去合作完成一件事情。</p></blockquote><h2 id="文件包含的作用"><a href="#文件包含的作用" class="headerlink" title="文件包含的作用"></a>文件包含的作用</h2><p>文件包含的意义：</p><ol><li>要么使用被包含文件中的内容，实现代码的共享（重用）：向上包含（索要）<ul><li>向上包含：在当前脚本要用某个代码之前包含别的文件</li></ul></li><li>要么自己有东西可以给别的文件使用，实现代码的共享（重用）：向下包含（给予）<ul><li>向下包含：在自己有某个东西的时候，需要别的脚本来显示（自己代码写完之后包含其他文件）</li></ul></li></ol><p>最大的作用：分工协作，每个脚本做的事情不一样，因此可以使用写作方式，让多个脚本共同完成一件事情。</p><h2 id="文件包含四种形式"><a href="#文件包含四种形式" class="headerlink" title="文件包含四种形式"></a>文件包含四种形式</h2><p>在PHP中问之间的包含有四种形式（两大形式）</p><ul><li>include:包含文件</li><li>include_once:系统会自动判断文件包含过程中，是否已经包含过（一个文件最多被包含一次）</li><li>require:与include相同</li><li>require_once:以include_once相同</li></ul><p>包含基本语法：</p><pre><code>include &#39;文件名字&#39;;include(&#39;文件名字&#39;);     //文件名字：路径问题</code></pre><p>代码示例：    </p><p><strong>include1.php</strong></p><pre><code class="php">&lt;?php    /*     * Create by PhpStorm     * Author: Yan     * Date: 2019/8/13     * Time: 20:36     * Features: 文件包含     */    //被包含文件    //定义数据    $a=1;    define(&#39;PI&#39;,3.14);?&gt;</code></pre><p><strong>include2.php</strong></p><pre><code class="php">&lt;?php    /*     * Create by PhpStorm     * Author: Yan     * Date: 2019/8/13     * Time: 20:37     * Features: 文件包含     */    //包含文件：使用数据    //包含文件    include &#39;include1.php&#39;;   //包含当前文件include2.php所在文件夹下的include1.php    echo $a,PI;?&gt;</code></pre><p>以上方式：是先包含文件，后使用文件中的内容（向上包含）。</p><p>向下包含：先准备内容，然后包含另外的文件，在另外的文件中，使用当前的内容。</p><p>代码示例：    </p><p><strong>include3.php</strong></p><pre><code class="php">&lt;?php    /*     * Create by PhpStorm     * Author: Yan     * Date: 2019/8/13     * Time: 20:46     * Features: 文件包含     */    //定义数据    $a = 10;    const PI = 3.14;    //包含文件：为了显示以上数据    include_once &#39;include4.php&#39;;?&gt;</code></pre><p><strong>include4.php</strong></p><pre><code class="php">&lt;table&gt;    &lt;tr&gt;        &lt;td&gt;&lt;?php echo $a; ?&gt;&lt;/td&gt;        &lt;td&gt;&lt;?php echo PI; ?&gt;&lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;</code></pre><h2 id="文件加载原理"><a href="#文件加载原理" class="headerlink" title="文件加载原理"></a>文件加载原理</h2><p>PHP代码的执行流程：    </p><ol><li>读取代码文件（PHP程序）</li><li>编译：将PHP代码转换成字节码（生成opcode）</li><li>zendengine来解析opcode，按照字节码去进行逻辑运算</li><li>转换成对应的HTML代码</li></ol><blockquote><p>文件加载原理：</p><ol><li>在文件加载（include或者require）的时候，系统会自动地将被包含文件中的代码相当于嵌入到当前文件中。 </li><li>加载位置：在哪加载，对应的文件中的代码嵌入的位置就是对应的include位置。</li><li>在PHP中被包含的文件是单独进行编译的</li></ol></blockquote><p>PHP文件在编译的过程中如果出现了语法错误，那么会失败（不会执行）：但是如果被包含文件有错误的时候，系统会执行到包含include这条语句的时候才会报错。</p><h2 id="include和require区别"><a href="#include和require区别" class="headerlink" title="include和require区别"></a>include和require区别</h2><ul><li>include和include_once的区别：</li></ul><p>include系统会碰到一次，执行一次；如果对同一文件进行多次加载，那么系统会执行多次；<br>include_once：系统碰到多次，也只会执行一次。</p><ul><li>require和include的区别：</li></ul><p>本质都是包含文件，唯一的区别在于包含不到文件的时候，报错的形式不一样。</p><p>include的错误级别比较轻：不会阻止代码执行。<br>require要求较高：如果包含出错代码不再执行（require后面的代码）</p><h1 id="文件加载路径"><a href="#文件加载路径" class="headerlink" title="文件加载路径"></a>文件加载路径</h1><p>文件在加载的时候需要指定文件路径才能保证PHP正确的找到对应的文件。</p><p>文件的加载路径包含两大类：</p><ul><li>绝对路径<ul><li>从磁盘的根目录开始（本地绝对路径 ）<ul><li>Windows  ：盘符C：/路径/PHP文件</li><li>Linux：/路径/PHP文件</li></ul></li><li>从网站根目录开始（网络绝对路径）<ul><li>/：相对于网站主机名字对应的路径</li><li>localhost/index.php-&gt;E:/server/apache/htdocs/index.php</li></ul></li></ul></li><li>相对路径:从当前文件所在目录开始的路径<ul><li>.|./：当前文件夹</li><li>../：上级目录（当前文件夹的上一层文件夹）</li></ul></li></ul><p>绝对路径和相对路径的加载区别：</p><ol><li>绝对路径相对效率偏低，但是相对安全（路径不会出问题）</li><li>相对路径相对效率高些，但是容易出错（相对路径会发生改变）</li></ol><h1 id="文件嵌套包含"><a href="#文件嵌套包含" class="headerlink" title="文件嵌套包含"></a>文件嵌套包含</h1><blockquote><p>文件嵌套包含 ：一个文件包含另外一个文件，同时被包含的文件又包含了另外一个文件。</p></blockquote><p>代码示例：    </p><p><strong>include3.php</strong></p><pre><code class="php">&lt;?php    /*     * Create by PhpStorm     * Author: Yan     * Date: 2019/8/13     * Time: 20:46     * Features: 文件包含     */    //定义数据    $a = 10;    const PI = 3.14;    //包含文件：为了显示以上数据    include_once &#39;include4.php&#39;;?&gt;</code></pre><p><strong>include4.php</strong></p><pre><code class="php">&lt;table&gt;    &lt;tr&gt;        &lt;td&gt;&lt;?php echo $a; ?&gt;&lt;/td&gt;        &lt;td&gt;&lt;?php echo PI; ?&gt;&lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;</code></pre><p><strong>include6.php</strong></p><pre><code class="php">&lt;?php    /*     * Create by PhpStorm     * Author: Yan     * Date: 2019/8/14     * Time: 14:58     * Features: 文件嵌套包含     */    // 文件嵌套包含    // 包含include3.php   文件本身包含了include4.php    include &#39;../../chap08/sec02/include3.php&#39;;?&gt;</code></pre><p>嵌套包含的时候就很容易出现相对路径出错的问题：相对路径会因为文件的包含而改变（./和../）：Windows下面，每一个文件夹下都有.和..的文件夹。</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数的基本概念"><a href="#函数的基本概念" class="headerlink" title="函数的基本概念"></a>函数的基本概念</h2><blockquote><p>函数：function，是一种语法结构，将实现某一个功能的代码块（多行代码）封装到一个结构中，从而实现代码的重复利用（复用）。</p></blockquote><h2 id="函数定义语法"><a href="#函数定义语法" class="headerlink" title="函数定义语法"></a>函数定义语法</h2><p>函数有几个对应的关键点：function关键字、函数名、参数（形参和实参）、函数体和返回值。</p><p>基本语法如下：      </p><pre><code>function 函数名(参数){    // 参数体    //返回值：return结果}</code></pre><p>定义函数的目的：是为了实现代码的重复利用，一个功能一个函数（简单明了）。</p><p>函数的使用：通过访问<code>函数的名字+()</code>,如果函数在定义的过程中有参数，那么在调用的时候就必须传入对应的参数。函数是一种结构不会自动运行，必须通过调用才会执行。</p><p>代码示例：    </p><pre><code class="php">&lt;?php    /*     * Create by PhpStorm     * Author: Yan     * Date: 2019/8/14     * Time: 15:31     * Features: 函数     */    // 函数    // 定义函数    function display()    {        // 函数体        echo &#39;hello world&#39;;   //没有返回值    }    //调用函数    display();?&gt;</code></pre><p>函数实在代码执行阶段，碰到函数名字的时候才会调用，不是在编译阶段。       </p><p>函数的调用特点：只要系统在内存中能够找到对应的函数，就可以执行（函数的调用可以在函数定义之前）。</p><p>函数执行的内存分析：    </p><ol><li>读取代码进入到代码段（编译：将代码变成字节码存储到内存）</li><li>根据代码逐行执行</li></ol><p>以上原因：编译和执行是分开的（先编译后执行）</p><h2 id="函数命名规范"><a href="#函数命名规范" class="headerlink" title="函数命名规范"></a>函数命名规范</h2><blockquote><p>命名规范：由字母、数字和下划线组成，但是不能以数字开头。</p></blockquote><p>函数作为一种常用的结构，一般遵循以下原则：函数通常名字代表着函数的功能，而有些功能会比较复杂，可能一个单词不足以表达，需要多个组合。</p><ol><li>驼峰法：除了左边第一个单词外，后面所有的单词首字母都大写。</li><li>下划线法：单词之间通过下划线连接，单词都是小写。</li></ol><p>函数名字：在一个脚本周期中，不允许出现同名函数（通常在一个系统开发中都不会使用同名函数）。</p><h2 id="参数详解"><a href="#参数详解" class="headerlink" title="参数详解"></a>参数详解</h2><p>函数的参数分为两种：形参和实参</p><h3 id="形参"><a href="#形参" class="headerlink" title="形参"></a>形参</h3><p>形参：形式参数，不具有实际意义的参数，是在函数定义使用的参数。</p><h3 id="实参"><a href="#实参" class="headerlink" title="实参"></a>实参</h3><p>实参：实际参数，具有实际数据意义的参数，是在函数调用时使用的参数。</p><p>形参是实参的载体：实参在调用时通常是需要传入到函数内部参与计算（运算），那么需要在函数内部去找到实际数据所在的位置才能找到数据本身：选哟实际调用的时候，将数据以实参的形式传递给形参：给形参赋值，从而使得函数内部可以用到外部数据。</p><p>代码示例：     </p><pre><code class="php">&lt;?php    /*     * Create by PhpStorm     * Author: Yan     * Date: 2019/8/14     * Time: 16:23     * Features: 函数参数     */    // 函数参数    // 定义函数    function add($arg1, $arg2)    {     //形参可以有多个，使用逗号分隔即可        //函数体：可以直接使用形参运算        echo $arg1 + $arg2;    }    // 调用函数    $num1 = 10;    add($num1, 20);   //传入得实参，可以是变量或者其他有值地表达式（变量、常量、运算符计算结果）?&gt;</code></pre><p><strong>注意</strong>      </p><ol><li>在PHP中允许实参多余形参（个数）：函数内部不用而已</li><li>在PHP中理论上形参个数没有限制（实际开发不会太多）</li><li>实参不能少于形参个数</li></ol><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><blockquote><p>默认值：default value，指的是形参的默认值，在函数定义的时候，就给形参进行一个初始赋值：如果实际调用传入的参数（实参）没有提供，那么形参就会使用定义时的值来进入函数内部参与运算。</p></blockquote><p>通常默认值是用在一些，一定会有某个数据参与，但是不可能通常是某个我们知道的值。</p><p>代码示例：     </p><pre><code class="php">&lt;?php    /*     * Create by PhpStorm     * Author: Yan     * Date: 2019/8/14     * Time: 16:23     * Features: 函数参数     */    // 函数参数    // 定义函数    function add($arg1, $arg2)    {     //形参可以有多个，使用逗号分隔即可        //函数体：可以直接使用形参运算        echo $arg1 + $arg2;    }    // 调用函数    $num1 = 10;    add($num1, 20);   //传入得实参，可以是变量或者其他有值地表达式（变量、常量、运算符计算结果）    // 函数的默认值    function jian($num1 = 0, $num2 = 0)    //当前$num1是形参，在编译时不执行，即便执行也是在jian函数内部，不会与外部的$num1变量冲突    {        echo $num1 - $num2;    }    // 调用：默认值如果存在，可以不用传入    jian($num1);    echo $num1;?&gt;</code></pre><p><strong>注意事项</strong>      </p><ol><li>默认值的定义是放在最右边的（多个），不能左边形参有默认值，但是右边没有</li></ol><p>函数外部定义的变量名字与函数定义的形参名字冲突（同名）是没有任何关联关系的，如果多个函数使用同样的形参名字也不冲突。</p><h3 id="引用传值"><a href="#引用传值" class="headerlink" title="引用传值"></a>引用传值</h3><p>实参在调用时会将值赋值给形参，那么实际上使用的方式就是一种简单的值传递：将实参（如果是变量或者常量或者其他表达式）的结果（值）取出来赋值给形参：形参参与外部实际传入的参数本身没有任何关联关系：只是结果一样。</p><p>有的时候，希望在函数内部拿到的外部数据，能够在函数内部改变，那么就需要明确告知函数（定义时），函数才会调用的时候去主动获取外部数据的内存地址。以上这种定义形式参数的方式叫做引用传值。</p><p>基本语法：</p><pre><code>function 函数名(形参1，形参2){    //函数体}</code></pre><p>在调用的时候，必须给引用传值的参数位置传入实际参数，而且参数本身必须是变量。（变量才有指向的数据的内存地址）</p><p>代码示例：     </p><pre><code class="php">&lt;?php    // 引用传值    function display($a, &amp;$b)    {        //修改形参的值        $a = $a * $a;        $b = $b * $b;        echo &#39;&lt;hr&gt;&#39;, $a, &#39;&lt;br/&gt;&#39;, $b, &#39;&lt;br/&gt;&#39;;    }    //定义变量    $a = 10;    $b = 5;    //调用函数    display($a, $b);    echo &#39;&lt;hr&gt;&#39;, $a, &#39;&lt;br/&gt;&#39;, $b, &#39;&lt;br/&gt;&#39;;    //错误调用：引用传值直接传入数据本身而不是变量    // display(10, 5);?&gt;</code></pre><p><strong>注意事项</strong>：在传入实参的时候，必须传入变量。</p><h2 id="函数体"><a href="#函数体" class="headerlink" title="函数体"></a>函数体</h2><blockquote><p>函数体：函数内部（大括号{}里面的）的所有代码都称之为函数体。<br>函数体：基本上所有的代码都可以实现</p><ol><li>定义变量 </li><li>定义常量</li><li>使用流程控制（分支、循环）</li><li>可以调用函数</li></ol></blockquote><h2 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h2><blockquote><p>返回值：return，指的是将函数实现的结果，通过return关键字，返回给函数外部（函数调用处）：在PHP中所有的函数都有返回值。（如果没有明确return使用，那么系统默认返回NULL）</p></blockquote><p>返回值作用：将计算结果返回给调用处。</p><p>代码示例：     </p><pre><code class="php">&lt;?php    /*     * Create by PhpStorm     * Author: Yan     * Date: 2019/8/15     * Time: 14:36     * Features: 函数返回值     */    // 函数返回值    // 定义函数    function display()    {        //输出        echo __FUNCTION__;   //输出当前函数名字    }    var_dump(display());    // 加法运算    function add($num1, $num2)    {        return $num1 + $num2;    //返回结果        //输出        echo $num1;    }    $res = add(10, 20);     //外部定义变量接收函数运行结果    echo $res;?&gt;</code></pre><p><strong>注意</strong>：函数的返回值可以是任意数据类型。</p><p>return关键字：      </p><ol><li>return在函数内部存在的价值：返回当前函数的结果（当前函数运行结束）。</li><li>return还可以在文件中直接使用（不在函数里面）：代表文件将结果return后面跟的内容转交给包含当前文件的位置。（通常在系统配置文件中使用较多），在文件中也代表终止文件后面的代码“return之后的内容不会执行了。</li></ol><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><blockquote><p>作用域：变量（常量）能够被访问的区域</p><ol><li>变量可以在普通代码中定义</li><li>变量也可以在函数内部定义</li></ol></blockquote><p>在PHP中作用域严格来说分为两种：但是PHP内部还定义一些在严格意义之外的一种，所以总共算三种：        </p><ol><li>全局变量：就是用户普通定义的变量（函数外部定义）<ul><li>所属全局空间：在PHP中只允许在全局空间使用：理论上函数内部不可访问</li><li>脚本周期：直到脚本运行结束（最后一行代码执行完）</li></ul></li><li>局部变量：就是在函数内部定义的变量<ul><li>所属当前函数空间：在PHP中只允许在当前函数自己内部使用</li><li>函数周期：函数执行结束（函数是在栈区中开辟独立内存空间运行）</li></ul></li><li>超全局变量：系统定义的变量（预定义变量： <code>$_SERVER</code>、<code>$_POST</code>等）<ul><li>所属超全局空间：没有访问限制（函数内外都可以访问）</li></ul></li></ol><p><strong>超全局变量会将全局变量自动纳入到<code>$GLOBALS</code>没有作用域限制，所以能够帮助局部变量去访问全局变量：但是必须使用数组方式。</strong></p><p><strong>如果想函数内部使用外部变量：除了<code>$GLOBALS</code>之外，通过参数传值（如果要统一战线还可以使用引用传值）。</strong></p><p>在PHP中，其实还有一种方式，能够实现全局访问局部，同时局部也可以访问全局：global关键字。</p><p>global关键字：是一种在函数里面定义变量的一种方式。</p><ol><li>如果使用global定义的变量名外部存在（全局变量），那么系统在函数内部定义的变量直接指向外部全局变量所指向的内存空间（同一个变量）；</li><li>如果使用global定义的变量名在外部不存在（全局变量），系统会自动在全局空间（外部）定义一个与局部变量同名的全局变量</li></ol><p>本质的形式：在函数的内部和外部，对一个同名变量（全局和局部）使用同一块内存地址保存数据，从而实现共同拥有。</p><p>基本语法：     </p><pre><code>global 变量名;      //不能赋值变量名=值;    //修改</code></pre><p>代码示例：     </p><pre><code class="php">&lt;?php    /*     * Create by PhpStorm     * Author: Yan     * Date: 2019/8/15     * Time: 16:02     * Features: 作用域     */    // PHP中作用域    // 默认的代码空间:全局空间    $global = &#39;global area&#39;;     //最终会被系统纳入到超全局空间中:$GLOBALS[]=global area    //局部变量(函数内部定义)    function display()    {        //所有的形参都可以理解为局部变量        $inner = __FUNCTION__;   //局部变量        //访问全局变量        echo $global;      //不能访问        echo &#39;&lt;hr&gt;&#39;;        // 访问全局变量        // var_dump($GLOBALS);        echo $GLOBALS[&#39;global&#39;];        echo &#39;&lt;hr&gt;&#39;;        //定义变量:使用全局变量        global $global;    //全局空间存在        echo $global;        echo &#39;&lt;hr&gt;&#39;;        //定义变量:全局不存在        global $local;        $local = &#39;inner&#39;;    }    // 调用函数    display();    //全局空间访问局部变量    echo $inner;          //不能访问    echo &#39;&lt;hr&gt;&#39;;    //访问&quot;局部&quot;变量    echo $local;    echo &#39;&lt;hr&gt;&#39;;?&gt;</code></pre><p>虽然以上方式可以实现局部与全局的互访，但是通常不会这么使用。一般如果会存在特殊使用，也会使用参数的形式来访问（还可以使用常量：define定义的）。</p><h2 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;代码仓库&quot;&gt;&lt;a href=&quot;#代码仓库&quot; class=&quot;headerlink&quot; title=&quot;代码仓库&quot;&gt;&lt;/a&gt;代码仓库&lt;/h1&gt;&lt;p&gt;仓库地址：&lt;a href=&quot;https://github.com/yanxin152133/PHP.git&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;环境&lt;/strong&gt;：      &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Apache/2.4.39 (Win64)&lt;/li&gt;
&lt;li&gt;PHP 7.3.6&lt;/li&gt;
&lt;li&gt;PhpStorm 2019.2&lt;/li&gt;
&lt;li&gt;MySQL 5.6&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;软件安装路径&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Apache &lt;strong&gt;D:\server\apache&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;PHP &lt;strong&gt;D:\server\php7&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;演示地址&quot;&gt;&lt;a href=&quot;#演示地址&quot; class=&quot;headerlink&quot; title=&quot;演示地址&quot;&gt;&lt;/a&gt;演示地址&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://139.159.236.98/php/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Demo&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;PHP手册&quot;&gt;&lt;a href=&quot;#PHP手册&quot; class=&quot;headerlink&quot; title=&quot;PHP手册&quot;&gt;&lt;/a&gt;PHP手册&lt;/h1&gt;&lt;p&gt;文件名为&lt;strong&gt;php_manual_zh.chm&lt;/strong&gt;即为PHP手册。&lt;/p&gt;
&lt;p&gt;打不开参考下面链接：    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/qq_14998713/article/details/52155834&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;解决win10中无法打开CHM文件的方法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;搭建环境（Windows）&quot;&gt;&lt;a href=&quot;#搭建环境（Windows）&quot; class=&quot;headerlink&quot; title=&quot;搭建环境（Windows）&quot;&gt;&lt;/a&gt;搭建环境（Windows）&lt;/h1&gt;&lt;h2 id=&quot;较早版本Apache-下载&quot;&gt;&lt;a href=&quot;#较早版本Apache-下载&quot; class=&quot;headerlink&quot; title=&quot;较早版本Apache 下载&quot;&gt;&lt;/a&gt;较早版本Apache 下载&lt;/h2&gt;&lt;p&gt;下载地址：&lt;a href=&quot;https://archive.apache.org/dist/httpd/binaries/win32/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Apache msi&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
      <category term="入门" scheme="http://yoursite.com/categories/PHP/%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="入门" scheme="http://yoursite.com/tags/%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>饥荒游戏服务器端搭建</title>
    <link href="http://yoursite.com/2019/07/29/%E9%A5%A5%E8%8D%92%E6%B8%B8%E6%88%8F%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2019/07/29/饥荒游戏服务器端搭建/</id>
    <published>2019-07-29T10:20:26.091Z</published>
    <updated>2019-08-02T12:18:10.401Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux服务器要求"><a href="#Linux服务器要求" class="headerlink" title="Linux服务器要求"></a>Linux服务器要求</h1><ul><li>上行带宽：8KBps 一个玩家；</li><li>内存：差不多一个玩家 65Mbytes；</li><li>CPU：没太大要求</li></ul><a id="more"></a><h1 id="服务器端口开放"><a href="#服务器端口开放" class="headerlink" title="服务器端口开放"></a>服务器端口开放</h1><p><strong>默认情况下，服务器在端口10999上使用UDP流量</strong></p><p>因此需要将服务器的10999端口进行开放</p><h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><p>为了防止内存不足，开启SWAP。</p><ul><li>首先确认SWAP设置了多少 </li></ul><pre><code class="bash">free -m</code></pre><ul><li>如果觉得不满意其空间大小，则对SWAP进行删除</li></ul><pre><code class="bash">swapoff -a</code></pre><ul><li>新增SWAP分区</li></ul><pre><code class="bash">dd if=/dev/zero of=/root/swapfile bs=1M count=1024  #1024大小可根据自己情况进行更改</code></pre><ul><li>格式化交换分区文件</li></ul><pre><code class="bash">mkswap /root/swapfile</code></pre><ul><li>启用swap分区文件</li></ul><pre><code class="bash">swapon /root/swapfile</code></pre><ul><li>添加开机启动</li></ul><pre><code class="bash">vi /etc/fstab</code></pre><p>这里提一下vi编辑器的基本用法：<br>进入文本后按键盘上的insert按钮开始编辑，按esc退出编辑，输入:wq保存并退出。           </p><ol><li>添加或修改</li></ol><pre><code class="bash">/root/swapfile swap swap defaults 0 0</code></pre><ol start="2"><li>重启下是否生效</li></ol><pre><code class="bash">reboot</code></pre><ol start="3"><li>重启后输入指令查看下SWAP是否增加</li></ol><pre><code class="bash">free -m</code></pre><h1 id="依赖安装"><a href="#依赖安装" class="headerlink" title="依赖安装"></a>依赖安装</h1><pre><code class="bash"># Ubuntu$ sudo apt-get install libstdc++6:i386 libgcc1:i386 libcurl4-gnutls-dev:i386 lib32gcc1# CentOS(仅供参考)$ yum -y install glibc.i686 libstdc++.i686 libcurl4-gnutls-dev.i686 libcurl.i686</code></pre><h1 id="安装-SteamCMD"><a href="#安装-SteamCMD" class="headerlink" title="安装 SteamCMD"></a>安装 SteamCMD</h1><p>SteamCMD，顾名思义，就是 Steam 的命令行版本。虽然饥荒服务器本身并不需要用 Steam 进行验证啊之类的，但我们还是得用它来把服务器更新到最新版本，不然其他人是进不来的。</p><p>我们最好新建一个用户来运行 SteamCMD，如果直接用 root 用户运行游戏服务端的话可能会导致严重的安全隐患。在 root 权限下使用以下命令来创建一个新用户： </p><pre><code class="bash">$ useradd -m steam$ su - steam</code></pre><p>然后在你喜欢的地方创建一个为 SteamCMD 准备的目录：</p><pre><code class="bash">$ mkdir ~/steamcmd  ## 创建目录$ cd ~/steamcmd  ## 进入该目录</code></pre><p>下载并解压 Linux 专用的 SteamCMD：</p><pre><code class="bash">$ wget https://steamcdn-a.akamaihd.net/client/installer/steamcmd_linux.tar.gz  ##  下载$ tar -xvzf steamcmd_linux.tar.gz  ## 解压</code></pre><p>运行 SteamCMD：</p><pre><code class="bash">$ ./steamcmd.sh</code></pre><p>登录安装退出操作：</p><pre><code class="bash"># 匿名登录，没必要用用户名密码登录login anonymous# 这里我们强制要 Steam 把饥荒服务端安装到此目录下# 最好用绝对路径，否则可能会安装到奇怪的地方去force_install_dir ../dontstarvetogether_dedicated_serverapp_update 343050 validatequit</code></pre><p>安装完成后，使用 quit 命令退出 steam 程序。</p><ul><li>成功安装所出现的标志：</li></ul><pre><code class="bash">Success! App &#39;343050&#39; fully installed.</code></pre><h1 id="通过客户端获取配置文件"><a href="#通过客户端获取配置文件" class="headerlink" title="通过客户端获取配置文件"></a>通过客户端获取配置文件</h1><h2 id="服务器端配置文件位置及相关操作"><a href="#服务器端配置文件位置及相关操作" class="headerlink" title="服务器端配置文件位置及相关操作"></a>服务器端配置文件位置及相关操作</h2><p>饥荒的配置目录位于: <strong>~/.klei/DoNotStarveTogether</strong></p><p>然后手动创建一个存档目录：     </p><pre><code class="bash">mkdir -p ~/.klei/DoNotStarveTogether/MyDediServer</code></pre><h2 id="利用客户端创建世界"><a href="#利用客户端创建世界" class="headerlink" title="利用客户端创建世界"></a>利用客户端创建世界</h2><ol><li>进入游戏</li><li>创建自己的世界，设置可自定应。</li><li>以 Windows 为例（Linux/Mac 类似），存档位置位于 <strong>/Users/username/Documents/Klei/DoNotStarveTogether</strong>，也就是文档目录下。</li><li>在该目录的下一级目录中，在一个<strong>全是数字的文件夹</strong>中有一个命名为 Cluster_X 的文件夹（X 为数字编号），提取出刚刚创建的存档。</li></ol><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p><strong>cluster.ini</strong></p><p>修改<strong>bind_ip</strong>和<strong>master_ip</strong>内容       </p><pre><code>[SHARD]shard_enabled = truebind_ip = 0.0.0.0 master_ip = 你的主服务器的 IP </code></pre><h2 id="Mod"><a href="#Mod" class="headerlink" title="Mod"></a>Mod</h2><p>进入到服务器的的饥荒安装目录：</p><pre><code class="bash">cd ~/dontstarvetogether_dedicated_server/mods</code></pre><p>修改该目录下的 dedicated_server_mods_setup.lua 文件：</p><pre><code class="bash">vim dedicated_server_mods_setup.lua # 在该文件中添加类似这样的内容，这串 ID 是 Mod 文件在 Steam 中的 ID# 可以在提取到的配置文件的 Master/modoverrides.lua 中找到# 然后添加到本文件中，一行一个ServerModSetup(&quot;362175979&quot;)</code></pre><p>本教程模板：    </p><pre><code class="lua">ServerModSetup(&quot;1089344410&quot;)ServerModSetup(&quot;1146082006&quot;)ServerModSetup(&quot;1200745268&quot;)ServerModSetup(&quot;1207269058&quot;)ServerModSetup(&quot;1290228121&quot;)ServerModSetup(&quot;1301033176&quot;)ServerModSetup(&quot;352499675&quot;)ServerModSetup(&quot;362175979&quot;)ServerModSetup(&quot;375850593&quot;)ServerModSetup(&quot;378160973&quot;)ServerModSetup(&quot;380423963&quot;)ServerModSetup(&quot;444235588&quot;)ServerModSetup(&quot;458587300&quot;)ServerModSetup(&quot;462434129&quot;)ServerModSetup(&quot;488009136&quot;)ServerModSetup(&quot;577104313&quot;)ServerModSetup(&quot;622448972&quot;)ServerModSetup(&quot;666155465&quot;)ServerModSetup(&quot;682721879&quot;)ServerModSetup(&quot;785295023&quot;)ServerModSetup(&quot;841471368&quot;)ServerModSetup(&quot;892478248&quot;)ServerModSetup(&quot;934638020&quot;)</code></pre><h2 id="上传配置文件"><a href="#上传配置文件" class="headerlink" title="上传配置文件"></a>上传配置文件</h2><p>将配置文件上传到 <strong>~/.klei/DoNotStarveTogether/MyDediServer</strong>下</p><p>Linux传输文件可参考链接：     </p><ul><li><a href="https://www.runoob.com/linux/linux-comm-scp.html" target="_blank" rel="noopener">Linux scp命令</a></li><li><a href="https://blog.csdn.net/chenjianqi0502/article/details/69943915" target="_blank" rel="noopener">Linux下如何将一个用户下的文件拷贝到另一个用户里</a></li><li><a href="https://www.cnblogs.com/dump/p/7716823.html" target="_blank" rel="noopener">Linux中zip压缩和unzip解压缩命令详解</a></li></ul><h1 id="配置user-id和自己的token"><a href="#配置user-id和自己的token" class="headerlink" title="配置user_id和自己的token"></a>配置user_id和自己的token</h1><p>搭建服务器需要相关的管理人员以及相关token文件</p><ol><li><p>获取相关文件<br>进入 <a href="https://accounts.klei.com/account/info" target="_blank" rel="noopener">https://accounts.klei.com/account/info</a>  该链接</p></li><li><p>按图中步骤进行操作<br>首先获取用户id,下图中的箭头所指的即是用户id，复制之后作为设置管理员文件的信息。</p></li></ol><p><img src="https://live.staticflickr.com/65535/48404433496_87c7015b3f_z.jpg" alt></p><p>点击 <strong>导航栏</strong> – <strong>游戏</strong> – <strong>Don’t Starve Together Server</strong></p><p><img src="https://live.staticflickr.com/65535/48404433451_ba62f3135c_z.jpg" alt></p><p>下图中三个箭头所指的东西任选其一即可，同时最下方也可以支持添加。复制作为token。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://live.staticflickr.com/65535/48404582862_0cc950201d_z.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure></p><ol start="3"><li>编辑相关文件<br>先新建 cluster_token.txt 文件，再将此前获取到的 Token 复制到文件中。</li></ol><pre><code class="bash">touch cluster_token.txt</code></pre><p>再新建 adminlist.txt 文件，再将此前获取到的 UserID 复制到文件中。</p><pre><code class="bash">touch adminlist.txt</code></pre><h1 id="启动游戏"><a href="#启动游戏" class="headerlink" title="启动游戏"></a>启动游戏</h1><h2 id="启动脚本"><a href="#启动脚本" class="headerlink" title="启动脚本"></a>启动脚本</h2><p>创建脚本文件:</p><pre><code class="bash">cd ~ &amp;&amp; touch startDST.sh</code></pre><p>编辑脚本文件:</p><pre><code class="bash">#!/bin/bashsteamcmd_dir=&quot;$HOME/steamcmd&quot;install_dir=&quot;$HOME/dontstarvetogether_dedicated_server&quot;cluster_name=&quot;MyDediServer&quot;dontstarve_dir=&quot;$HOME/.klei/DoNotStarveTogether&quot;cd &quot;$install_dir/bin&quot;run_shared=(./dontstarve_dedicated_server_nullrenderer)run_shared+=(-console)run_shared+=(-cluster &quot;$cluster_name&quot;)run_shared+=(-monitor_parent_process $$)&quot;${run_shared[@]}&quot; -shard Caves  | sed &#39;s/^/Caves:  /&#39; &amp;&quot;${run_shared[@]}&quot; -shard Master | sed &#39;s/^/Master: /&#39;</code></pre><p>给启动脚本添加权限：</p><pre><code class="bash">chmod +x ./startDST.sh</code></pre><p>运行：    </p><pre><code class="bash">./startDST.sh</code></pre><h1 id="更新游戏版本"><a href="#更新游戏版本" class="headerlink" title="更新游戏版本"></a>更新游戏版本</h1><p>创建脚本文件：    </p><pre><code class="bash">cd ~ &amp;&amp; touch updateDST.sh</code></pre><p>编辑脚本文件：    </p><pre><code class="bash">#!/bin/bashsteamcmd_dir=&quot;$HOME/steamcmd&quot;## 检查并更新更新游戏版本cd &quot;$steamcmd_dir&quot;./steamcmd.sh +@ShutdownOnFailedCommand 1 +@NoPromptForPassword 1 +login anonymous +force_install_dir ../dontstarvetogether_dedicated_server +app_update 343050 validate +quit</code></pre><p>给脚本添加权限：    </p><pre><code class="bash">chmod +x ./startDST.sh</code></pre><h1 id="模板下载"><a href="#模板下载" class="headerlink" title="模板下载"></a>模板下载</h1><p>下载地址： <a href="https://github.com/yanxin152133/DST" target="_blank" rel="noopener">DST服务器搭建</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux服务器要求&quot;&gt;&lt;a href=&quot;#Linux服务器要求&quot; class=&quot;headerlink&quot; title=&quot;Linux服务器要求&quot;&gt;&lt;/a&gt;Linux服务器要求&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;上行带宽：8KBps 一个玩家；&lt;/li&gt;
&lt;li&gt;内存：差不多一个玩家 65Mbytes；&lt;/li&gt;
&lt;li&gt;CPU：没太大要求&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="游戏" scheme="http://yoursite.com/categories/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="饥荒" scheme="http://yoursite.com/categories/%E6%B8%B8%E6%88%8F/%E9%A5%A5%E8%8D%92/"/>
    
    
      <category term="游戏" scheme="http://yoursite.com/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="饥荒" scheme="http://yoursite.com/tags/%E9%A5%A5%E8%8D%92/"/>
    
  </entry>
  
  <entry>
    <title>解决git clone速度慢的问题</title>
    <link href="http://yoursite.com/2019/07/16/%E8%A7%A3%E5%86%B3git%20clone%E9%80%9F%E5%BA%A6%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/07/16/解决git clone速度慢的问题/</id>
    <published>2019-07-16T12:12:59.244Z</published>
    <updated>2019-07-17T07:05:14.312Z</updated>
    
    <content type="html"><![CDATA[<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><a id="more"></a><h2 id="1-在git内部设置代理"><a href="#1-在git内部设置代理" class="headerlink" title="1. 在git内部设置代理"></a>1. 在git内部设置代理</h2><ul><li>命令行</li></ul><pre><code class="bash">git config --global http.proxy socks5://127.0.0.1:1080git config --global https.proxy socks5://127.0.0.1:1080</code></pre><ul><li>直接编辑相关文件</li></ul><p><strong>C:\Users\用户名</strong>文件夹下的 <strong>.gitconfig</strong>,点击打开。<br>将以下内容添加进去。    </p><pre><code class="properties">[http]    proxy = socks5://127.0.0.1:1080[https]    proxy = socks5://127.0.0.1:1080</code></pre><h2 id="2-注意下载时是否是https"><a href="#2-注意下载时是否是https" class="headerlink" title="2. 注意下载时是否是https"></a>2. 注意<strong>下载时是否是https</strong></h2><h2 id="3-在使用代理下载时，会遇到git-push需要每次输入密码。"><a href="#3-在使用代理下载时，会遇到git-push需要每次输入密码。" class="headerlink" title="3. 在使用代理下载时，会遇到git push需要每次输入密码。"></a>3. 在使用代理下载时，会遇到git push需要每次输入密码。</h2><p>通过以下方式解决该问题。      </p><ul><li><p>设置记住密码（默认15分钟）：</p><pre><code class="bash">git config --global credential.helper cache</code></pre></li><li><p>如果想自己设置时间，可以这样做：</p><pre><code class="bash">git config credential.helper &#39;cache --timeout=3600&#39;</code></pre><p>这样就设置一个小时之后失效</p></li><li><p>长期存储密码：</p><pre><code class="bash">git config --global credential.helper store</code></pre></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://juejin.im/post/5a6c7806f265da3e355b4d1d" target="_blank" rel="noopener">提高 git clone 速度</a></li><li><a href="https://blog.csdn.net/hanqingsong412/article/details/50464465" target="_blank" rel="noopener">git设置代理、记住密码</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;解决方案&quot;&gt;&lt;a href=&quot;#解决方案&quot; class=&quot;headerlink&quot; title=&quot;解决方案&quot;&gt;&lt;/a&gt;解决方案&lt;/h1&gt;
    
    </summary>
    
      <category term="git" scheme="http://yoursite.com/categories/git/"/>
    
      <category term="git clone速度慢" scheme="http://yoursite.com/categories/git/git-clone%E9%80%9F%E5%BA%A6%E6%85%A2/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
      <category term="git clone速度慢" scheme="http://yoursite.com/tags/git-clone%E9%80%9F%E5%BA%A6%E6%85%A2/"/>
    
  </entry>
  
  <entry>
    <title>Java基础</title>
    <link href="http://yoursite.com/2019/07/14/java%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2019/07/14/java基础/</id>
    <published>2019-07-14T13:17:20.148Z</published>
    <updated>2019-08-07T14:16:17.537Z</updated>
    
    <content type="html"><![CDATA[<h1 id="代码仓库地址"><a href="#代码仓库地址" class="headerlink" title="代码仓库地址"></a>代码仓库地址</h1><p>欢迎下载：<a href="https://github.com/yanxin152133/java" target="_blank" rel="noopener">GitHub</a></p><p>运行环境：    </p><ul><li>IntelliJ IDEA 2019.1.3(Ultimate Edition)</li><li>jdk 1.8.0_211</li></ul><h1 id="Java8手册"><a href="#Java8手册" class="headerlink" title="Java8手册"></a>Java8手册</h1><p>文件名为<strong>jdk1.8.CHM</strong>即为Java8手册。</p><p>打不开参考下面链接：    </p><ul><li><a href="https://blog.csdn.net/qq_14998713/article/details/52155834" target="_blank" rel="noopener">解决win10中无法打开CHM文件的方法</a></li></ul><h1 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h1><h1 id="Java简介"><a href="#Java简介" class="headerlink" title="Java简介"></a>Java简介</h1><a id="more"></a><p>Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程。      </p><p>Java具有简单性、面向对象、分布式、健壮性、安全性、平台独立与可移植性、多线程、动态性等特点 。Java可以编写桌面应用程序、Web应用程序、分布式系统和嵌入式系统应用程序等。</p><p><a href="https://baike.baidu.com/item/Java/85979?fr=aladdin" target="_blank" rel="noopener">详情</a></p><h1 id="运行环境搭建"><a href="#运行环境搭建" class="headerlink" title="运行环境搭建"></a>运行环境搭建</h1><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>JDK建议使用1.8及以上的版本。<br>官方下载路径：<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">jdk下载路地址</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>双击下载软件，一路单击下一步即可。     </p><h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p><strong>Windows</strong>：右击【我的电脑】→【属性】→【高级系统设置】→【环境变量】→【系统变量】→【新建】，接着如下图所示：<br><img src="https://farm8.staticflickr.com/7873/40480682053_903c92b01b_b.jpg" alt="java_home"></p><p>在【系统变量】的path中添加 <strong>%JAVA_HOME%\bin</strong>。</p><p>验证，如下图所示：<br><img src="https://farm8.staticflickr.com/7860/40480681993_9a639b1dc2_b.jpg" alt="java"></p><h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><pre><code class="java">public class helloworld {    public static void main(String[] args) {        System.out.println(&quot;helloworld&quot;);    }}</code></pre><h2 id="Hello-World-运行原理"><a href="#Hello-World-运行原理" class="headerlink" title="Hello World 运行原理"></a>Hello World 运行原理</h2><div id="flowchart-0" class="flow-chart"></div><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><h2 id="Intellij-IDEA"><a href="#Intellij-IDEA" class="headerlink" title="Intellij IDEA"></a>Intellij IDEA</h2><p>下载路径：<a href="https://www.jetbrains.com/idea/download/download-thanks.html?platform=windows" target="_blank" rel="noopener">indea U</a></p><h3 id="激活（针对学生的免费使用计划）"><a href="#激活（针对学生的免费使用计划）" class="headerlink" title="激活（针对学生的免费使用计划）"></a>激活（针对学生的免费使用计划）</h3><p>参考：<a href="https://blog.csdn.net/iemdm1110/article/details/53365881" target="_blank" rel="noopener">Intellij IDEA的下载和使用（针对学生的免费使用计划）</a></p><h1 id="注释、标识符命名规则及Java中的关键字"><a href="#注释、标识符命名规则及Java中的关键字" class="headerlink" title="注释、标识符命名规则及Java中的关键字"></a>注释、标识符命名规则及Java中的关键字</h1><h2 id="1-Java注释"><a href="#1-Java注释" class="headerlink" title="1. Java注释"></a>1. Java注释</h2><pre><code>1. 单行注释：//2. 多行注释：/*。。。。。*/3. 文档注释：/**。。。*/</code></pre><h2 id="2-标识符命名"><a href="#2-标识符命名" class="headerlink" title="2. 标识符命名"></a>2. 标识符命名</h2><pre><code>标识符定义：Java语言中，对于变量、常量、函数、语句块也有名字，我们统统称为Java标识符。标识符作用：标识符是用来给类、对象、方法、常量、接口和自定义数据类型命令的。标识符命名规则：Java标识符由数字、字母和下划线（_），美元符号（$）组成。在Java中是区分大小写的，而且还要求首位不能是数字。最重要的是，Java关键字不能当作Java标识符。</code></pre><h2 id="3-Java关键字"><a href="#3-Java关键字" class="headerlink" title="3. Java关键字"></a>3. Java关键字</h2><table><thead><tr><th><strong>访问控制</strong></th><th><strong>private</strong></th><th><strong>protected</strong></th><th><strong>public</strong></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td><strong>类，方法和变量修饰符</strong></td><td><strong>abstract</strong></td><td><strong>class</strong></td><td><strong>extends</strong></td><td><strong>final</strong></td><td><strong>implements</strong></td><td><strong>interface</strong></td><td><strong>native</strong></td></tr><tr><td></td><td><strong>new</strong></td><td><strong>static</strong></td><td><strong>strictfp</strong></td><td><strong>synchronized</strong></td><td><strong>transient</strong></td><td><strong>volatile</strong></td><td></td></tr><tr><td><strong>程序控制</strong></td><td><strong>break</strong></td><td><strong>continue</strong></td><td><strong>return</strong></td><td><strong>do</strong></td><td><strong>while</strong></td><td><strong>if</strong></td><td><strong>else</strong></td></tr><tr><td></td><td><strong>for</strong></td><td><strong>instanceof</strong></td><td><strong>switch</strong></td><td><strong>case</strong></td><td><strong>default</strong></td><td></td><td></td></tr><tr><td><strong>错误处理</strong></td><td><strong>try</strong></td><td><strong>catch</strong></td><td><strong>throw</strong></td><td><strong>throws</strong></td><td><strong>finally</strong></td><td></td><td></td></tr><tr><td><strong>包相关</strong></td><td><strong>import</strong></td><td><strong>package</strong></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><strong>基本类型</strong></td><td><strong>boolean</strong></td><td><strong>byte</strong></td><td><strong>char</strong></td><td><strong>double</strong></td><td><strong>float</strong></td><td><strong>int</strong></td><td><strong>long</strong></td></tr><tr><td></td><td><strong>short</strong></td><td><strong>null</strong></td><td><strong>true</strong></td><td><strong>false</strong></td><td></td><td></td><td></td></tr><tr><td><strong>变量引用</strong></td><td><strong>super</strong></td><td><strong>this</strong></td><td><strong>void</strong></td><td></td><td></td><td></td><td></td></tr><tr><td><strong>保留字</strong></td><td><strong>goto</strong></td><td><strong>const</strong></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>参考：<a href="http://cyw3.github.io/YalesonChan/2016/Java-key.html" target="_blank" rel="noopener">Java 关键字总结</a>                    </p><h1 id="Java基本数据类型"><a href="#Java基本数据类型" class="headerlink" title="Java基本数据类型"></a>Java基本数据类型</h1><h2 id="1-数据类型分类"><a href="#1-数据类型分类" class="headerlink" title="1. 数据类型分类"></a>1. 数据类型分类</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://live.staticflickr.com/65535/48287266636_32ed239f62_z.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="2-整数类型"><a href="#2-整数类型" class="headerlink" title="2. 整数类型"></a>2. 整数类型</h2><table><thead><tr><th>序号</th><th>数据类型</th><th>大小/位</th><th>可表示的数据范围</th></tr></thead><tbody><tr><td>1</td><td>byte(位)</td><td>8</td><td>-2<sup>7</sup>到（2<sup>6</sup>-1）</td></tr><tr><td>2</td><td>short(整型)</td><td>16</td><td>-2<sup>15</sup>到（2<sup>15</sup>-1）</td></tr><tr><td>3</td><td>int(整型)</td><td>32</td><td>-2<sup>31</sup>到（2<sup>31</sup>-1）</td></tr><tr><td>4</td><td>long(长整型)</td><td>64</td><td>-2<sup>63</sup>到（2<sup>63</sup>-1）</td></tr></tbody></table><p>Byte数据范围表示   </p><table><thead><tr><th>符号位</th><th>1</th><th>1</th><th>1</th><th>1</th><th>1</th><th>1</th><th>1</th><th>1</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>符号位0表示正   范围  00000000~01111111<br>符号位1表示负   范围  10000000~11111111（减一取反）</p><p>代码实例：    </p><pre><code class="java">package com.java.chap03;/** * @author Yan * @date 2019/7/16 13:52 */public class Demo1 {    public static void main(String[] args) {        //定义一个int类型的变量        int a;        //给变量a赋值        a=1;        System.out.println(a);        //定义一个int类型的变量a2        int a2=1;        System.out.println(&quot;a2=&quot;+a2);        //定义一个byte类型的变量b        byte b=3;        System.out.println(&quot;b=&quot;+b);        //定义一个short类型的变量        short s=4;        System.out.println(&quot;s=&quot;+s);        //定义一个long类型的变量l        long l=5;        System.out.println(&quot;l=&quot;+l);        int a11=1;        int a22=2;        int a3=a11+a22;        System.out.println(&quot;a1+a2=&quot;+a3);    }}</code></pre><h2 id="3-浮点类型"><a href="#3-浮点类型" class="headerlink" title="3. 浮点类型"></a>3. 浮点类型</h2><table><thead><tr><th>序号</th><th>数据类型</th><th>大小/位</th><th>可表示的数据范围</th></tr></thead><tbody><tr><td>1</td><td>float(单精度)</td><td>32</td><td>-3.4E38(-3.4x10<sup>38</sup>) 到 3.4E38(3.4x10<sup>38</sup>))</td></tr><tr><td>2</td><td>double(双精度)</td><td>64</td><td>-1.7E308(-1.7x10<sup>308</sup>) 到 1.7E308(1.7x10<sup>308</sup>))</td></tr></tbody></table><p>代码示例：       </p><pre><code class="java">package com.java.chap03;/** * @author Yan * @date 2019/7/16 13:53 */public class Demo2 {    public static void main(String[] args) {        //定义一个float类型的变量f        //小数默认是double类型，所以必须加一个f,来表示float类型        float f=1.1f;        System.out.println(&quot;f=&quot;+f);        //定义一个double类型变量d        double d=1.2;        System.out.println(&quot;d=&quot;+d);        //获取float的最大值        float maxF=Float.MAX_VALUE;        System.out.println(&quot;float最大值：&quot;+maxF);        //获取float的最小值        float minF=Float.MIN_VALUE;        System.out.println(&quot;float最小值：&quot;+minF);    }}</code></pre><h2 id="4-字符型"><a href="#4-字符型" class="headerlink" title="4. 字符型"></a>4. 字符型</h2><p>字符型常量有3种表示形式。char     </p><pre><code>1. 直接通过单个字符来指定字符型常量，如‘A’，‘b’，‘5’；2. 通过转义字符表示特殊字符型常量，如‘\n’,‘\\’;3. 直接使用Unicode值来表示字符型常量，如‘\u66f9’，‘\yu950b’；</code></pre><table><thead><tr><th>转义字符</th><th>说明</th></tr></thead><tbody><tr><td>\b</td><td>退格</td></tr><tr><td>\n</td><td>换行</td></tr><tr><td>\t</td><td>制表符</td></tr><tr><td>\”</td><td>双引号</td></tr><tr><td>\’</td><td>单引号</td></tr><tr><td>\</td><td>反斜杠</td></tr><tr><td>\r</td><td>回车符</td></tr></tbody></table><p>代码示例:        </p><pre><code class="java">package com.java.chap03;/** * @author Yan * @date 2019/7/16 13:53 */public class Demo3 {    public static void main(String[] args) {        //定义一个单个字符        char c1=&#39;A&#39;;        System.out.println(&quot;c1=&quot;+c1);        //定义一个反斜杠字符        char c2=&#39;\\&#39;;        System.out.println(&quot;c2=&quot;+c2);        //用Unicode编码输出自己的名字        char c3=&#39;\u66f9&#39;;        char c4=&#39;\u950b&#39;;        System.out.println(&quot;c3=&quot;+c3);        System.out.println(&quot;c4=&quot;+c4);    }}</code></pre><h2 id="5-布尔类型"><a href="#5-布尔类型" class="headerlink" title="5. 布尔类型"></a>5. 布尔类型</h2><p>布尔类型的变量只有true(真)和false(假)两种。  </p><pre><code class="java">package com.java.chap03;/** * @author Yan * @date 2019/7/16 13:53 */public class Demo4 {    public static void main(String[] args) {        //定义一个布尔类型变量b1        boolean b1=true;        System.out.println(&quot;b1=&quot;+b1);        //定义一个布尔类型变量b2        boolean b2=false;        System.out.println(&quot;b2=&quot;+b2);    }}</code></pre><h2 id="6-基本类型的类型转换"><a href="#6-基本类型的类型转换" class="headerlink" title="6. 基本类型的类型转换"></a>6. 基本类型的类型转换</h2><pre><code>1. 自动类型转换条件：      1. 转换前后的数据类型兼容；     2. 转换后的数据类型的表示范围要比转换前的大；2. 强制类型转换</code></pre><p>代码示例：    </p><pre><code class="java">package com.java.chap03;/** * @author Yan * @date 2019/7/16 13:53 */public class Demo5 {    public static void main(String[] args) {        //自动类型转换        short s=1;        int i;        //自动类型转换 short类型转成int类型        i=s;        System.out.println(&quot;i=&quot;+i);        //强制类型转换        double d=1.333;        float f;        //把double类型的数据强制转换成float类型        f=(float) d;        System.out.println(&quot;f=&quot;+f);    }}</code></pre><h1 id="Java运算符与表达式"><a href="#Java运算符与表达式" class="headerlink" title="Java运算符与表达式"></a>Java运算符与表达式</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://live.staticflickr.com/65535/48287869506_1ed621abc2_z.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="1-赋值运算符"><a href="#1-赋值运算符" class="headerlink" title="1. 赋值运算符"></a>1. 赋值运算符</h2><p>符号：=（赋值）</p><pre><code class="java">package com.java.chap04;/** * @author Yan * @date 2019/7/16 13:01 */public class Demo1 {    public static void main(String[] args) {        //定义变量a        int a;        //给变量a赋值        a=1;        System.out.println(&quot;a=&quot;+a);        //定义变量a，并且给a赋值        int a2=2;        System.out.println(&quot;a2=&quot;+a2);    }}</code></pre><h2 id="2-算数运算符"><a href="#2-算数运算符" class="headerlink" title="2. 算数运算符"></a>2. 算数运算符</h2><p>符号：+（加），-（减），*（乘），/（除），%（取模）</p><pre><code class="java">package com.java.chap04;/** * @author Yan * @date 2019/7/16 13:07 */public class Demo2 {    public static void main(String[] args) {        int a=10;        int b=3;        //+运算符        System.out.println(a+&quot;+&quot;+b+&quot;=&quot;+(a+b));        //-运算符        System.out.println(a+&quot;-&quot;+b+&quot;=&quot;+(a-b));        //*运算符        System.out.println(a+&quot;*&quot;+b+&quot;=&quot;+(a*b));        // /运算符        System.out.println(a+&quot;/&quot;+b+&quot;=&quot;+(a/b));        //%运算符        System.out.println(a+&quot;%&quot;+b+&quot;=&quot;+(a%b));    }}</code></pre><h2 id="3-自增与自减运算符"><a href="#3-自增与自减运算符" class="headerlink" title="3. 自增与自减运算符"></a>3. 自增与自减运算符</h2><p>符号：++（自增），–（自减）<br><strong>重点：a++和++a的区别</strong></p><pre><code class="java">package com.java.chap04;/** * @author Yan * @date 2019/7/16 13:13 */public class Demo3 {    public static void main(String[] args) {        int a = 1;        //a++表示先做赋值操作，然后自增        /*        int b=a++;        System.out.println(&quot;b=&quot;+b);        System.out.println(&quot;a=&quot;+a);         */        //++a表示先自增，然后赋值操作        int b=++a;        System.out.println(&quot;b=&quot;+b);        System.out.println(&quot;a=&quot;+a);    }}</code></pre><h2 id="4-逻辑运算符"><a href="#4-逻辑运算符" class="headerlink" title="4. 逻辑运算符"></a>4. 逻辑运算符</h2><p>符号：&amp;&amp;（与），&amp;（不短路与），||（或），|（不短路或），!(非)，^（亦或）</p><pre><code class="java">package com.java.chap04;/** * @author Yan * @date 2019/7/16 13:53 */public class Demo4 {    public static void main(String[] args) {        // &amp;&amp; 与  前后两个操作数必须都是true才返回true，否则返回false        boolean b1 = (5 &lt; 3) &amp;&amp; (4 &gt; 5);        System.out.println(&quot;b1 = &quot; + b1);        //&amp; 不短路与        boolean b2 = (5 &lt; 3) &amp; (4 &gt; 5);        System.out.println(&quot;b2 = &quot; + b2);        //一般都使用 &amp;&amp;        //原因：效率高        // || 或 只要两个操作数中有一个是true，就返回true，否则返回false        boolean b3 = (2 &lt; 3) || (4 &gt; 5);        System.out.println(&quot;b3 = &quot; + b3);        // | 不短路或        boolean b4 = (2 &lt; 3) | (4 &gt; 5);        System.out.println(&quot;b4 = &quot; + b4);        // ! 非，如果操作数为true，返回false，否则返回true        boolean b5 = !(3 &lt; 4);        System.out.println(&quot;b5 = &quot; + b5);        // ^ 异或 当两个操作数不相同时，返回true，否则返回false        boolean b6 = (5 &gt; 4) ^ (4 &gt; 5);        System.out.println(&quot;b6 = &quot; + b6);    }}</code></pre><h2 id="5-关系运算符"><a href="#5-关系运算符" class="headerlink" title="5. 关系运算符"></a>5. 关系运算符</h2><p>符号：&gt;(大于)，&lt;(小于)，&gt;=（大于等于），&lt;=(小于等于)，==（等于），!=(不等于)</p><pre><code class="java">package com.java.chap04;/** * @author Yan * @date 2019/7/16 14:22 */public class Demo5 {    public static void main(String[] args) {        int a = 2;        int b = 3;        // &gt; 大于        System.out.println(a + &quot;&gt;&quot; + b + &quot;:&quot; + (a &gt; b));        // &lt; 小于        System.out.println(a + &quot;&lt;&quot; + b + &quot;:&quot; + (a &lt; b));        // &gt;= 大于等于        System.out.println(a + &quot;&gt;=&quot; + b + &quot;:&quot; + (a &gt;= b));        // &lt;= 小于等于        System.out.println(a + &quot;&lt;=&quot; + b + &quot;:&quot; + (a &lt;= b));        // == 等于        System.out.println(a + &quot;==&quot; + b + &quot;:&quot; + (a == b));        // != 不等于        System.out.println(a + &quot;!=&quot; + b + &quot;:&quot; + (a != b));    }}</code></pre><h2 id="6-三目运算符"><a href="#6-三目运算符" class="headerlink" title="6. 三目运算符"></a>6. 三目运算符</h2><p>格式：（表达式）？表达式为true返回值A：表达式为false返回值B</p><pre><code class="java">package com.java.chap04;/** * @author Yan * @date 2019/7/16 14:26 */public class Demo6 {    public static void main(String[] args) {        //三目运算符        String s=2&gt;3?&quot;表达式为真&quot;:&quot;表达式为假&quot;;        System.out.println(&quot;s = &quot; + s);    }}</code></pre><h1 id="Java选择与循环语句"><a href="#Java选择与循环语句" class="headerlink" title="Java选择与循环语句"></a>Java选择与循环语句</h1><h2 id="1-程序的选择结构"><a href="#1-程序的选择结构" class="headerlink" title="1. 程序的选择结构"></a>1. 程序的选择结构</h2><pre><code>1. if 语句2. if...else 语句3. if...else if...else 语句</code></pre><pre><code class="java">package com.java.chap05;/** * @author Yan * @date 2019/7/16 15:16 */public class Demo1 {    public static void main(String[] args) {        int a=-1;        // if语句        if (a&gt;0){            System.out.println(a+&quot;是正数&quot;);        }        //if...else语句        if (a&gt;0){            System.out.println(a+&quot;是正数&quot;);        }else {            System.out.println(a+&quot;不是正数&quot;);        }        //if...else if...else        if (a&gt;0){            System.out.println(a+&quot;是正数&quot;);        }else if (a&lt;0){            System.out.println(a+&quot;是负数&quot;);        }else{            System.out.println(a+&quot;是0&quot;);        }    }}</code></pre><pre><code>4. switch 语句</code></pre><pre><code class="java">package com.java.chap05;import java.util.Scanner;/** * @author Yan * @date 2019/7/16 15:22 */public class Demo2 {    public static void main(String[] args) {        System.out.println(&quot;请输入一个数字&quot;);        //定义一个系统输入对象        Scanner scanner=new Scanner(System.in);        int n=scanner.nextInt();        //System.out.println(n);        switch (n){            case 1:{                System.out.println(&quot;用户输入的是1&quot;);                break;            }            case 2:{                System.out.println(&quot;用户输入的是2&quot;);                break;            }            default:{                System.out.println(&quot;用户输入的是其他数字&quot;);            }        }    }}</code></pre><h2 id="2-程序的循环结构"><a href="#2-程序的循环结构" class="headerlink" title="2. 程序的循环结构"></a>2. 程序的循环结构</h2><pre><code>1. while 循环2. do...while 循环3. for 循环4. for 循环的嵌套</code></pre><pre><code class="java">package com.java.chap05;/** * @author Yan * @date 2019/7/16 15:31 */public class Demo3 {    public static void main(String[] args) {        //在控制台输出1到10        //while 循环语句        int i = 1;        while (i &lt; 11) {            System.out.print(i + &quot;  &quot;);            i++;        }        System.out.println(&quot;\n-------------------&quot;);        // do...while 循环语句        int j = 1;        do {            System.out.print(j + &quot;    &quot;);            j++;        } while (j &lt; 11);        System.out.println(&quot;\n-------------------&quot;);        //while和do...while的区别        //while是先判断后执行，do...while是先执行后判断        // for 循环        for (int k = 1; k &lt; 11; k++) {            System.out.printf(k + &quot;   &quot;);        }        System.out.println(&quot;\n-------------------&quot;);        // for循环的嵌套        for (int m = 0; m &lt; 10; m++) {            for (int n = 0; n &lt; 10; n++) {                System.out.print(&quot;m=&quot; + m + &quot;n=&quot; + n+&quot;   &quot;);            }            System.out.println();        }    }}</code></pre><pre><code>5. 求水仙花数</code></pre><pre><code class="java">package com.java.chap05;/** * @author Yan * @date 2019/7/16 15:42 */public class Demo4 {    public static void main(String[] args) {        for (int i=100;i&lt;=999;i++){            //求出百位数            int b=i/100;            //求出十位数            int s=(i-b*100)/10;            //求出个位数            int g=(i-b*100-s*10);            if (i==g*g*g+s*s*s+b*b*b){                System.out.println(i+&quot; &quot;);            }        }    }}</code></pre><h2 id="3-循环结构的控制"><a href="#3-循环结构的控制" class="headerlink" title="3. 循环结构的控制"></a>3. 循环结构的控制</h2><pre><code>1. break 语句结束循环</code></pre><pre><code class="java">package com.java.chap05;/** * @author Yan * @date 2019/7/16 15:52 */public class Demo5 {    public static void main(String[] args) {        for (int i=0;i&lt;10;i++){            for (int j=0;j&lt;10;j++){                if (i==1){                    break;                }                System.out.print(&quot;i=&quot;+i+&quot;   j=&quot;+j+&quot;  &quot;);            }            System.out.println();        }    }}</code></pre><pre><code class="java">package com.java.chap05;/** * @author Yan * @date 2019/7/16 15:55 */public class Demo6 {    public static void main(String[] args) {        outer:        for (int i=0;i&lt;10;i++){            for (int j=0;j&lt;10;j++){                if (i==1){                    break outer;                }                System.out.print(&quot;i=&quot;+i+&quot;   j=&quot;+j+&quot;  &quot;);            }            System.out.println();        }    }}</code></pre><pre><code>2. continue 语句结束本次循环</code></pre><pre><code class="java">package com.java.chap05;/** * @author Yan * @date 2019/7/16 15:57 */public class Demo7 {    public static void main(String[] args) {        for (int i=0;i&lt;10;i++){            if (i==4){                continue;            }            System.out.print(&quot;i=&quot;+i+&quot;  &quot;);        }    }}</code></pre><pre><code>3. return 语句结束方法</code></pre><pre><code class="java">package com.java.chap05;/** * @author Yan * @date 2019/7/16 15:59 */public class Demo8 {    public static void main(String[] args) {        for (int i=0;i&lt;10;i++){            for (int j=0;j&lt;10;j++){                if (i==1){                    return;                }                System.out.print(&quot;i=&quot;+i+&quot;   j=&quot;+j+&quot;  &quot;);            }            System.out.println();        }        System.out.println(&quot;执行到这里了&quot;);    }}</code></pre><h1 id="Java数组"><a href="#Java数组" class="headerlink" title="Java数组"></a>Java数组</h1><h2 id="1-数组简介"><a href="#1-数组简介" class="headerlink" title="1. 数组简介"></a>1. 数组简介</h2><p>数组是Java中最常见的一种数据结构，可用于存储多个数据。</p><h2 id="2-数组的定义"><a href="#2-数组的定义" class="headerlink" title="2. 数组的定义"></a>2. 数组的定义</h2><pre><code class="java">type[] arrayName;或者type arrayName[];   </code></pre><p>实例：     </p><pre><code class="java">int []arr; int arr[];    </code></pre><pre><code class="java">package com.java.chap06;/** * @author Yan * @date 2019/7/17 14:08 */public class Demo1 {    public static void main(String[] args) {        //定义一个数组        int []arr;        //定义一个数组        int arr2[];    }}</code></pre><h2 id="3-数组的初始化"><a href="#3-数组的初始化" class="headerlink" title="3. 数组的初始化"></a>3. 数组的初始化</h2><pre><code>1. 静态初始化</code></pre><p>格式     </p><pre><code class="java">arrayName=new type[]{element1,element2,element3.....}     </code></pre><p>实例：    </p><pre><code class="java">int arr1[]=new int[]{1,2,3}; </code></pre><pre><code class="java">package com.java.chap06;/** * @author Yan * @date 2019/7/17 14:14 */public class Demo2 {    public static void main(String[] args) {        //定义一个数组，并且静态初始化        int arr[]=new  int[]{1,2,3};        //普通的遍历数组方式        for (int i=0;i&lt;arr.length;i++){            System.out.println(arr[i]);        }        System.out.println(&quot;------------&quot;);        //foreach方法遍历数组        for (int j:arr){            System.out.println(j);        }    }}</code></pre><pre><code>2. 动态初始化</code></pre><p>格式      </p><pre><code class="java">arrayName=new type[length];</code></pre><p>实例：      </p><pre><code class="java">int arr2[]=new int[3];</code></pre><pre><code class="java">package com.java.chap06;/** * @author Yan * @date 2019/7/17 14:18 */public class Demo3 {    public static void main(String[] args) {        //定义一个数组，然后动态初始化，长度是3        int arr[]=new int[3];        for(int i:arr){            System.out.println(i);        }    }}</code></pre><p>内存分析<br><img src="https://live.staticflickr.com/65535/48305077142_c9fb3c2e4b_z.jpg" alt></p><h2 id="4-二维数组及多维数组"><a href="#4-二维数组及多维数组" class="headerlink" title="4. 二维数组及多维数组"></a>4. 二维数组及多维数组</h2><p>二维数组静态化初始化 格式：   </p><pre><code class="java">arrayName=new type[]{{element1,element2},{element1,element2},{element1,element2}};    </code></pre><p>实例：     </p><pre><code class="java">int[][]arr=new int[][]{1,2,3},{4,5,6},{7,8,9}};</code></pre><p>二维数组动态初始化 格式：    </p><pre><code class="java">arrayName=new type[length][length];    </code></pre><p>实例：    </p><pre><code class="java">int [][]arr2=new int[3][3];</code></pre><pre><code class="java">package com.java.chap06;/** * @author Yan * @date 2019/7/17 14:35 */public class Demo4 {    public static void main(String[] args) {        //定义一个二维数组,并静态初始化        int [][]arr=new int[][]{{1,2,3},{4,5,6},{7,8,9}};        //输出        for (int i=0;i&lt;arr.length;i++){            for (int j=0;j&lt;arr[0].length;j++){                System.out.print(arr[i][j]+&quot;  &quot;);            }            System.out.println();        }        //二维数组的动态初始化        int [][]arr2=new int[3][3];        for (int i=0;i&lt;arr2.length;i++){            for (int j=0;j&lt;arr2[0].length;j++){                System.out.print(arr2[i][j]+&quot;  &quot;);            }            System.out.println();        }    }}</code></pre><p><img src="https://live.staticflickr.com/65535/48305176832_bedf7286a8_z.jpg" alt></p><h2 id="5-起泡法"><a href="#5-起泡法" class="headerlink" title="5. 起泡法"></a>5. 起泡法</h2><p>对4，21，0，-12，-3排序。<br>原理：起泡法是从一端开始比较的，第一次循环就是把最大数放到最后一个位置，第二次循环就是把第二最大数放到倒数第二个位置。       </p><table><thead><tr><th></th><th>4</th><th>21</th><th>0</th><th>-12</th><th>-3</th></tr></thead><tbody><tr><td>第1次</td><td>4</td><td>0</td><td>-12</td><td>-3</td><td>21</td></tr><tr><td>第2次</td><td>0</td><td>-12</td><td>-3</td><td>4</td><td>21</td></tr><tr><td>第3次</td><td>-12</td><td>-3</td><td>0</td><td>4</td><td>21</td></tr><tr><td>第4次</td><td>-12</td><td>-3</td><td>0</td><td>4</td><td>21</td></tr></tbody></table><pre><code class="java">package com.java.chap06;/** * @author Yan * @date 2019/7/17 14:46 */public class Demo5 {    public static void main(String[] args) {        int temp;        int []arr={4,21,0,-12,-3};        //循环的次数n-1次        for (int i=0;i&lt;arr.length-1;i++){            //比较次数n-1-i            for (int j=0;j&lt;arr.length-1-i;j++){                //假如前面一个数大于后面一个数，则交换数据                if (arr[j]&gt;arr[j+1]){                    temp=arr[j];                    arr[j]=arr[j+1];                    arr[j+1]=temp;                }            }        }        for (int i:arr){            System.out.print(i+&quot;  &quot;);        }    }}</code></pre><h1 id="Java面向对象"><a href="#Java面向对象" class="headerlink" title="Java面向对象"></a>Java面向对象</h1><h2 id="1-面向对象的基本概念"><a href="#1-面向对象的基本概念" class="headerlink" title="1. 面向对象的基本概念"></a>1. 面向对象的基本概念</h2><p>定义：以基于对象的思维去分析和解决问题，万物皆对象；<br>三大特性：封装，继承，多态；</p><h2 id="2-类与对象"><a href="#2-类与对象" class="headerlink" title="2. 类与对象"></a>2. 类与对象</h2><h3 id="1-类与对象的关系"><a href="#1-类与对象的关系" class="headerlink" title="1. 类与对象的关系"></a>1. 类与对象的关系</h3><h3 id="2-类的定义"><a href="#2-类的定义" class="headerlink" title="2. 类的定义"></a>2. 类的定义</h3><h3 id="3-类的创建及使用"><a href="#3-类的创建及使用" class="headerlink" title="3. 类的创建及使用"></a>3. 类的创建及使用</h3><pre><code class="java">package com.java.chap07.sec01;/** * @author Yan * @date 2019/7/18 13:39 * Person类 */public class Person {    String name;    //在类中，定义一个姓名name字符串属性    int age;         //在类中，定义一个年龄age属性    public void speak(){        System.out.println(&quot;我叫&quot;+name+&quot;我今年&quot;+age+&quot;岁了&quot;);    }    public static void main(String[] args) {        //定义一个Person类的对象zhangsan        Person zhangsan;        //实例化对象        zhangsan=new Person();        //给对象的name属性赋值        zhangsan.name=&quot;张三&quot;;        zhangsan.age=23;        zhangsan.speak();    }}</code></pre><p>内存分析    </p><p><img src="https://live.staticflickr.com/65535/48312793817_34c3556633_z.jpg" alt></p><h2 id="3-方法"><a href="#3-方法" class="headerlink" title="3. 方法"></a>3. 方法</h2><h3 id="1-方法的定义及简单使用"><a href="#1-方法的定义及简单使用" class="headerlink" title="1. 方法的定义及简单使用"></a>1. 方法的定义及简单使用</h3><pre><code class="java">package com.java.chap07.sec02;/** * @author Yan * @date 2019/7/18 13:54 */public class People {    /**     * 最简单的一个方法定义     */    void speak(){        System.out.println(&quot;我叫张三&quot;);    }    public static void main(String[] args) {        People zhangsan=new People();        zhangsan.speak();    }}</code></pre><pre><code class="java">package com.java.chap07.sec02;/** * @author Yan * @date 2019/7/18 13:57 */public class People2 {    //形参，入参    void speak(String name){        System.out.println(&quot;我叫&quot;+name);    }    public static void main(String[] args) {        People2 zhangsan=new People2();        zhangsan.speak(&quot;张三&quot;);    }}</code></pre><pre><code class="java">package com.java.chap07.sec02;/** * @author Yan * @date 2019/7/18 13:57 */public class People3 {    //形参，入参    void speak(String name, int age) {        System.out.println(&quot;我叫&quot; + name+&quot;我今年&quot;+age+&quot;岁了&quot;);    }    public static void main(String[] args) {        People3 zhangsan = new People3();        zhangsan.speak(&quot;张三&quot;, 23);    }}</code></pre><pre><code class="java">package com.java.chap07.sec02;/** * @author Yan * @date 2019/7/18 13:57 */public class People4 {    //形参，入参,不固定参数    void speak(String name, int age,String ...hobbies) {        System.out.println(&quot;我叫&quot; + name + &quot;我今年&quot; + age + &quot;岁了&quot;);        System.out.println(&quot;我的爱好：  &quot;);        for (String hobby:hobbies){            System.out.print(hobby+&quot;  &quot;);        }    }    public static void main(String[] args) {        People4 zhangsan = new People4();        zhangsan.speak(&quot;张三&quot;, 23,&quot;游泳&quot;,&quot;唱歌&quot;);    }}</code></pre><pre><code class="java">package com.java.chap07.sec02;/** * @author Yan * @date 2019/7/18 13:57 */public class People5 {    //返回类型    int speak(String name, int age,String ...hobbies) {        System.out.println(&quot;我叫&quot; + name + &quot;我今年&quot; + age + &quot;岁了&quot;);        System.out.println(&quot;我的爱好：  &quot;);        for (String hobby:hobbies){            System.out.print(hobby+&quot;  &quot;);        }        //获取爱好的长度        int totalHobbies=hobbies.length;        return totalHobbies;    }    public static void main(String[] args) {        People5 zhangsan = new People5();        int n=zhangsan.speak(&quot;张三&quot;, 23,&quot;游泳&quot;,&quot;唱歌&quot;);        System.out.println(&quot;\n有&quot;+n+&quot;个爱好&quot;);    }}</code></pre><h3 id="2-方法的值传递和引用传递-重点"><a href="#2-方法的值传递和引用传递-重点" class="headerlink" title="2. 方法的值传递和引用传递(重点)"></a>2. 方法的值传递和引用传递(重点)</h3><pre><code class="java">package com.java.chap07.sec02;/** * 三围类 * @author Yan * @date 2019/7/18 14:08 */class Sanwei{    int b;   //胸围    int w;   //腰围    int h;   //臀围}public class People6 {    /**     * 报三围     * @param age 年龄     * @param sanwei  三围     */    void speak(int age,Sanwei sanwei){        System.out.println(&quot;我今年&quot;+age+&quot;岁了,我的三围是&quot;+sanwei.b+&quot;,&quot;+sanwei.w+&quot;,&quot;+sanwei.h);        age=24;        sanwei.b=80;    }    public static void main(String[] args) {        People6 xiaoli=new People6();        int age=23;        Sanwei sanwei=new Sanwei();        sanwei.b=90;        sanwei.w=60;        sanwei.h=90;        //age传递的是值，sanwei传递的是引用（地址）,c里叫指针        xiaoli.speak(age,sanwei);        System.out.println(age);        System.out.println(sanwei.b);    }}</code></pre><h3 id="3-方法的重载"><a href="#3-方法的重载" class="headerlink" title="3. 方法的重载"></a>3. 方法的重载</h3><p>方法重载定义：方法名称相同，但是参数的类型或者参数的个数不同。</p><pre><code class="java">package com.java.chap07.sec03;/** * @author Yan * @date 2019/7/18 14:22 */public class Demo {    int add(int a,int b){        System.out.print(&quot;方法一:&quot;);        return a+b;    }    /**     * 方法的重载，参数个数不一样     * @param a     * @param b     * @param c     * @return     */    int add(int a,int b,int c){        System.out.print(&quot;方法二：&quot;);        return a+b+c;    }    /**     * 方法的重载，参数的类型不一样     * @param a     * @param b     * @return     */    int add(int a,String b){        System.out.print(&quot;方法三：&quot;);        return a+Integer.parseInt(b);    }    public static void main(String[] args) {        Demo demo=new Demo();        System.out.println(demo.add(1,2));        System.out.println(demo.add(1,2,3));        System.out.println(demo.add(1,&quot;3&quot;));    }}</code></pre><h3 id="4-static静态方法与普通方法"><a href="#4-static静态方法与普通方法" class="headerlink" title="4. static静态方法与普通方法"></a>4. static静态方法与普通方法</h3><p>static方法：方法属于类本身；调用方式：1. 类名.方法;2. 对象.方法      </p><p>普通方法：方法属于类的对象；调用方式：1. 对象.方法</p><pre><code class="java">package com.java.chap07.sec03;/** * @author Yan * @date 2019/7/18 15:33 */public class Demo2 {    void fun1(){        System.out.println(&quot;这是一个普通方法&quot;);    }    static void fun2(){        System.out.println(&quot;这是一个静态方法&quot;);    }    public static void main(String[] args) {        Demo2 demo2=new Demo2();        //调用普通方法，对象.方法        demo2.fun1();        //调用静态方法，类名.方法名        Demo2.fun2();        //调用静态方法，对象.方法        demo2.fun2();    }}</code></pre><h3 id="5-递归方法"><a href="#5-递归方法" class="headerlink" title="5. 递归方法"></a>5. 递归方法</h3><p>求阶乘 1 <em> 2 </em> 3… <em> (n-1) </em> n<br>原理：     </p><pre><code class="java">N=5 F(n-1) * 5        N=4 F(n-1) * 4     N=3 F(n-1) * 3      N=2 F(n-1) * 2      N=1 1   </code></pre><pre><code class="java">package com.java.chap07.sec03;/** * @author Yan * @date 2019/7/18 15:38 */public class Demo3 {    /**     * 非递归     * @param n     * @return     */    static long notDiGui(int n){        long result=1;        for (int i=1;i&lt;=n;i++){            result=result*i;        }        return result;    }    /**     * 递归     * @param n     * @return     */    static long DiGUi(int n){        if (n==1){            return 1;        }        return DiGUi(n-1)*n;    }    public static void main(String[] args) {        System.out.println(&quot;非递归：&quot;+Demo3.notDiGui(5));        System.out.println(&quot;递归:&quot;+Demo3.DiGUi(5));    }}</code></pre><h2 id="4-构造方法，this关键字"><a href="#4-构造方法，this关键字" class="headerlink" title="4. 构造方法，this关键字"></a>4. 构造方法，this关键字</h2><h3 id="1-构造方法"><a href="#1-构造方法" class="headerlink" title="1. 构造方法"></a>1. 构造方法</h3><p>构造器是一个特殊的方法，这个特殊方法用于创建实例时可执行初始化；<br>假如没有构造方法，系统会自动生成一个默认的无参构造方法；假如有构造方法，系统不会自动生成构造方法；</p><pre><code class="java">package com.java.chap07.sec04;/** * @author Yan * @date 2019/7/18 15:56 */public class People {    // String 类属性默认值是null    private String name;    //int 类属性默认值是0    private int age;    /**     * 默认构造方法     */    People(){        System.out.println(&quot;默认构造方法&quot;);    }    /**     * 有参数的构造方法   构造方法的重载     */    People(String name2,int age2){        name=name2;        age=age2;        System.out.println(&quot;有参数的构造方法&quot;);    }    public void say(){        System.out.println(&quot;我叫：&quot;+name+&quot;，我今年：&quot;+age+&quot;岁了&quot;);    }    public static void main(String[] args) {        //People people=new People();        People people2=new People(&quot;张三&quot;,23);        people2.say();    }}</code></pre><h3 id="2-this关键字"><a href="#2-this关键字" class="headerlink" title="2. this关键字"></a>2. this关键字</h3><p>this表示当前对象     </p><ol><li>使用this调用本类中的属性；    </li><li>使用this调用构造方法；    </li></ol><pre><code class="java">package com.java.chap07.sec04;/** * @author Yan * @date 2019/7/18 15:56 */public class People2 {    // String 类属性默认值是null    private String name;    //int 类属性默认值是0    private int age;    /**     * 默认构造方法     */    People2(){        System.out.println(&quot;默认构造方法&quot;);    }    /**     * 有参数的构造方法   构造方法的重载     */    People2(String name2, int age2){        this();        this.name=name2;        this.age=age2;        System.out.println(&quot;有参数的构造方法&quot;);    }    public void say(){        System.out.println(&quot;我叫：&quot;+name+&quot;，我今年：&quot;+age+&quot;岁了&quot;);    }    public static void main(String[] args) {        //People people=new People();        People2 people2=new People2(&quot;张三&quot;,23);        people2.say();    }}</code></pre><h2 id="5-访问控制权限及package-import关键字"><a href="#5-访问控制权限及package-import关键字" class="headerlink" title="5. 访问控制权限及package import关键字"></a>5. 访问控制权限及package import关键字</h2><h3 id="1-访问控制权限"><a href="#1-访问控制权限" class="headerlink" title="1. 访问控制权限"></a>1. 访问控制权限</h3><p>private(私有)   get,set方法<br>package（包访问权限）<br>protected(子类访问权限)<br>public（公共访问权限）      </p><table><thead><tr><th></th><th>private</th><th>package</th><th>protected</th><th>public</th></tr></thead><tbody><tr><td>同一个类中</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>同一个包中</td><td></td><td>√</td><td>√</td><td>√</td></tr><tr><td>子类中</td><td></td><td></td><td>√</td><td>√</td></tr><tr><td>全局范围</td><td></td><td></td><td></td><td>√</td></tr></tbody></table><p><strong>Demo1.java</strong>    </p><pre><code class="java">package com.java.chap07.sec05;/** * @author Yan * @date 2019/7/18 16:16 */public class Demo1 {    /**     * 定义一个私有的属性a     */    private int a;    public int getA() {        return a;    }    public void setA(int a) {        this.a = a;    }}</code></pre><p><strong>TestDemo1.java</strong>     </p><pre><code class="java">package com.java.chap07.sec05;/** * @author Yan * @date 2019/7/18 16:17 */public class TestDemo1 {    public static void main(String[] args) {        Demo1 demo1=new Demo1();        demo1.setA(2);        int a=demo1.getA();        System.out.println(a);    }}</code></pre><h3 id="2-package-import-关键字"><a href="#2-package-import-关键字" class="headerlink" title="2. package import 关键字"></a>2. package import 关键字</h3><p>package 包定义<br>import 导入相关类</p><pre><code class="java">package com.java.chap07.sec05;import com.java.chap07.sec02.People;/** * @author Yan * @date 2019/7/18 16:19 */public class Demo2 {    public static void main(String[] args) {        //不同包，则需要导入相关类        People people=new People();        //在同一个包中，则不需要导入相关类        Demo1 demo1=new Demo1();    }}</code></pre><h2 id="6-内部类"><a href="#6-内部类" class="headerlink" title="6. 内部类"></a>6. 内部类</h2><p>内部类定义：在类的内部定义类；<br>内部类优点：可以方便的使用外部类的属性；<br>内部类缺点：破环类的基本结构；              </p><p><strong>Demo1.java</strong>     </p><pre><code class="java">package com.java.chap07.sec06;/** * @author Yan * @date 2019/7/18 16:38 */public class Outer {    private int a=1;    /**     * 定义内部类     */    class Inner{        public void show(){            System.out.println(a);        }    }    public void show(){        Inner inner=new Inner();        inner.show();    }    public static void main(String[] args) {        Outer outer=new Outer();        outer.show();    }}</code></pre><p><strong>Demo2.java</strong>      </p><pre><code class="java">package com.java.chap07.sec06;/** * @author Yan * @date 2019/7/18 16:38 */public class Outer2 {    private int a = 1;    /**     * 定义内部类     */    class Inner {        public void show() {            System.out.println(a);        }    }    public static void main(String[] args) {        Outer2 outer2 = new Outer2();   //实例化外部类对象        Outer2.Inner inner = outer2.new Inner();    //实例化内部类对象        inner.show();    }}</code></pre><h2 id="7-代码块"><a href="#7-代码块" class="headerlink" title="7. 代码块"></a>7. 代码块</h2><ol><li>普通代码块</li></ol><pre><code class="java">package com.java.chap07.sec07;/** * @author Yan * @date 2019/7/18 16:49 */public class Demo1 {    public static void main(String[] args) {        int a=1;        /**         * 普通代码块         */        {            a=2;            System.out.println(&quot;普通代码块&quot;);        }        System.out.println(&quot;a=&quot;+a);    }}</code></pre><ol start="2"><li>构造块</li></ol><pre><code class="java">package com.java.chap07.sec07;/** * @author Yan * @date 2019/7/18 16:52 */public class Demo2 {    /**     * 构造块     * @param args     */    {        System.out.println(&quot;通用构造块&quot;);    }    /**     * 构造方法一     */    public Demo2(){        System.out.println(&quot;构造方法一&quot;);    }    /**     * 构造方法二     */    public Demo2(int i){        System.out.println(&quot;构造方法二&quot;);    }    /**     * 构造方法三     */    public Demo2(int i,int j){        System.out.println(&quot;构造方法三&quot;);    }    public static void main(String[] args) {        new Demo2();    //实例化一个对象  匿名类        new Demo2(1);        new Demo2(1,2);    }}</code></pre><ol start="3"><li>静态代码块</li></ol><pre><code class="java">package com.java.chap07.sec07;/** * @author Yan * @date 2019/7/18 16:55 */public class Demo3 {    /**     * 构造块     */    {        System.out.println(&quot;通用构造块&quot;);    }    /**     * 静态代码块     */    static {        System.out.println(&quot;静态代码块&quot;);    }    /**     * 构造方法一     */    public Demo3(){        System.out.println(&quot;构造方法一&quot;);    }    /**     * 构造方法二     */    public Demo3(int i){        System.out.println(&quot;构造方法二&quot;);    }    /**     * 构造方法三     */    public Demo3(int i,int j){        System.out.println(&quot;构造方法三&quot;);    }    public static void main(String[] args) {        new Demo3();        new Demo3(1);        new Demo3(1,2);    }}</code></pre><h2 id="8-String-类"><a href="#8-String-类" class="headerlink" title="8. String 类"></a>8. String 类</h2><h3 id="1-实例化String对象"><a href="#1-实例化String对象" class="headerlink" title="1. 实例化String对象"></a>1. 实例化String对象</h3><p>方法一：   </p><pre><code class="java">String name1=&quot;张三&quot;;</code></pre><p>方法二：     </p><pre><code class="java">String name2=new String(&quot;李四&quot;);</code></pre><pre><code class="java">package com.java.chap07.sec08;/** * @author Yan * @date 2019/7/18 21:32 */public class Demo1 {    public static void main(String[] args) {        //实例化String的方式一        String name1=&quot;张三&quot;;        System.out.println(&quot;name1:&quot;+name1);        //实例化String的方式二        String name2=new String(&quot;李四&quot;);        System.out.println(&quot;name2:&quot;+name2);    }}</code></pre><h3 id="2-“-”-VS-“equals方法”"><a href="#2-“-”-VS-“equals方法”" class="headerlink" title="2. “==” VS “equals方法”"></a>2. “==” VS “equals方法”</h3><ol><li>“==”，比较的是引用，“equals方法”比较的是具体内容</li></ol><p><img src="https://live.staticflickr.com/65535/48314990292_7cf024cfee_z.jpg" alt></p><pre><code class="java">package com.java.chap07.sec08;/** * @author Yan * @date 2019/7/18 21:39 */public class Demo2 {    public static void main(String[] args) {        String name1=&quot;张三&quot;;    //直接赋值方式        String name2=new String(&quot;张三&quot;);   //new 的方式        String name3=name2;     // 传递引用        //==比较的是引用        System.out.println(&quot;name1==name2:&quot;+(name1==name2));        System.out.println(&quot;name1==name3:&quot;+(name1==name3));        System.out.println(&quot;name2==name3:&quot;+(name2==name3));        System.out.println(&quot;-------------&quot;);        //equals比较的是内容        System.out.println(&quot;name1.equals(name2):&quot;+(name1.equals(name2)));        System.out.println(&quot;name1.equals(name3):&quot;+(name1.equals(name3)));        System.out.println(&quot;name2.equals(name3):&quot;+(name2.equals(name3)));    }}</code></pre><h3 id="3-String-两种实例化方式的区别"><a href="#3-String-两种实例化方式的区别" class="headerlink" title="3. String 两种实例化方式的区别"></a>3. String 两种实例化方式的区别</h3><ol><li>直接赋值方式，创建的对象存放到字符串对象池里，假如存在的，就不会创建；</li><li>new对象方式，每次都创建一个新的对象；</li></ol><p><img src="https://live.staticflickr.com/65535/48315050387_192d66d693_z.jpg" alt></p><pre><code class="java">package com.java.chap07.sec08;/** * @author Yan * @date 2019/7/18 21:46 */public class Demo3 {    public static void main(String[] args) {        String name1=&quot;张三&quot;;        String name2=&quot;张三&quot;;        String name3=new String(&quot;张三&quot;);        String name4=new String(&quot;张三&quot;);        System.out.println(&quot;name1==name2:&quot;+(name1==name2));        System.out.println(&quot;name1==name3:&quot;+(name1==name3));        System.out.println(&quot;name3==name4:&quot;+(name3==name4));    }}</code></pre><h3 id="4-字符串的内容不可变性"><a href="#4-字符串的内容不可变性" class="headerlink" title="4. 字符串的内容不可变性"></a>4. 字符串的内容不可变性</h3><p>字符串的特性：不能改变字符串的内容；只能通过指向一个新的内存地址；     </p><p><img src="https://live.staticflickr.com/65535/48314968091_7ac4026543_z.jpg" alt></p><pre><code class="java">package com.java.chap07.sec08;/** * @author Yan * @date 2019/7/18 21:51 */public class Demo4 {    public static void main(String[] args) {        String name=&quot;张&quot;;        name+=&quot;三&quot;;        System.out.println(name);    }}</code></pre><h3 id="5-String类常用方法及基本使用"><a href="#5-String类常用方法及基本使用" class="headerlink" title="5. String类常用方法及基本使用"></a>5. String类常用方法及基本使用</h3><ol><li>char charAt(int index)返回指定索引处的char值。<br><code>`</code>java<br>package com.java.chap07.sec08;</li></ol><p>/**</p><ul><li>@author Yan</li><li><p>@date 2019/7/18 22:00<br>*/<br>public class Demo5 {<br> public static void main(String[] args) {</p><pre><code> String name=&quot;张三&quot;; char ming=name.charAt(1); System.out.println(ming); String srt=&quot;我是中国人&quot;; //遍历字符串 for (int i=0;i&lt;srt.length();i++){     System.out.println(srt.charAt(i)); }</code></pre><p> }<br>}</p></li></ul><pre><code>2. int length()返回此字符串的长度。3. int indexOf() 返回指定字符在此字符中第一次出现处的索引。   ```javapackage com.java.chap07.sec08;/** * @author Yan * @date 2019/7/18 22:03 */public class Demo6 {    public static void main(String[] args) {        //indexOf方法使用示例        String str=&quot;abcdefghdijklmnopqrstuvwxyz&quot;;        System.out.println(&quot;d在字符串str中第一次出现的索引位置：&quot;+str.indexOf(&quot;d&quot;));        System.out.println(&quot;d在字符串str中第一次出现的索引位置,从索引4开始：&quot;+str.indexOf(&quot;d&quot;,4));    }}</code></pre><ol start="4"><li>String substring(int beginIndex)返回一个新的字符串，它是此字符串的一个子字符串。该子字符串从指定索引处的字符开始，直到此字符串末尾。</li></ol><pre><code class="java">package com.java.chap07.sec08;/** * @author Yan * @date 2019/7/18 22:08 */public class Demo7 {    public static void main(String[] args) {        //subString方法使用        String str=&quot;不开心每一天,不可能&quot;;        String newStr=str.substring(1);        String newStr2=str.substring(1,6);        System.out.println(str);        System.out.println(newStr);        System.out.println(newStr2);    }}</code></pre><ol start="5"><li>String toUpperCase() 使用默认语言环境的规则将此String中的所有字符都转换为大写。</li></ol><pre><code class="java">package com.java.chap07.sec08;/** * @author Yan * @date 2019/7/18 22:12 */public class Demo8 {    public static void main(String[] args) {        String str=&quot;I&#39;m a boy!&quot;;        String upStr=str.toUpperCase();   //转换成大写        System.out.println(&quot;str:&quot;+str);        System.out.println(&quot;upStr:&quot;+upStr);        String lowerStr=upStr.toLowerCase();  //转换成小写        System.out.println(&quot;lowerStr:&quot;+lowerStr);    }}</code></pre><ol start="6"><li>综合实例<br>编程输入一个字符串，要求去掉前后的空格，然后分别统计其中英文字母，空格，数字和其他字符的个数。</li></ol><pre><code class="java">package com.java.chap07.sec08;/** * @author Yan * @date 2019/7/18 22:18 */public class Demo9 {    public static void main(String[] args) {        String str=&quot;  aB23 2&amp;*  &amp;*   s2  &quot;;        //去掉前面和后面的空白        String newStr=str.trim();        System.out.println(&quot;str:&quot;+str);        System.out.println(&quot;newStr:&quot;+newStr);        int yingWen=0;        int kongGe=0;        int shuZi=0;        int qiTa=0;        for (int i=0;i&lt;newStr.length();i++){            char c=newStr.charAt(i);            if (c&gt;=&#39;a&#39;&amp;&amp;c&lt;=&#39;z&#39;||(c&gt;=&#39;A&#39;&amp;&amp;c&lt;=&#39;Z&#39;)){                //判断英文字符                yingWen++;                System.out.println(&quot;英文字符：&quot;+c);            }else if (c&gt;=&#39;0&#39;&amp;&amp;c&lt;=&#39;9&#39;){                //判断数字                shuZi++;                System.out.println(&quot;数字：&quot;+c);            }else if (c==&#39; &#39;){                //判断空格                kongGe++;                System.out.println(&quot;空格：&quot;+c);            }else {                //判断其他                qiTa++;                System.out.println(&quot;其他：&quot;+c);            }        }        System.out.println();        System.out.println(&quot;英文总数：&quot;+yingWen);        System.out.println(&quot;数字总数：&quot;+shuZi);        System.out.println(&quot;空格总数：&quot;+kongGe);        System.out.println(&quot;其他总数：&quot;+qiTa);    }}</code></pre><h2 id="9-Java类的继承"><a href="#9-Java类的继承" class="headerlink" title="9. Java类的继承"></a>9. Java类的继承</h2><ol><li>继承定义以及基本使用<br>定义：子类能够继承父类的属性和方法；<br><strong>注意点</strong>：Java中只支持单继承；私有方法不能继承。</li></ol><p><strong>Animal.java</strong>     </p><pre><code class="java">package com.java.chap07.sec09;/** * 动物类 * * @author Yan * @date 2019/7/19 15:32 */public class Animal {    //属性姓名    private String name;    //属性年龄    private int age;    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    //方法say    public void say() {        System.out.println(&quot;我是一个动物，我叫：&quot; + this.getName() + &quot;我的年龄是：&quot; + this.getAge());    }}</code></pre><p><strong>Dog.java</strong>      </p><pre><code class="java">package com.java.chap07.sec09;/** * * 定义Dog类，继承自Animal类 * @author Yan * @date 2019/7/19 17:25 */public class Dog extends Animal{    public static void main(String[] args) {        Dog dog=new Dog();        dog.setName(&quot;Pick&quot;);        dog.setAge(1);        dog.say();    }}</code></pre><ol start="2"><li>方法重写</li></ol><p><strong>Animal.java</strong>     </p><pre><code class="java">package com.java.chap07.sec09;/** * 动物类 * * @author Yan * @date 2019/7/19 15:32 */public class Animal {    //属性姓名    private String name;    //属性年龄    private int age;    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    //方法say    public void say() {        System.out.println(&quot;我是一个动物，我叫：&quot; + this.getName() + &quot;我的年龄是：&quot; + this.getAge());    }}</code></pre><p><strong>Cat.java</strong>    </p><pre><code>package com.java.chap07.sec09;/** * @author Yan * @date 2019/7/19 17:32 */public class Cat extends Animal {    /**     * 重写父类的say方法     */    //方法say    public void say() {        System.out.println(&quot;我是一只猫，我叫：&quot; + this.getName() + &quot;我的年龄是：&quot; + this.getAge());    }    public static void main(String[] args) {        Cat cat=new Cat();        cat.setName(&quot;Mini&quot;);        cat.setAge(2);        cat.say();    }}</code></pre><ol start="3"><li>对象实例化过程以及super关键字</li></ol><p><strong>Animal.java</strong>     </p><pre><code class="java">package com.java.chap07.sec09;/** * 动物类 * * @author Yan * @date 2019/7/19 15:32 */public class Animal {    //属性姓名    private String name;    //属性年龄    private int age;    /**     * 无参构造方法     */    public Animal(){        System.out.println(&quot;无参构造方法&quot;);    }    /**     * 有参父类构造方法     * @param name 名字     * @param age 年龄     */    public Animal(String name,int age){        System.out.println(&quot;有参父类构造方法&quot;);        this.name=name;        this.age=age;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    //方法say    public void say() {        System.out.println(&quot;我是一个动物，我叫：&quot; + this.getName() + &quot;我的年龄是：&quot; + this.getAge());    }}</code></pre><p><strong>Cat.java</strong>         </p><pre><code class="java">package com.java.chap07.sec09;/** * @author Yan * @date 2019/7/19 17:32 */public class Cat extends Animal {    private String address;    public String getAddress() {        return address;    }    public void setAddress(String address) {        this.address = address;    }    public Cat() {        super();        System.out.println(&quot;子类无参构造方法&quot;);    }    public Cat(String name, int age,String address) {        super(name, age);        this.address=address;        System.out.println(&quot;子类有参构造方法&quot;);    }    /**     * 重写父类的say方法     */    //方法say    public void say() {        //调用父类的say方法        super.say();        System.out.println(&quot;我是一只猫，我叫：&quot; + this.getName() + &quot;我的年龄是：&quot; + this.getAge()+&quot;我来自：&quot;+this.address);    }    public static void main(String[] args) {        Cat cat=new Cat(&quot;Mini&quot;,1,&quot;火星&quot;);        //cat.setName(&quot;Mini&quot;);        //cat.setAge(2);        cat.say();    }}</code></pre><h2 id="10-final关键字"><a href="#10-final关键字" class="headerlink" title="10. final关键字"></a>10. final关键字</h2><blockquote><p>使用final声明的类不能被继承<br>使用final声明的方法不能被子类覆盖<br>使用final声明的变量不能被修改，即为常量</p></blockquote><ol><li>final 修饰类</li></ol><p>代码示例：<br><strong>JiangShi.java</strong>  </p><pre><code class="java">package com.java.chap07.sec10;/** * @author Yan * @date 2019/7/19 21:04 */public final class JiangShi {}</code></pre><p><strong>test.java</strong>       </p><pre><code class="java">package com.java.chap07.sec10;/** * @author Yan * @date 2019/7/19 21:05 */public class Test extends JiangShi{}</code></pre><ol start="2"><li>final 修饰方法</li></ol><p><strong>People.java</strong>     </p><pre><code class="java">package com.java.chap07.sec10;/** * @author Yan * @date 2019/7/19 21:55 */public class People {    public final void action(){        System.out.println(&quot;做一个良好公民！&quot;);    }}</code></pre><p><strong>Test.java</strong>        </p><pre><code class="java">package com.java.chap07.sec10;/** * @author Yan * @date 2019/7/19 21:05 */public class Test extends People{    public void action(){        System.out.println(&quot;做一个坏蛋&quot;);    }}</code></pre><ol start="3"><li>final 修饰的变量</li></ol><p><strong>People.java</strong></p><pre><code class="java">package com.java.chap07.sec10;/** * @author Yan * @date 2019/7/19 21:55 */public class People {    private final int a=1;    public void action(){        a=2;        System.out.println(&quot;做一个良好公民！&quot;);    }}</code></pre><p><strong>Common.java</strong></p><pre><code class="java">package com.java.chap07.sec10;/** * @author Yan * @date 2019/7/19 22:25 */public class Common {    /**     * 静态常量     */    public static final String SOMETILE=&quot;中国的首都是北京&quot;;}</code></pre><p><strong>Test.java</strong></p><pre><code class="java">package com.java.chap07.sec10;/** * @author Yan * @date 2019/7/19 21:05 */public class Test extends People{    public void action(){        System.out.println(&quot;做一个坏蛋&quot;);    }    public static void main(String[] args) {        System.out.println(Common.SOMETILE);    }}</code></pre><h2 id="11-抽象类"><a href="#11-抽象类" class="headerlink" title="11. 抽象类"></a>11. 抽象类</h2><p>定义：在Java中，含有抽象方法的类称为抽象类，同样不能生成对象。<br><strong>注意点</strong>：      </p><ol><li>包含一个抽象方法的类是抽象类</li><li>抽象类和抽象方法都要用abstract 关键字声明</li><li>抽象方法只需要声明而不需要实现</li><li>抽象类必须被子类（假如不是抽象类）必须重写抽象类中的全部抽象方法</li><li>抽象类不能被实例化</li></ol><p><strong>People.java</strong></p><pre><code class="java">package com.java.chap07.sec11;/** * 定义一个抽象类People * @author Yan * @date 2019/7/20 15:25 */public abstract class People {    private String name;    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public void say(){        System.out.println(&quot;我的姓名是：&quot;+this.getName());    }    /**     *     * 定义一个抽象方法职业     */    public abstract void profession();}</code></pre><p><strong>Student.java</strong></p><pre><code class="java">package com.java.chap07.sec11;/** * @author Yan * @date 2019/7/20 15:29 */public class Student extends People{    @Override    public void profession() {        System.out.println(&quot;职业是：学生&quot;);    }}</code></pre><p><strong>Teacher.java</strong></p><pre><code class="java">package com.java.chap07.sec11;/** * @author Yan * @date 2019/7/20 15:30 */public class Teacher extends People{    @Override    public void profession() {        System.out.println(&quot;职业是：老师&quot;);    }}</code></pre><p><strong>Test.java</strong></p><pre><code class="java">package com.java.chap07.sec11;/** * @author Yan * @date 2019/7/20 15:28 */public class Test {    public static void main(String[] args) {        //抽象类不能被实例化        //People p=new People();        Student student=new Student();        student.profession();        Teacher teacher=new Teacher();        teacher.profession();    }}</code></pre><h2 id="12-接口"><a href="#12-接口" class="headerlink" title="12. 接口"></a>12. 接口</h2><p>定义：一种特殊的“抽象类”，没有普通方法，有全局常量和公共的抽象方法所组成。        </p><ol><li>接口的定义</li></ol><p><strong>A.java</strong>   </p><pre><code class="java">package com.java.chap07.sec12;/** * 定义一个接口A * @author Yan * @date 2019/7/20 15:40 */public interface A {    /**     * 全局常量     */    public static final String TITLE=&quot;www.baidu.com&quot;;    /**     * 定义一个抽象方法 abstract可以省略     */    public void a();}</code></pre><ol start="2"><li>实现接口<br>可以实现一个或者多个接口</li></ol><p>实现一个接口<br><strong>A.java</strong></p><pre><code class="java">package com.java.chap07.sec12;/** * 定义一个接口A * @author Yan * @date 2019/7/20 15:40 */public interface A {    /**     * 全局常量     */    public static final String TITLE=&quot;www.baidu.com&quot;;    /**     * 定义一个抽象方法 abstract可以省略     */    public void a();}</code></pre><p><strong>Test.java</strong></p><pre><code class="java">package com.java.chap07.sec12;/** * @author Yan * @date 2019/7/20 16:04 */public class Test implements A{    @Override    public void a() {        System.out.println(&quot;a方法&quot;);    }    public static void main(String[] args) {        Test test=new Test();        test.a();        System.out.println(Test.TITLE);    }}</code></pre><p>实现多个接口       </p><p><strong>A.java</strong></p><pre><code class="java">package com.java.chap07.sec12;/** * 定义一个接口A * @author Yan * @date 2019/7/20 15:40 */public interface A {    /**     * 全局常量     */    public static final String TITLEA=&quot;www.baidu.com&quot;;    /**     * 定义一个抽象方法 abstract可以省略     */    public void a();}</code></pre><p><strong>B.java</strong></p><pre><code class="java">package com.java.chap07.sec12;/** * 定义一个接口A * @author Yan * @date 2019/7/20 15:40 */public interface B {    /**     * 全局常量     */    public static final String TITLEB=&quot;www.google.com&quot;;    /**     * 定义一个抽象方法 abstract可以省略     */    public void b();}</code></pre><p><strong>Test.java</strong></p><pre><code class="java">package com.java.chap07.sec12;/** * @author Yan * @date 2019/7/20 16:04 */public class Test implements A, B {    @Override    public void a() {        System.out.println(&quot;a方法&quot;);    }    @Override    public void b() {        System.out.println(&quot;b方法&quot;);    }    public static void main(String[] args) {        Test test = new Test();        test.a();        test.b();        System.out.println(Test.TITLEA);        System.out.println(Test.TITLEB);    }}</code></pre><ol start="3"><li>继承类和实现接口<br>先继承，后实现接口</li></ol><p><strong>C.java</strong></p><pre><code class="java">package com.java.chap07.sec12;/** * @author Yan * @date 2019/7/20 16:12 */public class C {    public void c(){        System.out.println(&quot;c方法&quot;);    }}</code></pre><p><strong>Test.java</strong></p><pre><code class="java">package com.java.chap07.sec12;/** * @author Yan * @date 2019/7/20 16:04 */public class Test extends C implements A, B {    @Override    public void a() {        System.out.println(&quot;a方法&quot;);    }    @Override    public void b() {        System.out.println(&quot;b方法&quot;);    }    public static void main(String[] args) {        Test test = new Test();        test.a();        test.b();        test.c();        System.out.println(Test.TITLEA);        System.out.println(Test.TITLEB);    }}</code></pre><ol start="4"><li>接口的继承<br>接口可以多继承     </li></ol><p><strong>D.java</strong></p><pre><code class="java">package com.java.chap07.sec12;/** * 定义接口D,继承A，B接口 * @author Yan * @date 2019/7/20 16:15 */public interface D extends A,B{    /**     * 定义一个抽象方法 abstract可以省略     */    public void d();}</code></pre><p><strong>Test2.java</strong></p><pre><code class="java">package com.java.chap07.sec12;/** * @author Yan * @date 2019/7/20 16:04 */public class Test2 extends C implements D {    @Override    public void a() {        System.out.println(&quot;a方法&quot;);    }    @Override    public void b() {        System.out.println(&quot;b方法&quot;);    }    @Override    public void d() {        System.out.println(&quot;d方法&quot;);    }    public static void main(String[] args) {        Test2 test = new Test2();        test.a();        test.b();        test.c();        test.d();        System.out.println(Test2.TITLEA);        System.out.println(Test2.TITLEB);    }}</code></pre><h2 id="13-对象多态性"><a href="#13-对象多态性" class="headerlink" title="13. 对象多态性"></a>13. 对象多态性</h2><p>Java中多态性体现：     </p><ol><li>方法的重载和重写；</li><li>可以用父类的引用指向子类的具体实现，而且可以随时更换为其他子类的具体实现；</li></ol><p><strong>Animal.java</strong></p><pre><code class="java">package com.java.chap07.sec13;/** * @author Yan * @date 2019/7/20 16:23 */public class Animal {    public void say(){        System.out.println(&quot;我是一个动物&quot;);    }}</code></pre><p><strong>Cat.java</strong></p><pre><code class="java">package com.java.chap07.sec13;/** * @author Yan * @date 2019/7/20 16:24 */public class Cat extends Animal{    public void say(){        System.out.println(&quot;我是一个猫&quot;);    }}</code></pre><p><strong>Dog.java</strong></p><pre><code class="java">package com.java.chap07.sec13;/** * @author Yan * @date 2019/7/20 16:24 */public class Dog extends Animal{    public void say(){        System.out.println(&quot;我是一个狗&quot;);    }}</code></pre><p><strong>Test.java</strong></p><pre><code class="java">package com.java.chap07.sec13;/** * @author Yan * @date 2019/7/20 16:25 */public class Test {    public static void main(String[] args) {        /*        Dog dog=new Dog();        dog.say();        Cat cat=new Cat();        cat.say();        */        //父类引用指向Dog类的具体实现        Animal animal = new Dog();        animal.say();        animal=new Cat();        animal.say();    }}</code></pre><p>对象的转型：<br>向上转型：子类对象-&gt;父类对象  <strong>安全</strong><br>向下转型：父类对象-&gt;子类对象  <strong>不安全</strong></p><p>向下转型     </p><pre><code class="java">package com.java.chap07.sec13;/** * @author Yan * @date 2019/7/20 16:25 */public class Test {    public static void main(String[] args) {        /*        Dog dog=new Dog();        dog.say();        Cat cat=new Cat();        cat.say();        */        //父类引用指向Dog类的具体实现        Animal animal = new Dog();        animal.say();        //向下转型        Dog dog= (Dog) animal;        dog.say();        //向下转型2 不安全        Cat cat= (Cat) animal;        cat.say();        /*animal=new Cat();        animal.say();         */    }}</code></pre><p><strong>接口方式</strong></p><p><strong>Animal.java</strong></p><pre><code class="java">package com.java.chap07.sec13;/** * @author Yan * @date 2019/7/20 16:23 */public interface Animal2 {    public void say2();}</code></pre><p><strong>Dog2.java</strong></p><pre><code class="java">package com.java.chap07.sec13;/** * @author Yan * @date 2019/7/20 16:34 */public class Dog2 implements Animal2{    @Override    public void say2() {        System.out.println(&quot;我是一只狗&quot;);    }}</code></pre><p><strong>Cat2.java</strong></p><pre><code class="java">package com.java.chap07.sec13;/** * @author Yan * @date 2019/7/20 16:24 */public class Cat2 implements Animal2 {    public void say2() {        System.out.println(&quot;我是一个猫&quot;);    }}</code></pre><p><strong>Test2.java</strong></p><pre><code class="java">package com.java.chap07.sec13;/** * @author Yan * @date 2019/7/20 16:25 */public class Test2 {    public static void main(String[] args) {        //父类引用指向Dog类的具体实现  向上转型        Animal2 animal2 = new Dog2();        animal2.say2();        animal2=new Cat2();        animal2.say2();        //向下转型        Dog2 dog2= (Dog2) animal2;        dog2.say2();        //向下转型2 不安全        Cat2 cat2= (Cat2) animal2;        cat2.say2();    }}</code></pre><h2 id="14-Object类"><a href="#14-Object类" class="headerlink" title="14. Object类"></a>14. Object类</h2><blockquote><p>Object类是所有类的父类；</p></blockquote><pre><code class="java">package com.java.chap07.sec14;/** * @author Yan * @date 2019/7/20 21:02 */public class A extends Object{    /**     * Object 类是所有类的父类     */    public A(){        super();    }}</code></pre><h3 id="1-Object类的常用方法"><a href="#1-Object类的常用方法" class="headerlink" title="1. Object类的常用方法"></a>1. Object类的常用方法</h3><ol><li></li></ol><pre><code class="java">public String toString();    //返回该对象的字符串表示</code></pre><p>代码示例：     </p><pre><code class="java">package com.java.chap07.sec14;/** * @author Yan * @date 2019/7/20 21:04 */public class People {    private String name;    public People(String name) {        this.name = name;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    @Override    public String toString() {        return this.getName();    }    public static void main(String[] args) {        People people=new People(&quot;张三&quot;);        System.out.println(people);        System.out.println(people.toString());    }}</code></pre><ol start="2"><li></li></ol><pre><code class="java">public boolean equals(Object obj);  //指示其他某个对象是否与此对象“相等”</code></pre><p>代码示例：     </p><pre><code class="java">package com.java.chap07.sec14;/** * @author Yan * @date 2019/7/20 21:04 */public class People {    private String name;    public People(String name) {        this.name = name;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    @Override    public String toString() {        return this.getName();    }    @Override    public boolean equals(Object obj) {        String name=((People)obj).getName();        System.out.println(name);        return this.name==name;    }    public static void main(String[] args) {        People people=new People(&quot;张三&quot;);        People people1=new People(&quot;张三&quot;);        People people3=new People(&quot;李四&quot;);        System.out.println(&quot;people.equals(people1)&quot;+people.equals(people1));        System.out.println(&quot;people1.equals(people3)&quot;+people1.equals(people3));        System.out.println(people);        System.out.println(people.toString());    }}</code></pre><h2 id="15-instanceof关键字"><a href="#15-instanceof关键字" class="headerlink" title="15. instanceof关键字"></a>15. instanceof关键字</h2><p>作用：判断一个对象是否属于一个类<br>格式： 对象  instanceof类 返回布尔类型<br>向下转型作判断；    </p><p>代码示例：     </p><p><strong>Animal.java</strong></p><pre><code class="java">package com.java.chap07.sec15;/** * @author Yan * @date 2019/7/20 21:17 */public class Animal {    public void say(){        System.out.println(&quot;我是一个动物&quot;);    }}</code></pre><p><strong>Cat.java</strong></p><pre><code class="java">package com.java.chap07.sec15;/** * @author Yan * @date 2019/7/20 21:17 */public class Cat extends Animal {    public void say(){        System.out.println(&quot;我是一只猫&quot;);    }    /**     * 子类方法     */    public void f2(){        System.out.println(&quot;我喜欢吃鱼&quot;);    }}</code></pre><p><strong>Dog.java</strong></p><pre><code class="java">package com.java.chap07.sec15;/** * @author Yan * @date 2019/7/20 21:17 */public class Dog extends Animal {    public void say(){        System.out.println(&quot;我是一只狗&quot;);    }    /**     * 子类方法     */    public void f2(){        System.out.println(&quot;我的名字是jack&quot;);    }}</code></pre><p><strong>Test.java</strong></p><pre><code class="java">package com.java.chap07.sec15;/** * @author Yan * @date 2019/7/20 21:18 */public class Test {    public static void doSomeThing(Animal animal){        animal.say();        if (animal instanceof Dog){            ((Dog)animal).f2();        }        if (animal instanceof Cat){            ((Cat)animal).f2();        }    }    public static void main(String[] args) {        Animal dog=new Dog();        System.out.println(&quot;dog对象是否属于Animal类：&quot;+(dog instanceof Animal));        System.out.println(&quot;dog对象是否属于Dog类：&quot;+(dog instanceof Dog));        System.out.println(&quot;dog对象是否属于Cat类：&quot;+(dog instanceof Cat));        doSomeThing(new Dog());        doSomeThing(new Cat());    }}</code></pre><h2 id="16-匿名内部类"><a href="#16-匿名内部类" class="headerlink" title="16. 匿名内部类"></a>16. 匿名内部类</h2><p>作用：假如某个类只使用一次，则可以使用匿名内部类。 </p><p>代码示例：    </p><p><strong>A.java</strong></p><pre><code class="java">package com.java.chap07.sec16;/** * @author Yan * @date 2019/7/20 21:34 */public interface A {    public void a();}</code></pre><p><strong>B.java</strong></p><pre><code class="java">package com.java.chap07.sec16;/** * @author Yan * @date 2019/7/20 21:35 */public class B implements A{    @Override    public void a() {        System.out.println(&quot;只使用一次&quot;);    }}</code></pre><p><strong>Test.java</strong></p><pre><code class="java">package com.java.chap07.sec16;/** * @author Yan * @date 2019/7/20 21:35 */public class Test {    public void test(A a){        a.a();    }    public static void main(String[] args) {        Test test=new Test();        test.test(new B());        //匿名内部类        test.test(new A() {            @Override            public void a() {                System.out.println(&quot;匿名内部类，一次性使用&quot;);            }        });    }}</code></pre><h2 id="17-包装类"><a href="#17-包装类" class="headerlink" title="17. 包装类"></a>17. 包装类</h2><p>每个基本类型都有一个对应的类；</p><table><thead><tr><th>序号</th><th>基本类型</th><th>包装类</th></tr></thead><tbody><tr><td>1</td><td>int</td><td>Integer</td></tr><tr><td>2</td><td>char</td><td>Character</td></tr><tr><td>3</td><td>short</td><td>Short</td></tr><tr><td>4</td><td>long</td><td>Long</td></tr><tr><td>5</td><td>float</td><td>Float</td></tr><tr><td>6</td><td>double</td><td>Double</td></tr><tr><td>7</td><td>boolean</td><td>Boolean</td></tr><tr><td>8</td><td>byte</td><td>Byte</td></tr></tbody></table><ol><li>装箱和拆箱</li></ol><pre><code class="java">package com.java.chap07.sec17;/** * @author Yan * @date 2019/7/20 22:02 */public class Demo1 {    public static void main(String[] args) {        int a=1;        Integer i=new Integer(a);    //装箱  把基本变量变成对象变量        int b=i.intValue();   //拆箱  把对象变量变成基本变量        System.out.println(&quot;a=&quot;+a+&quot;,i=&quot;+i+&quot;,b=&quot;+b);    }}</code></pre><ol start="2"><li>自动装箱和拆箱</li></ol><pre><code class="java">package com.java.chap07.sec17;/** * @author Yan * @date 2019/7/20 22:05 */public class Demo2 {    public static void main(String[] args) {        Integer i=1;     //自动装箱的过程  自动把基本数据转换成对象        int i2=i;   //自动拆箱   自动把对象转换成基本数据        System.out.println(&quot;i=&quot;+i+&quot;,i2=&quot;+i2);    }}</code></pre><ol start="3"><li>包装类的作用</li></ol><pre><code class="java">package com.java.chap07.sec17;/** * @author Yan * @date 2019/7/20 22:07 */public class Demo3 {    public static void main(String[] args) {        String a=&quot;1&quot;;        String b=&quot;2&quot;;        int m=Integer.parseInt(a);        int n=Integer.parseInt(b);        System.out.println(&quot;a+b=&quot;+(m+n));    }}</code></pre><h2 id="18-设计模式"><a href="#18-设计模式" class="headerlink" title="18. 设计模式"></a>18. 设计模式</h2><ol><li>单例模式<br>在Java应用中，单例对象能保证在一个JVM中，该对象只有一个实例存在。</li></ol><p>饿汉式     </p><p><strong>Singleton1.java</strong></p><pre><code class="java">package com.java.chap07.sec18;/** * @author Yan * @date 2019/7/21 14:05 */public class Singleton1 {    /**     * 构造方法私有     */    private Singleton1(){    }    /**     * 饿汉式单例实现     */    private static final Singleton1 single1=new Singleton1();    /**     * 静态工厂方式     */    public static Singleton1 getInstance(){        return single1;    }}</code></pre><p><strong>TestSingleton.java</strong></p><pre><code class="java">package com.java.chap07.sec18;/** * @author Yan * @date 2019/7/21 14:06 */public class TestSingleton {    public static void main(String[] args) {        //Singleton1 singleton1=new Singleton1();        Singleton1 singleton1=Singleton1.getInstance();        Singleton1 singleton2=Singleton1.getInstance();        System.out.println(&quot;饿汉式：&quot;+(singleton1==singleton2));        TestSingleton testSingleton=new TestSingleton();        TestSingleton testSingleton2=new TestSingleton();        System.out.println(testSingleton==testSingleton2);    }}</code></pre><p>懒汉式      </p><p><strong>Singleton2.java</strong></p><pre><code class="java">package com.java.chap07.sec18;/** * @author Yan * @date 2019/7/21 14:05 */public class Singleton2 {    /**     * 构造方法私有     */    private Singleton2(){    }    /**     * 懒汉式单例实现    在第一次调用的时候实例化     */    private static Singleton2 single;    /**     * 工厂     */    public synchronized static Singleton2 getInstance(){        if (single==null){            //第一次调用的时候实例化            System.out.println(&quot;第一次调用的时候实例化&quot;);            single=new Singleton2();        }        return single;    }}</code></pre><p><strong>TestSingleton.java</strong></p><pre><code class="java">package com.java.chap07.sec18;/** * @author Yan * @date 2019/7/21 14:06 */public class TestSingleton {    public static void main(String[] args) {        Singleton2 singleton3=Singleton2.getInstance();        Singleton2 singleton4=Singleton2.getInstance();        System.out.println(&quot;懒汉式：&quot;+(singleton3==singleton4));    }}</code></pre><h1 id="Java异常处理"><a href="#Java异常处理" class="headerlink" title="Java异常处理"></a>Java异常处理</h1><h2 id="异常的概念"><a href="#异常的概念" class="headerlink" title="异常的概念"></a>异常的概念</h2><p>代码示例：     </p><pre><code class="java">package com.java.chap08.sec01;/** * @author Yan * @date 2019/7/21 14:30 */public class ExceptionDemo {    public static void main(String[] args) {        String str=&quot;123a&quot;;        int a=Integer.parseInt(str);        System.out.println(a);    }}</code></pre><h2 id="捕获和处理异常"><a href="#捕获和处理异常" class="headerlink" title="捕获和处理异常"></a>捕获和处理异常</h2><p>在Java中，我们用try…catch…来捕获异常；   </p><pre><code class="java">try...catch...finally</code></pre><p>代码示例：     </p><pre><code class="java">package com.java.chap08.sec02;/** * @author Yan * @date 2019/7/21 14:32 */public class Demo1 {    public static void main(String[] args) {        String str=&quot;123a&quot;;        try {            int a=Integer.parseInt(str);        }catch (NumberFormatException e){            e.printStackTrace();        }        System.out.println(&quot;aaaa&quot;);    }}</code></pre><pre><code class="java">package com.java.chap08.sec02;/** * @author Yan * @date 2019/7/21 15:59 */public class Demo2 {    public static void testFinally(){        String str=&quot;123a&quot;;        try{            int a=Integer.parseInt(str);            System.out.println(a);        }catch (Exception e){            e.printStackTrace();            System.out.println(&quot;exception&quot;);            return;        }finally {            System.out.println(&quot;final end&quot;);        }        System.out.println(&quot;end&quot;);    }    public static void main(String[] args) {        testFinally();    }}</code></pre><h2 id="throws和throw关键字"><a href="#throws和throw关键字" class="headerlink" title="throws和throw关键字"></a>throws和throw关键字</h2><p>throws表示当前方法不处理异常，而是交给方法的调用处去处理。<br>throw表示直接抛出一个异常</p><p>代码示例：      </p><p><strong>throws</strong></p><pre><code class="java">package com.java.chap08.sec03;/** * @author Yan * @date 2019/7/21 16:03 */public class Demo1 {    /**     * 把异常向外抛     * @throws NumberFormatException     */    public static void testThrows() throws NumberFormatException {        String str = &quot;123a&quot;;        int a = Integer.parseInt(str);        System.out.println(a);    }    public static void main(String[] args) {        try {            testThrows();        }catch (Exception e){            System.out.println(&quot;在这里处理异常&quot;);            e.printStackTrace();        }        System.out.println(&quot;I&#39;m here&quot;);    }}</code></pre><p><strong>throw</strong></p><pre><code class="java">package com.java.chap08.sec03;/** * @author Yan * @date 2019/7/21 16:07 */public class Demo2 {    public static void testThrow(int a) throws Exception{        if (a==1){            //直接抛出一个异常类            throw new Exception(&quot;有异常&quot;);        }        System.out.println(a);    }    public static void main(String[] args) {        try {            testThrow(1);        } catch (Exception e) {            e.printStackTrace();        }        try {            testThrow(0);        } catch (Exception e) {            e.printStackTrace();        }    }}</code></pre><h2 id="Exception和RuntimeException区别"><a href="#Exception和RuntimeException区别" class="headerlink" title="Exception和RuntimeException区别"></a>Exception和RuntimeException区别</h2><p>Exception 是检查型异常，例如Exception在程序中必须使用try…catch进行处理；</p><p>RuntimeException 是非检查型异常，例如NumberFormatException，可以不使用try…catch进行处理，但是如果产生异常，则异常将由JVM进行处理；       </p><p>RuntimeException 最好也用try…catch捕获。</p><p>代码示例：     </p><pre><code class="java">package com.java.chap08.sec04;/** * @author Yan * @date 2019/7/21 16:12 */public class Demo1 {    /**     * 运行时异常，编译时不检查，可以不适用try...catch捕获     * @throws RuntimeException     */    public static void testRuntimeException() throws RuntimeException {        throw new RuntimeException(&quot;运行时异常&quot;);    }    /**     * Exception异常，编译时异常，必须使用try...catch捕获     * @throws Exception     */    public static void testException() throws Exception{        throw new Exception(&quot;Exception异常&quot;);    }    public static void main(String[] args) {        try{            testRuntimeException();        }catch (Exception e){            e.printStackTrace();        }        try {            testException();        } catch (Exception e) {            e.printStackTrace();        }    }}</code></pre><h2 id="自定义异常类"><a href="#自定义异常类" class="headerlink" title="自定义异常类"></a>自定义异常类</h2><p>代码示例：    </p><p><strong>CustomerException.java</strong></p><pre><code class="java">package com.java.chap08.sec05;/** * 自定义异常，继承自Exception * @author Yan * @date 2019/7/21 16:18 */public class CustomerException extends Exception{    public CustomerException(String message){        super(message);    }}</code></pre><p><strong>TestCustomerException.java</strong></p><pre><code class="java">package com.java.chap08.sec05;/** * @author Yan * @date 2019/7/21 16:19 */public class TestCustomerException {    public static void test() throws CustomerException{        throw new CustomerException(&quot;自定义异常&quot;);    }    public static void main(String[] args) {        try {            test();        } catch (CustomerException e) {            e.printStackTrace();        }    }}</code></pre><h1 id="Java常用类"><a href="#Java常用类" class="headerlink" title="Java常用类"></a>Java常用类</h1><h2 id="Java日期处理类"><a href="#Java日期处理类" class="headerlink" title="Java日期处理类"></a>Java日期处理类</h2><ol><li>Date类</li></ol><pre><code class="java">package com.java.chap09.sec01;import java.util.Date;/** * 日期类Date * @author Yan * @date 2019/7/21 20:56 */public class TestDate {    public static void main(String[] args) {        Date date=new Date();        System.out.println(&quot;当前日期：&quot;+date);    }}</code></pre><ol start="2"><li>Calendar类</li></ol><pre><code class="java">package com.java.chap09.sec01;        import java.util.Calendar;/** * @author Yan * @date 2019/7/21 20:58 */public class TestCalendar {    public static void main(String[] args) {        Calendar calendar = Calendar.getInstance();        System.out.println(calendar.get(Calendar.YEAR));        System.out.println(calendar.get(Calendar.MONTH) + 1);        System.out.println(&quot;现在是&quot; + calendar.get(Calendar.YEAR) + &quot;年&quot;                + (calendar.get(Calendar.MONTH) + 1) + &quot;月&quot;                + calendar.get(Calendar.DAY_OF_MONTH) + &quot;日&quot;                + calendar.get(Calendar.HOUR_OF_DAY) + &quot;时&quot;                + calendar.get(Calendar.MINUTE) + &quot;分&quot;                + calendar.get(Calendar.SECOND) + &quot;秒&quot;);    }}</code></pre><ol start="3"><li>SimpleDateFormat</li></ol><pre><code class="java">package com.java.chap09.sec01;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;/** * @author Yan * @date 2019/7/21 21:05 */public class TestSimpleDateFormat {    /**     * 将日期对象格式为指定格式的日期字符串     * @param date 传入的日期对象     * @param format  格式     * @return     */    public static String formatDate(Date date,String format){        String result=&quot;&quot;;        SimpleDateFormat sdf=new SimpleDateFormat(format);        if (date!=null){            result=sdf.format(date);        }        return result;    }    /**     * 将日期字符串转换成一个日期对象     * @param dataStr 日期字符串     * @param format 格式     * @return     */    public static Date formatDate(String dataStr,String format) throws ParseException {        SimpleDateFormat sdf=new SimpleDateFormat(format);        return sdf.parse(dataStr);    }    public static void main(String[] args) throws ParseException {        Date date=new Date();        //SimpleDateFormat sdf=new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);        //System.out.println(sdf.format(date));        String dataStr=&quot;2010-07-21 21:12:26&quot;;        Date date1=formatDate(dataStr,&quot;yyyy-MM-dd HH:mm:ss&quot;);        System.out.println(formatDate(date,&quot;yyyy-MM-dd HH:mm:ss&quot;));        System.out.println(formatDate(date1,&quot;yyyy-MM-dd HH:mm:ss&quot;));    }}</code></pre><h2 id="String-VS-StringBuffer"><a href="#String-VS-StringBuffer" class="headerlink" title="String VS StringBuffer"></a>String VS StringBuffer</h2><p>String：对String类型的对象操作，等同于重新生成一个对象，然后将引用指向它；</p><p>StringBuffer：对StringBuffer类型的对象操作，操作的始终是用一个对象。     </p><ol><li>String</li></ol><p><img src="https://live.staticflickr.com/65535/48344498272_fa4a07241c_z.jpg" alt></p><p>代码示例：      </p><pre><code class="java">package com.java.chap09.sec02;/** * @author Yan * @date 2019/7/22 14:00 */public class TestString {    public static void main(String[] args) {        String str=&quot;123&quot;;        str+=&quot;abc&quot;;        System.out.println(str);    }}</code></pre><ol start="2"><li>StringBuffer</li></ol><p><img src="https://live.staticflickr.com/65535/48344384271_961416d201_z.jpg" alt></p><p>代码示例：     </p><pre><code class="java">package com.java.chap09.sec02;/** * @author Yan * @date 2019/7/22 14:01 */public class TestStringBuffer {    public static void main(String[] args) {        StringBuffer sb=new StringBuffer(&quot;123&quot;);        sb.append(&quot;abc&quot;);        System.out.println(sb);    }}</code></pre><h2 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h2><blockquote><ol><li>max方法：求最大值</li><li>min方法：求最小值</li><li>round方法：四舍五入</li><li>pow方法：求次幂</li></ol></blockquote><p>代码示例：     </p><pre><code class="java">package com.java.chap09.sec03;/** * @author Yan * @date 2019/7/22 14:10 */public class TestMath {    public static void main(String[] args) {        System.out.println(&quot;最大值：&quot;+Math.max(1,2));        System.out.println(&quot;最小值：&quot;+Math.min(1,2));        System.out.println(&quot;四舍五入：&quot;+Math.round(12.4));        System.out.println(&quot;次幂：&quot;+Math.pow(3,4));    }}</code></pre><h2 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h2><blockquote><ol><li>toString()方法：返回指定数组内容的字符串表示形式</li><li>sort()方法：对指定的类型数组按数字升序进行排序</li><li>binarySearch()方法：使用二分搜索法来搜索指定类型数组，以获得指定的值</li><li>fill()方法：将指定类型值分配给指定类型数组的每个元素</li></ol></blockquote><p>代码示例：      </p><pre><code class="java">package com.java.chap09.sec04;import java.util.Arrays;/** * @author Yan * @date 2019/7/22 14:36 */public class TestArrays {    public static void main(String[] args) {        int arr[]={1,7,3,8,2};        System.out.println(&quot;以字符串形式输出数组：&quot;+Arrays.toString(arr));        Arrays.sort(arr);   //给数组排序        System.out.println(&quot;排序后的数组&quot;+Arrays.toString(arr));        System.out.println(Arrays.binarySearch(arr,7));        Arrays.fill(arr,0);   //将指定内容填充到数组中        System.out.println(&quot;填充数组后的字符串：&quot;+Arrays.toString(arr));    }}</code></pre><h1 id="Java泛型"><a href="#Java泛型" class="headerlink" title="Java泛型"></a>Java泛型</h1><h2 id="泛型引入"><a href="#泛型引入" class="headerlink" title="泛型引入"></a>泛型引入</h2><p>定义：使用泛型可以指代任意对象类型</p><p>代码示例：     </p><p><strong>C1.java</strong></p><pre><code class="java">package com.java.chap10.sec01;/** * @author Yan * @date 2019/7/22 16:00 */public class C1 {    private Integer a;    public C1(Integer a) {        super();        this.a = a;    }    public Integer getA() {        return a;    }    public void setA(Integer a) {        this.a = a;    }    /**     * 打印a的类型     */    public void print(){        System.out.println(&quot;a的类型是：&quot;+a.getClass().getName());    }}</code></pre><p><strong>C2.java</strong></p><pre><code class="java">package com.java.chap10.sec01;/** * @author Yan * @date 2019/7/22 16:02 */public class C2 {    private String a;    public C2(String a) {        super();        this.a = a;    }    public String getA() {        return a;    }    public void setA(String a) {        this.a = a;    }    /**     * 打印a的类型     */    public void print(){        System.out.println(&quot;a的类型是：&quot;+a.getClass().getName());    }}</code></pre><p><strong>C12.java</strong></p><pre><code class="java">package com.java.chap10.sec01;/** * @author Yan * @date 2019/7/22 16:09 */public class C12 {    private Object object;    public C12(Object object) {        super();        this.object = object;    }    public Object getObject() {        return object;    }    public void setObject(Object object) {        this.object = object;    }    /**     * 打印object的类型     */    public void print(){        System.out.println(&quot;a的类型是：&quot;+object.getClass().getName());    }}</code></pre><p><strong>CC.java</strong></p><pre><code class="java">package com.java.chap10.sec01;/** * 定义泛型类 * @author Yan * @date 2019/7/24 15:56 */public class CC&lt;T&gt; {    private T ob;    public CC(T ob) {        super();        this.ob = ob;    }    public T getOb() {        return ob;    }    public void setOb(T ob) {        this.ob = ob;    }    /**     * 打印T的类型     */    public void print(){        System.out.println(&quot;T的实际类型&quot;+ob.getClass().getName());;    }}</code></pre><p><strong>Test.java</strong></p><pre><code class="java">package com.java.chap10.sec01;/** * @author Yan * @date 2019/7/22 16:03 */public class Test1 {    public static void main(String[] args) {        //begin test c1        C1 c1=new C1(1);        c1.print();        int i=c1.getA();        System.out.println(&quot;i=&quot;+i);        //end test c1        //begin test c2        C2 c2=new C2(&quot;Hi&quot;);        c2.print();        String s1=c2.getA();        System.out.println(&quot;s1=&quot;+s1);        //end test c2        //begin test c12        C12 c12=new C12(1);   //向上转型        c12.print();        int i12= (Integer) c12.getObject();   //向下转型        System.out.println(&quot;i12=&quot;+i12);        C12 c121=new C12(&quot;你好&quot;);  //向上转型        c121.print();        String i121=(String) c121.getObject();  //向下转型        System.out.println(&quot;i121=&quot;+i121);        //end test c12        //begin test CC        CC&lt;Integer&gt; cc=new CC&lt;Integer&gt;(1);        cc.print();        int icc=cc.getOb();        System.out.println(&quot;icc=&quot;+icc);        //end test CC        //begin test CC        CC&lt;String&gt; cc1=new CC&lt;String&gt;(&quot;你好&quot;);        cc1.print();        String icc1=cc1.getOb();        System.out.println(&quot;icc1=&quot;+icc1);        //end test CC    }}</code></pre><h2 id="限制泛型"><a href="#限制泛型" class="headerlink" title="限制泛型"></a>限制泛型</h2><p>代码示例：     </p><p><strong>Animal.java</strong></p><pre><code class="java">package com.java.chap10.sec02;/** * @author Yan * @date 2019/7/24 16:07 */public class Animal {    public void print(){        System.out.println(&quot;动物&quot;);    }}</code></pre><p><strong>Cat.java</strong></p><pre><code>package com.java.chap10.sec02;/** * @author Yan * @date 2019/7/24 16:07 */public class Cat extends Animal{    public void print(){        System.out.println(&quot;Cat&quot;);    }}</code></pre><p><strong>Dog.java</strong></p><pre><code class="java">package com.java.chap10.sec02;/** * @author Yan * @date 2019/7/24 16:07 */public class Dog extends Animal{    public void print(){        System.out.println(&quot;Dog&quot;);    }}</code></pre><p><strong>Demo.java</strong></p><pre><code class="java">package com.java.chap10.sec02;/** * @author Yan * @date 2019/7/24 16:08 */public class Demo &lt;T extends Animal&gt;{    private T ob;    public Demo(T ob) {        super();        this.ob = ob;    }    public T getOb() {        return ob;    }    public void setOb(T ob) {        this.ob = ob;    }    public void print(){        System.out.println(&quot;T的类型是： &quot;+ob.getClass().getName());    }}</code></pre><p><strong>Test.java</strong></p><pre><code class="java">package com.java.chap10.sec02;/** * @author Yan * @date 2019/7/24 16:11 */public class Test {    public static void main(String[] args) {        Demo&lt;Dog&gt; demo=new Demo&lt;Dog&gt;(new Dog());        Dog dog=demo.getOb();        dog.print();        Demo&lt;Cat&gt; demo2=new Demo&lt;Cat&gt;(new Cat());        Cat cat=demo2.getOb();        cat.print();        //Demo&lt;Integer&gt; demo3=new Demo&lt;Integer&gt;(2);        Demo&lt;Animal&gt; demo3=new Demo&lt;Animal&gt;(new Animal());    }}</code></pre><h2 id="通配符泛型"><a href="#通配符泛型" class="headerlink" title="通配符泛型"></a>通配符泛型</h2><p>代码示例：     </p><p><strong>Test.java</strong></p><pre><code class="java">package com.java.chap10.sec03;import com.java.chap10.sec02.Animal;import com.java.chap10.sec02.Cat;import com.java.chap10.sec02.Demo;import com.java.chap10.sec02.Dog;/** * @author Yan * @date 2019/7/24 16:23 */public class Test {    /**     * 通配符泛型     * @param animal     */    private static void take(Demo&lt;?&gt; animal){        animal.print();    }    public static void main(String[] args) {        Demo&lt;Dog&gt; dog=new Demo&lt;Dog&gt;(new Dog());        take(dog);        Demo&lt;Cat&gt; cat=new Demo&lt;Cat&gt;(new Cat());        take(cat);        Demo&lt;Animal&gt; animalDemo=new Demo&lt;Animal&gt;(new Animal());        take(animalDemo);    }}</code></pre><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>代码示例：     </p><pre><code class="java">package com.java.chap10.sec04;/** * @author Yan * @date 2019/7/24 19:39 */public class Test {    /**     * 泛型方法     * @param t     * @param &lt;T&gt;     */    public static &lt;T&gt; void f(T t){        System.out.println(&quot;T的类型是：&quot;+t.getClass().getName());    }    public static void main(String[] args) {        f(&quot;&quot;);        f(1);        f(1.0);        f(new Object());    }}</code></pre><h1 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h1><h2 id="Java集合的引入"><a href="#Java集合的引入" class="headerlink" title="Java集合的引入"></a>Java集合的引入</h2><p>代码示例：      </p><p><strong>Student.java</strong></p><pre><code class="java">package com.java.chap11.sec01;/** * @author Yan * @date 2019/7/25 14:40 */public class Student {    private String name;    private int age;    public Student(String name, int age) {        super();        this.name = name;        this.age = age;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }}</code></pre><p><strong>Demo.java</strong></p><pre><code class="java">package com.java.chap11.sec01;import java.util.LinkedList;/** * @author Yan * @date 2019/7/25 14:41 */public class Demo {    public static void main(String[] args) {        Student student[]=new Student[3];        Student student1=new Student(&quot;张三&quot;,1);        Student student2=new Student(&quot;李四&quot;,3);        Student student3=new Student(&quot;王五&quot;,4);        LinkedList&lt;Student&gt; list=new LinkedList&lt;Student&gt;();        list.add(student1);        list.add(student2);        list.add(student3);        /**         * 遍历集合         */        for (int i=0;i&lt;list.size();i++){            Student student4=list.get(i);            System.out.println(student4.getName()+&quot;:&quot;+student4.getAge());        }    }}</code></pre><h2 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h2><p>是Collection接口的子接口，也是最常用的接口。此接口对Collection接口进行了大量的扩展，List集合里的元素是允许重复的。      </p><ol><li>ArrayList实现类</li></ol><p>代码实现：    </p><pre><code class="java">package com.java.chap11.sec02;import java.util.ArrayList;/** * @author Yan * @date 2019/7/25 15:09 */public class TestArrayList {    public static void printArrayList(ArrayList&lt;String&gt; arrayList){        System.out.println(&quot;当前的集合元素&quot;);        for (int i=0;i&lt;arrayList.size();i++){            System.out.print(arrayList.get(i)+&quot; &quot;);        }        System.out.println();    }    public static void main(String[] args) {        ArrayList&lt;String&gt; arrayList=new ArrayList&lt;String&gt;();        //添加元素        arrayList.add(&quot;张三&quot;);        arrayList.add(&quot;李四&quot;);        printArrayList(arrayList);        //将指定的元素插入此列表中的指定位置        arrayList.add(1,&quot;小张三&quot;);        printArrayList(arrayList);        //用指定的元素替代此列表指定位置上的元素        arrayList.set(2,&quot;小李四&quot;);        printArrayList(arrayList);        //移除此列表中指定位上的元素        arrayList.remove(0);        printArrayList(arrayList);    }}</code></pre><ol start="2"><li>LinkedList实现类</li></ol><p>代码示例：    </p><pre><code class="java">package com.java.chap11.sec02;import java.util.LinkedList;/** * @author Yan * @date 2019/7/25 15:36 */public class TestLinkedList {    public static void printLinkedList(LinkedList&lt;String&gt; linkedList){        System.out.println(&quot;当前元素集合：&quot;);        for (int i=0;i&lt;linkedList.size();i++){            System.out.print(linkedList.get(i)+&quot;  &quot;);        }        System.out.println();    }    public static void main(String[] args) {        LinkedList&lt;String&gt; linkedList=new LinkedList&lt;String&gt;();        linkedList.add(&quot;张三&quot;);        linkedList.add(&quot;李四&quot;);        linkedList.add(&quot;王五&quot;);        linkedList.add(&quot;李四&quot;);        linkedList.add(&quot;赵六&quot;);        printLinkedList(linkedList);        //返回此列表中首次出现的指定元素的索引，如果此列表中不包括该元素，则返回-1；        System.out.println(linkedList.indexOf(&quot;李四&quot;));        //获取但不移除此列表的第一个元素；如果此列表为空，则返回null        System.out.println(linkedList.peekFirst());        printLinkedList(linkedList);        //获取但不移除此列表的最后一个元素；如果此列表为空，则返回null        System.out.println(linkedList.peekLast());        printLinkedList(linkedList);        //获取并移除此列表的第一个元素；如果此列表为空，则返回null        System.out.println(linkedList.pollFirst());        printLinkedList(linkedList);        //获取并移除此列表的最后一个元素；如果此列表为空，则返回null        System.out.println(linkedList.pollLast());        printLinkedList(linkedList);    }}</code></pre><h2 id="集合的遍历"><a href="#集合的遍历" class="headerlink" title="集合的遍历"></a>集合的遍历</h2><ol><li>Iterator</li></ol><p>代码示例：     </p><pre><code class="java">package com.java.chap11.sec03;import com.java.chap11.sec01.Student;import java.util.Iterator;import java.util.LinkedList;/** * @author Yan * @date 2019/7/25 15:51 */public class TestIterator {    public static void main(String[] args) {        LinkedList&lt;Student&gt; list=new LinkedList&lt;Student&gt;();        list.add(new Student(&quot;张三&quot;,10));        list.add(new Student(&quot;李四&quot;,20));        list.add(new Student(&quot;王五&quot;,30));        /**         * 用Iterator遍历集合         */        Iterator&lt;Student&gt; iterator=list.iterator();   //返回一个迭代器        while(iterator.hasNext()){            Student s=iterator.next();    //返回迭代的下一个元素            System.out.println(&quot;姓名：&quot;+s.getName()+&quot;   年龄：&quot;+s.getAge());        }    }}</code></pre><ol start="2"><li>foreach</li></ol><p>代码示例：     </p><pre><code class="java">package com.java.chap11.sec03;import com.java.chap11.sec01.Student;import java.util.Iterator;import java.util.LinkedList;/** * @author Yan * @date 2019/7/25 15:57 */public class TestForeach {    public static void main(String[] args) {        LinkedList&lt;Student&gt; list=new LinkedList&lt;Student&gt;();        list.add(new Student(&quot;张三&quot;,10));        list.add(new Student(&quot;李四&quot;,20));        list.add(new Student(&quot;王五&quot;,30));        /**         * 用Foreach遍历集合         */        for (Student s:list){            System.out.println(&quot;姓名：&quot;+s.getName()+&quot;   年龄：&quot;+s.getAge());        }    }}</code></pre><h2 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h2><p>是Collertion接口的子接口，没有对Collection接口进行扩展，里面不允许存重复的内容。     </p><ol><li>HashSet类</li></ol><p>代码示例：     </p><pre><code class="java">package com.java.chap11.sec04;import java.util.HashSet;import java.util.Iterator;/** * @author Yan * @date 2019/7/25 16:02 */public class TestHashSet {    public static void main(String[] args) {        /**         * 1. HashSet是无序的         * 2. 不允许有重复值         */        HashSet&lt;String&gt; hashSet=new HashSet&lt;String&gt;();        hashSet.add(&quot;1&quot;);        hashSet.add(&quot;2&quot;);        hashSet.add(&quot;5&quot;);        hashSet.add(&quot;4&quot;);        hashSet.add(&quot;2&quot;);        /**         * 用Iterator遍历集合         */        Iterator&lt;String&gt; iterator=hashSet.iterator();        while (iterator.hasNext()){            String s=iterator.next();            System.out.println(s+&quot; &quot;);        }    }}</code></pre><h2 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h2><p>是存放一对值的最大接口，即接口中的每一个元素都是一对，以key-&gt;value键值对的形式保存。     </p><ol><li>HashMap类</li></ol><p>代码示例：     </p><pre><code class="java">package com.java.chap11.sec05;import com.java.chap11.sec01.Student;import java.util.HashMap;import java.util.Iterator;/** * @author Yan * @date 2019/7/25 16:08 */public class TestHashMap {    public static void main(String[] args) {        HashMap&lt;String, Student&gt; hashMap=new HashMap&lt;String,Student&gt;();        hashMap.put(&quot;1号&quot;,new Student(&quot;张三&quot;,10));        hashMap.put(&quot;2号&quot;,new Student(&quot;李四&quot;,20));        hashMap.put(&quot;3号&quot;,new Student(&quot;王五&quot;,30));        // 通过key获取value        Student student=hashMap.get(&quot;1号&quot;);        System.out.println(student.getName()+&quot;:&quot;+student.getAge());        Iterator&lt;String&gt; iterator=hashMap.keySet().iterator();  //获取key的集合，再获取迭代器        while (iterator.hasNext()){            String key=iterator.next();    //获取key            Student student1=hashMap.get(key);   //通过key获取value            System.out.println(&quot;key=&quot;+key+&quot;value=[&quot;+student1.getName()+&quot;,&quot;+student1.getAge()+&quot;]&quot;);        }    }}</code></pre><h1 id="Java多线程"><a href="#Java多线程" class="headerlink" title="Java多线程"></a>Java多线程</h1><h2 id="多线程的引入"><a href="#多线程的引入" class="headerlink" title="多线程的引入"></a>多线程的引入</h2><p>定义：同时对多项任务加以控制</p><p>代码示例：     </p><p><strong>Demo.java</strong></p><pre><code class="java">package com.java.chap12.sec01;/** * @author Yan * @date 2019/7/27 13:15 */public class Demo1 {    /**     * 听音乐     */    private static void music(){        for (int i=0;i&lt;1000;i++){            System.out.println(&quot;听音乐&quot;);        }    }    /**     * 吃饭     *     */    private static void eat(){        for (int i=0;i&lt;1000;i++){            System.out.println(&quot;吃饭&quot;);        }    }    public static void main(String[] args) {        //music();        //eat();        /**         * 利用多线程实现一边吃饭一边听歌         */        Music musicThread=new Music();        Eat eatThread=new Eat();        musicThread.start();        eatThread.start();    }}</code></pre><p><strong>Eat.java</strong></p><pre><code class="java">package com.java.chap12.sec01;/** * @author Yan * @date 2019/7/27 13:18 */public class Eat extends Thread {    @Override    public void run() {        for (int i=0;i&lt;1000;i++){            try {                Thread.sleep(100);                System.out.println(&quot;吃饭&quot;);            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }}</code></pre><p><strong>Music.java</strong></p><pre><code class="java">package com.java.chap12.sec01;/** * @author Yan * @date 2019/7/27 13:19 */public class Music extends Thread {    @Override    public void run() {        for (int i=0;i&lt;1000;i++){            try {                Thread.sleep(100);                System.out.println(&quot;听音乐&quot;);            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }}</code></pre><h2 id="Java多线程实现"><a href="#Java多线程实现" class="headerlink" title="Java多线程实现"></a>Java多线程实现</h2><ol><li>继承Thread类</li></ol><p>代码示例：     </p><pre><code class="java">package com.java.chap12.sec02;/** * @author Yan * @date 2019/7/27 13:24 */public class Thread1 extends Thread {    private int baoZi=1;    private String threadName;    public Thread1(String threadName) {        super();        this.threadName = threadName;    }    @Override    public synchronized void run() {        while (baoZi&lt;=10){            System.out.println(threadName+&quot;吃第&quot;+baoZi+&quot;包子&quot;);            baoZi++;        }    }    public static void main(String[] args) {        System.out.println(&quot;张三，李四一起吃包子，每人吃了10个&quot;);        Thread1 t1=new Thread1(&quot;张三线程&quot;);        Thread1 t2=new Thread1(&quot;李四线程&quot;);        t1.start();        t2.start();    }}</code></pre><ol start="2"><li>实现Runnable接口</li></ol><p>代码示例：    </p><pre><code class="java">package com.java.chap12.sec02;/** * @author Yan * @date 2019/7/27 13:29 */public class Thread2 implements Runnable {    private int baoZi=1;    private String threadName;    public Thread2(String threadName) {        super();        this.threadName = threadName;    }    @Override    public synchronized void run() {        while (baoZi&lt;=10){            System.out.println(threadName+&quot;吃第&quot;+baoZi+&quot;包子&quot;);            baoZi++;        }    }    public static void main(String[] args) {        //System.out.println(&quot;张三，李四一起吃包子，每人吃了10个&quot;);        //Thread2 t1=new Thread2(&quot;张三线程&quot;);        //Thread2 t2=new Thread2(&quot;李四线程&quot;);        //Thread t11=new Thread(t1);        //Thread t12=new Thread(t2);        //t11.start();        //t12.start();        Thread2 t1=new Thread2(&quot;超级张三线程&quot;);        Thread t11=new Thread(t1);        Thread t12=new Thread(t1);        Thread t13=new Thread(t1);        Thread t14=new Thread(t1);        //实现资源共享        t11.start();        t12.start();        t13.start();        t14.start();    }}</code></pre><h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p><img src="https://live.staticflickr.com/65535/48385151952_855767c53c_z.jpg" alt></p><blockquote><ol><li>创建状态<br>在程序中用构造方法创建了一个线程对象后，新的线程对象便处于新建状态，此时，它已经有了相应的内存空间和其他资源，但还处于不可运行状态。新建一个线程对象可采用Thread类的构造方法来实现，例如，“Thread thread=new Thread();”。</li></ol></blockquote><blockquote><ol start="2"><li>就绪状态<br>新建线程对象后，调用该线程的start()方法就可以启动线程。当线程启动时，线程进入就绪状态。此时，线程将进入线程队列排队，等待CPU服务，这表明它已经具备了运行条件。</li></ol></blockquote><blockquote><ol start="3"><li>运行状态<br>当就绪状态的线程被调用并获得处理器资源时，线程就进入了运行状态。此时，自动调用该线程对象的run()方法。run()方法定义了该线程的操作和功能。</li></ol></blockquote><blockquote><ol start="4"><li>堵塞状态<br>一个正在运行的线程在某些特殊情况下，如被人为挂起或需要执行耗时的输入/输出操作时，将让出CPU并暂时中止自己的执行，进入堵塞状态，堵塞时，线程不能进入排队队列，只有当引起堵塞的原因被消除后，线程才可以转入就绪状态。</li></ol></blockquote><blockquote><ol start="5"><li>死亡状态<br>线程调用stop()方法时或run()方法执行结束后，即处于死亡状态。处于死亡状态的线程不具有继续运行的能力。</li></ol></blockquote><h2 id="线程常用方法"><a href="#线程常用方法" class="headerlink" title="线程常用方法"></a>线程常用方法</h2><ol><li>getName(); 返回该线程的名称。</li><li>currentThread(); 返回对当前正在执行的线程对象的引用。</li><li>isAlive(); 测试线程是否处于活动状态。</li><li>sleep(); 线程休眠。</li><li>setPriority(int newPriority); 更改线程的优先级。</li><li>yield(); 暂停当前正在执行的线程对象，并执行其他线程。</li></ol><p>代码示例：     </p><p><strong>getName()、currentThread()</strong></p><pre><code class="java">package com.java.chap12.sec04;import javax.swing.plaf.TableHeaderUI;/** * @author Yan * @date 2019/7/27 14:23 */public class Demo1 implements Runnable{    @Override    public void run() {        for (int i=0;i&lt;10;i++){            //获取当前线程            Thread t=Thread.currentThread();            System.out.println(t.getName()+&quot;:&quot;+i);  //返回线程的名称        }    }    public static void main(String[] args) {        Demo1 demo1=new Demo1();        new Thread(demo1).start();        new Thread(demo1).start();        new Thread(demo1,&quot;线程3&quot;).start();    }}</code></pre><p><strong>isAlive()</strong></p><pre><code class="java">package com.java.chap12.sec04;/** * @author Yan * @date 2019/7/27 14:35 */public class Demo2 implements Runnable{    @Override    public void run() {        for (int i=0;i&lt;10;i++){            //获取当前线程            Thread t=Thread.currentThread();            System.out.println(t.getName()+&quot;:&quot;+i);  //返回线程的名称        }    }    public static void main(String[] args) {        Demo2 demo2=new Demo2();        Thread t1=new Thread(demo2);        System.out.println(&quot;t1是否活动：&quot;+t1.isAlive());        t1.start();        System.out.println(&quot;t1是否活动：&quot;+t1.isAlive());    }}</code></pre><p><strong>sleep()</strong></p><pre><code class="java">package com.java.chap12.sec04;/** * @author Yan * @date 2019/7/27 14:35 */public class Demo3 implements Runnable{    @Override    public void run() {        for (int i=0;i&lt;10;i++){            try {                Thread.sleep(1000);                //获取当前线程                Thread t=Thread.currentThread();                System.out.println(t.getName()+&quot;:&quot;+i);  //返回线程的名称            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }    public static void main(String[] args) {        Demo3 demo2=new Demo3();        Thread t1=new Thread(demo2);        t1.start();    }}</code></pre><p><strong>setPriority(int newPriority)</strong></p><pre><code class="java">package com.java.chap12.sec04;/** * @author Yan * @date 2019/7/27 14:35 */public class Demo4 implements Runnable{    @Override    public void run() {        for (int i=0;i&lt;10;i++){            try {                Thread.sleep(1000);                //获取当前线程                Thread t=Thread.currentThread();                System.out.println(t.getName()+&quot;:&quot;+i);  //返回线程的名称            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }    public static void main(String[] args) {        Demo4 demo4=new Demo4();        Thread t1=new Thread(demo4,&quot;线程A&quot;);        Thread t2=new Thread(demo4,&quot;线程B&quot;);        Thread t3=new Thread(demo4,&quot;线程C&quot;);        t1.setPriority(Thread.MAX_PRIORITY);        t2.setPriority(Thread.MIN_PRIORITY);        t3.setPriority(Thread.NORM_PRIORITY);        t1.start();        t2.start();        t3.start();    }}</code></pre><p><strong>yield()</strong></p><pre><code class="java">package com.java.chap12.sec04;/** * @author Yan * @date 2019/7/27 14:35 */public class Demo5 implements Runnable {    @Override    public void run() {        for (int i = 0; i &lt; 10; i++) {            try {                Thread.sleep(1000);                //获取当前线程                Thread t = Thread.currentThread();                System.out.println(t.getName() + &quot;:&quot; + i);  //返回线程的名称                if (i==5){                    System.out.println(&quot;线程礼让&quot;);                    Thread.currentThread().yield();                }            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }    public static void main(String[] args) {        Demo5 demo5 = new Demo5();        new Thread(demo5, &quot;线程A&quot;).start();        new Thread(demo5, &quot;线程B&quot;).start();    }}</code></pre><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><ol><li><p>同步方法</p></li><li><p>同步锁</p></li></ol><p>代码示例：     </p><p><strong>Demo2.java</strong></p><pre><code class="java">package com.java.chap12.sec05;/** * @author Yan * @date 2019/7/27 14:54 */public class Demo2 implements Runnable {    private int baoZi=10;    /**     * 同步方法     */    @Override    public synchronized void run() {        while (baoZi&gt;0){            System.out.println(Thread.currentThread().getName()+&quot;吃了第&quot;+baoZi+&quot;包子&quot;);            baoZi--;        }    }    public static void main(String[] args) {        Demo2 demo1=new Demo2();        new Thread(demo1,&quot;张三&quot;).start();        new Thread(demo1,&quot;李四&quot;).start();        new Thread(demo1,&quot;王五&quot;).start();    }}</code></pre><p><strong>Demo3.java</strong></p><pre><code class="java">package com.java.chap12.sec05;/** * @author Yan * @date 2019/7/27 14:54 */public class Demo3 implements Runnable {    private int baoZi = 10;    @Override    public void run() {        /**         * 同步块         */        synchronized (this) {            while (baoZi &gt; 0) {                System.out.println(Thread.currentThread().getName() + &quot;吃了第&quot; + baoZi + &quot;包子&quot;);                baoZi--;            }        }    }    public static void main(String[] args) {        Demo3 demo1 = new Demo3();        new Thread(demo1, &quot;张三&quot;).start();        new Thread(demo1, &quot;李四&quot;).start();        new Thread(demo1, &quot;王五&quot;).start();    }}</code></pre><h1 id="Java图形界面Swing框架"><a href="#Java图形界面Swing框架" class="headerlink" title="Java图形界面Swing框架"></a>Java图形界面Swing框架</h1><h2 id="Swing简介"><a href="#Swing简介" class="headerlink" title="Swing简介"></a>Swing简介</h2><ol><li>Swing是Java的一个图形框架，继承自AWT；</li><li>Swing主要涉及到容器，组件，还有布局管理器；</li><li>Swing与用户交互的时候还涉及到事件概念</li></ol><h2 id="JFrame容器"><a href="#JFrame容器" class="headerlink" title="JFrame容器"></a>JFrame容器</h2><ol><li><p>public void setVisible(boolean b):根据参数b的值显示或隐藏此窗体</p></li><li><p>public void setSize(int width,int height):调整组件的大小，使其宽度为width，高度为height</p></li><li><p>public void setLocation(int x,.int y):将组件移到新位置。通过此组件父级坐标空间中的x和y参数来指定新位置的左上角</p></li><li><p>public Container getContentPane():返回此窗体的contentPane对象</p></li><li><p>public void setBackground(Color c):设置组件的背景色</p></li></ol><p>代码示例：     </p><pre><code class="java">package com.java.chap13.sec02;import javax.swing.*;import java.awt.*;/** * @author Yan * @date 2019/7/27 15:38 */public class JFrameTest {    public static void main(String[] args) {        JFrame jFrame=new JFrame(&quot;JFrame窗体&quot;);        /*Container c=jFrame.getContentPane();        c.setBackground(Color.blue);*/        jFrame.getContentPane().setBackground(Color.red);   //设置容器的背景颜色        jFrame.setLocation(300,200);   //设置容器的位置        jFrame.setSize(500,500);    //设置容器大小        jFrame.setVisible(true);  //让容器显示    }}</code></pre><h2 id="JButton组件"><a href="#JButton组件" class="headerlink" title="JButton组件"></a>JButton组件</h2><p>代码示例：     </p><pre><code class="java">package com.java.chap13.sec03;import javax.swing.*;import java.awt.*;/** * @author Yan * @date 2019/7/27 16:18 */public class JButtonTest {    public static void main(String[] args) {        JFrame jFrame=new JFrame(&quot;JButton测试&quot;);        JButton jButton=new JButton(&quot;这是一个按钮&quot;);        jFrame.add(jButton);        jFrame.getContentPane().setBackground(Color.red);   //设置容器的背景颜色        jFrame.setLocation(300,200);   //设置容器的位置        jFrame.setSize(500,500);    //设置容器大小        jFrame.setVisible(true);  //让容器显示        jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);    }}</code></pre><h2 id="Swing布局管理器"><a href="#Swing布局管理器" class="headerlink" title="Swing布局管理器"></a>Swing布局管理器</h2><ol><li>FlowLayout流式布局<br>使用此种布局方式会使所有的组件像流水一样依次进行排列</li></ol><p>代码示例：     </p><pre><code class="java">package com.java.chap13.sec04;import javax.swing.*;import java.awt.*;/** * FlowLayout流式布局 * @author Yan * @date 2019/7/27 16:26 */public class FlowLayout {    public static void main(String[] args) {        JFrame jFrame=new JFrame(&quot;FlowLayout测试&quot;);        //jFrame.setLayout(new java.awt.FlowLayout());        //jFrame.setLayout(new java.awt.FlowLayout(java.awt.FlowLayout.LEFT));        jFrame.setLayout(new java.awt.FlowLayout(java.awt.FlowLayout.LEFT,15,15));        JButton jButton=null;        for(int i=0;i&lt;9;i++){            jButton=new JButton(&quot;JButton&quot;+i);            jFrame.add(jButton);        }        jFrame.getContentPane().setBackground(Color.red);   //设置容器的背景颜色        jFrame.setLocation(300,200);   //设置容器的位置        jFrame.setSize(500,500);    //设置容器大小        jFrame.setVisible(true);  //让容器显示        jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);    }}</code></pre><ol start="2"><li>BorderLayout<br>使用此种布局方式将一个窗体的版面划分成东、西、南、北、中5个区域，可以直接将需要的组件放到这5个区域中</li></ol><p>代码示例：     </p><pre><code class="java">package com.java.chap13.sec04;import javax.swing.*;import java.awt.*;/** * * @author Yan * @date 2019/7/28 15:35 */public class BorderLayoutTest {    public static void main(String[] args) {        JFrame jFrame=new JFrame(&quot;BorderLayout测试&quot;);        //jFrame.setLayout(new BorderLayout());        jFrame.setLayout(new BorderLayout(5,5));        jFrame.add(new JButton(&quot;东&quot;),BorderLayout.EAST);        jFrame.add(new JButton(&quot;西&quot;),BorderLayout.WEST);        jFrame.add(new JButton(&quot;南&quot;),BorderLayout.SOUTH);        jFrame.add(new JButton(&quot;北&quot;),BorderLayout.NORTH);        jFrame.add(new JButton(&quot;中&quot;),BorderLayout.CENTER);        jFrame.getContentPane().setBackground(Color.red);   //设置容器的背景颜色        jFrame.setLocation(300,200);   //设置容器的位置        jFrame.setSize(500,500);    //设置容器大小        jFrame.setVisible(true);  //让容器显示        jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);    }}</code></pre><ol start="3"><li>GridLayout表格布局<br>使用此种布局是以表格的形式进行布局管理的，在使用此布局管理器时必须设置显示的行数和列数</li></ol><p>代码示例：      </p><pre><code class="java">package com.java.chap13.sec04;import javax.swing.*;import java.awt.*;/** * @author Yan * @date 2019/7/28 15:39 */public class GridLayoutTest {    public static void main(String[] args) {        JFrame jFrame=new JFrame(&quot;GridLayout测试&quot;);        jFrame.setLayout(new GridLayout(4,5,5,5));        JButton jButton=null;        for (int i=0;i&lt;19;i++){            jButton=new JButton(&quot;JButton&quot;+i);            jFrame.add(jButton);        }        jFrame.getContentPane().setBackground(Color.red);   //设置容器的背景颜色        jFrame.setLocation(300,200);   //设置容器的位置        jFrame.setSize(500,500);    //设置容器大小        jFrame.setVisible(true);  //让容器显示        jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);    }}</code></pre><ol start="4"><li>绝对布局</li></ol><p>代码示例：     </p><pre><code class="java">package com.java.chap13.sec04;import javax.swing.*;import java.awt.*;/** * @author Yan * @date 2019/7/28 15:44 */public class AbsoluteLayoutTest {    public static void main(String[] args) {        JFrame jFrame=new JFrame(&quot;绝对布局测试&quot;);        jFrame.setLayout(null);        JButton jButton1=new JButton(&quot;按钮1&quot;);        JButton jButton2=new JButton(&quot;按钮2&quot;);        jFrame.add(jButton1);        jFrame.add(jButton2);        jButton1.setBounds(50,10,100,20);        jButton2.setBounds(70,40,200,30);        jFrame.getContentPane().setBackground(Color.red);   //设置容器的背景颜色        jFrame.setLocation(300,200);   //设置容器的位置        jFrame.setSize(500,500);    //设置容器大小        jFrame.setVisible(true);  //让容器显示        jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);    }}</code></pre><h2 id="JLable-组件"><a href="#JLable-组件" class="headerlink" title="JLable 组件"></a>JLable 组件</h2><p>代码示例：    </p><pre><code class="java">package com.java.chap13.sec05;import javax.swing.*;import java.awt.*;/** * @author Yan * @date 2019/7/28 16:02 */public class JLableTest {    public static void main(String[] args) {        JFrame jFrame=new JFrame(&quot;JLable测试&quot;);        JLabel jLabel=new JLabel(&quot;JLable组件&quot;,JLabel.CENTER);        jFrame.add(jLabel);        jFrame.getContentPane().setBackground(Color.red);   //设置容器的背景颜色        jFrame.setLocation(300,200);   //设置容器的位置        jFrame.setSize(500,500);    //设置容器大小        jFrame.setVisible(true);  //让容器显示        jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);    }}</code></pre><h2 id="文本框组件"><a href="#文本框组件" class="headerlink" title="文本框组件"></a>文本框组件</h2><ol><li>JTextField 文本框</li></ol><p>代码示例：     </p><pre><code class="java">package com.java.chap13.sec06;import javax.swing.*;import java.awt.*;/** * @author Yan * @date 2019/7/28 16:17 */public class JTextFiledTest {    public static void main(String[] args) {        JFrame jFrame=new JFrame(&quot;JTextFiled单行文本框测试&quot;);        jFrame.setLayout(new GridLayout(1,2,10,10));        JLabel jLabel=new JLabel(&quot;用户名：&quot;);        JTextField jTextField=new JTextField();        jFrame.add(jLabel);        jFrame.add(jTextField);        jFrame.getContentPane().setBackground(Color.red);   //设置容器的背景颜色        jFrame.setLocation(300,200);   //设置容器的位置        jFrame.setSize(500,500);    //设置容器大小        jFrame.setVisible(true);  //让容器显示        jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);    }}</code></pre><ol start="2"><li>JPasswordField 密码框</li></ol><p>代码示例：      </p><pre><code class="java">package com.java.chap13.sec06;import javax.swing.*;import java.awt.*;/** * @author Yan * @date 2019/7/28 16:42 */public class JPasswordFiledTest {    public static void main(String[] args) {        JFrame jFrame = new JFrame(&quot;JPasswordFiled密码框测试&quot;);        jFrame.setLayout(new GridLayout(2, 2, 10, 10));        JLabel jLabel = new JLabel(&quot;用户名：&quot;);        JTextField jTextField = new JTextField();        JLabel jLabe2 = new JLabel(&quot;密码：&quot;);        JPasswordField jPasswordField=new JPasswordField();        jFrame.add(jLabel);        jFrame.add(jTextField);        jFrame.add(jLabe2);        jFrame.add(jPasswordField);        jFrame.getContentPane().setBackground(Color.red);   //设置容器的背景颜色        jFrame.setLocation(300, 200);   //设置容器的位置        jFrame.setSize(500, 500);    //设置容器大小        jFrame.setVisible(true);  //让容器显示        jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);    }}</code></pre><ol start="3"><li>JTextArea 文本域</li></ol><p>代码示例：     </p><pre><code class="java">package com.java.chap13.sec06;import javax.swing.*;import java.awt.*;/** * @author Yan * @date 2019/7/28 16:17 */public class JTextAreaTest {    public static void main(String[] args) {        JFrame jFrame = new JFrame(&quot;JTextArea文本域测试&quot;);        jFrame.setLayout(new GridLayout(1, 2, 10, 10));        JLabel jLabel = new JLabel(&quot;描述：&quot;);        JTextArea jTextArea = new JTextArea();        jFrame.add(jLabel);        jFrame.add(jTextArea);        jFrame.getContentPane().setBackground(Color.red);   //设置容器的背景颜色        jFrame.setLocation(300, 200);   //设置容器的位置        jFrame.setSize(500, 500);    //设置容器大小        jFrame.setVisible(true);  //让容器显示        jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);    }}</code></pre><h2 id="JPanel-轻量级容器"><a href="#JPanel-轻量级容器" class="headerlink" title="JPanel 轻量级容器"></a>JPanel 轻量级容器</h2><p>代码示例：     </p><pre><code class="java">package com.java.chap13.sec07;import javax.swing.*;import javax.swing.border.EmptyBorder;import java.awt.*;/** * @author Yan * @date 2019/7/28 16:50 */public class JPanelTest {    public static void main(String[] args) {        JFrame jFrame = new JFrame(&quot;JPanel面板测试&quot;);        JPanel jPanel=new JPanel();        jPanel.setLayout(new GridLayout(3,2,10,10));        jFrame.add(jPanel);        jPanel.setBorder(new EmptyBorder(10,10,10,10));   //设置边距        JLabel jLabel = new JLabel(&quot;用户名：&quot;);        JTextField jTextField = new JTextField();        JLabel jLabe2 = new JLabel(&quot;密码：&quot;);        JPasswordField jPasswordField = new JPasswordField();        JButton jButton=new JButton(&quot;登录&quot;);        JButton jButton2=new JButton(&quot;重置&quot;);        jPanel.add(jLabel);        jPanel.add(jTextField);        jPanel.add(jLabe2);        jPanel.add(jPasswordField);        jPanel.add(jButton);        jPanel.add(jButton2);        jFrame.getContentPane().setBackground(Color.red);   //设置容器的背景颜色        jFrame.setLocation(300, 200);   //设置容器的位置        jFrame.setSize(500, 500);    //设置容器大小        jFrame.setVisible(true);  //让容器显示        jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);    }}</code></pre><h2 id="Swing事件处理"><a href="#Swing事件处理" class="headerlink" title="Swing事件处理"></a>Swing事件处理</h2><p>代码示例：     </p><p><strong>demo1</strong></p><pre><code class="java">package com.java.chap13.sec08;import javax.swing.*;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;/** * @author Yan * @date 2019/7/28 22:11 */class JButtonListener implements ActionListener{    @Override    public void actionPerformed(ActionEvent e) {        System.out.println(e.getActionCommand());        JOptionPane.showMessageDialog(null,&quot;我被点击了&quot;);    }}public class EventTest1 {    public static void main(String[] args) {        JFrame jFrame = new JFrame(&quot;Swing事件&quot;);        JButton jButton=new JButton(&quot;我是一个按钮&quot;);        JButtonListener jButtonListener=new JButtonListener();        jButton.addActionListener(jButtonListener);  //添加/注册事件监听        jFrame.add(jButton);        jFrame.getContentPane().setBackground(Color.red);   //设置容器的背景颜色        jFrame.setLocation(300, 200);   //设置容器的位置        jFrame.setSize(500, 500);    //设置容器大小        jFrame.setVisible(true);  //让容器显示        jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);    }}</code></pre><p><strong>demo2</strong></p><pre><code class="java">package com.java.chap13.sec08;import javax.swing.*;import java.awt.*;import java.awt.event.WindowEvent;import java.awt.event.WindowListener;/** * @author Yan * @date 2019/7/28 22:17 *///class MyWindowListener implements WindowListener {////    @Override//    public void windowOpened(WindowEvent e) {//        System.out.println(&quot;窗口被打开&quot;);//    }////    @Override//    public void windowClosing(WindowEvent e) {//        System.out.println(&quot;窗口关闭&quot;);//    }////    @Override//    public void windowClosed(WindowEvent e) {//        System.out.println(&quot;窗口被关闭&quot;);//    }////    @Override//    public void windowIconified(WindowEvent e) {//        System.out.println(&quot;窗口最小化&quot;);//    }////    @Override//    public void windowDeiconified(WindowEvent e) {//        System.out.println(&quot;窗口从最小化恢复&quot;);//    }////    @Override//    public void windowActivated(WindowEvent e) {//        System.out.println(&quot;窗口被选中&quot;);//    }////    @Override//    public void windowDeactivated(WindowEvent e) {//        System.out.println(&quot;窗口选中被取消&quot;);//    }//}public class EventTest2 {    public static void main(String[] args) {        JFrame jFrame = new JFrame(&quot;Swing事件&quot;);        //MyWindowListener myWindowListener=new MyWindowListener();        //jFrame.addWindowListener(myWindowListener);        jFrame.addWindowListener(new WindowListener() {            @Override            public void windowOpened(WindowEvent e) {                System.out.println(&quot;窗口被打开&quot;);            }            @Override            public void windowClosing(WindowEvent e) {                System.out.println(&quot;窗口关闭&quot;);            }            @Override            public void windowClosed(WindowEvent e) {                System.out.println(&quot;窗口被关闭&quot;);            }            @Override            public void windowIconified(WindowEvent e) {                System.out.println(&quot;窗口最小化&quot;);            }            @Override            public void windowDeiconified(WindowEvent e) {                System.out.println(&quot;窗口从最小化恢复&quot;);            }            @Override            public void windowActivated(WindowEvent e) {                System.out.println(&quot;窗口被选中&quot;);            }            @Override            public void windowDeactivated(WindowEvent e) {                System.out.println(&quot;窗口选中被取消&quot;);            }        });        jFrame.getContentPane().setBackground(Color.red);   //设置容器的背景颜色        jFrame.setLocation(300, 200);   //设置容器的位置        jFrame.setSize(500, 500);    //设置容器大小        jFrame.setVisible(true);  //让容器显示        jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);    }}</code></pre><p><strong>demo3</strong></p><pre><code class="java">package com.java.chap13.sec08;import javax.swing.*;import java.awt.*;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;/** * @author Yan * @date 2019/7/28 22:24 *///class MyWindowAdapter extends WindowAdapter{//    @Override//    public void windowClosing(WindowEvent e) {//        super.windowClosing(e);//        System.out.println(&quot;窗口关闭。。。。。。。&quot;);//    }//}public class EventTest3 {    public static void main(String[] args) {        JFrame jFrame = new JFrame(&quot;Swing事件&quot;);        //MyWindowAdapter myWindowAdapter=new MyWindowAdapter();        //jFrame.addWindowListener(myWindowAdapter);        jFrame.addWindowListener(new WindowAdapter() {            @Override            public void windowClosing(WindowEvent e) {                super.windowClosing(e);                System.out.println(&quot;窗口关闭。。。。&quot;);            }        });        jFrame.getContentPane().setBackground(Color.red);   //设置容器的背景颜色        jFrame.setLocation(300, 200);   //设置容器的位置        jFrame.setSize(500, 500);    //设置容器大小        jFrame.setVisible(true);  //让容器显示        jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);    }}</code></pre><h1 id="Java-IO流"><a href="#Java-IO流" class="headerlink" title="Java IO流"></a>Java IO流</h1><h2 id="IO流简介"><a href="#IO流简介" class="headerlink" title="IO流简介"></a>IO流简介</h2><p>流是一组有顺序的，有起点和终点的字节集合，是对数据传输的总称或抽象。即数据再两设备间的传输称为流，流的本质是数据传输，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。</p><p><img src="https://live.staticflickr.com/65535/48411733786_ac1f14f1b1_b.jpg" alt></p><blockquote><p>IO 流的分类<br>根据处理数据类型的不同分类：字符流和字节流<br>根据数据流向不同分为：输入流和输出流</p></blockquote><h2 id="文件操作File类"><a href="#文件操作File类" class="headerlink" title="文件操作File类"></a>文件操作File类</h2><ol><li>public boolean mkdir()：创建此抽象路径名指定的目录</li><li>public boolean createNewFile():创建一个文件</li><li>public boolean delete():删除此抽象路径名表示的文件或目录。如果此路径名表示一个目录，则该目录必须为空才能删除</li><li>public boolean exists():测试此抽象路径名表示的文件或目录是否存在</li><li>public File[] listFiles():返回一个抽象路径名数组，这些路径名表示此抽象路径名表示的目录中的文件</li><li>public boolean idDirectory():测试此抽象路径名表示的文件是否是一个目录</li></ol><p>代码示例：     </p><p><strong>Demo1.java</strong></p><pre><code class="java">package com.java.chap14.sec02;import java.io.File;import java.io.IOException;/** * @author Yan * @date 2019/7/30 15:43 */public class Demo1 {    public static void main(String[] args) throws IOException {        File file=new File(&quot;D://java创建的目录&quot;);        boolean b=file.mkdir();   //创建虚拟目录        if (b){            System.out.println(&quot;目录创建成功&quot;);            file=new File(&quot;D://java创建的目录//java创建的文件.txt&quot;);            boolean b2=file.createNewFile();   //创建文件            if (b2){                System.out.println(&quot;文件创建成功&quot;);            }else {                System.out.println(&quot;文件创建失败&quot;);            }        }else {            System.out.println(&quot;目录创建失败&quot;);        }    }}</code></pre><p><strong>Demo2.java</strong></p><pre><code class="java">package com.java.chap14.sec02;import java.io.File;import java.io.IOException;/** * @author Yan * @date 2019/7/30 15:43 */public class Demo2 {    public static void main(String[] args) throws IOException {        File file=new File(&quot;D://java创建的目录//Java创建的文件.txt&quot;);        if (file.exists()){  //假如目录存在            boolean b=file.delete();    //删除文件            if (b){                System.out.println(&quot;删除文件成功&quot;);            }else {                System.out.println(&quot;删除文件失败&quot;);            }        }        file=new File(&quot;D://java创建的目录&quot;);        if (file.exists()){            boolean b2=file.delete();   //删除目录            if (b2){                System.out.println(&quot;删除目录成功&quot;);            }else {                System.out.println(&quot;删除目录失败&quot;);            }        }    }}</code></pre><p><strong>Demo3.java</strong></p><pre><code class="java">package com.java.chap14.sec02;import java.io.File;/** * @author Yan * @date 2019/7/30 17:21 */public class Demo3 {    public static void main(String[] args) {        File file=new File(&quot;D://图书&quot;);        File files[]=file.listFiles();    //遍历目录        for (int i=0;i&lt;files.length;i++){            System.out.println(files[i]);        }    }}</code></pre><p><strong>Demo4.java</strong></p><pre><code class="java">package com.java.chap14.sec02;import java.io.File;/** * @author Yan * @date 2019/7/30 17:45 */public class Demo4 {    /**     * 打印文件     * @param file     */    public static void listFile(File file) {        if (file != null) {            if (file.isDirectory()) {  //是目录                File files[]=file.listFiles();   //遍历目录                if (files!=null){                    for (int i=0;i&lt;files.length;i++){                        listFile(files[i]);   //递归调用                    }                }            } else {    //是文件                System.out.println(file);    //是文件，直接打印文件的路径            }        }    }    public static void main(String[] args) {        File file=new File(&quot;D://实验报告&quot;);        listFile(file);    }}</code></pre><h2 id="字节输入，输出流"><a href="#字节输入，输出流" class="headerlink" title="字节输入，输出流"></a>字节输入，输出流</h2><ol><li>InputStream 读取文件</li></ol><p>代码示例：    </p><p><strong>Demo1.java</strong> </p><pre><code class="java">package com.java.chap14.sec03;import java.io.File;import java.io.FileInputStream;import java.io.InputStream;/** * @author Yan * @date 2019/7/31 14:36 */public class Demo1 {    public static void main(String[] args) throws Exception {        File file=new File(&quot;D://测试文件.txt&quot;);        InputStream inputStream=new FileInputStream(file);   //实例化FileInputStream        byte b[]=new byte[1024];        int len=inputStream.read(b);        inputStream.read(b);        inputStream.close();   //关闭输出流        System.out.println(&quot;读取的内容：&quot;+new String(b,0,len));    }}</code></pre><p><strong>Demo2.java</strong></p><pre><code class="java">package com.java.chap14.sec03;import java.io.File;import java.io.FileInputStream;import java.io.InputStream;/** * @author Yan * @date 2019/7/31 14:36 */public class Demo2 {    public static void main(String[] args) throws Exception {        File file=new File(&quot;D://测试文件.txt&quot;);        InputStream inputStream=new FileInputStream(file);   //实例化FileInputStream        int fileLength= (int) file.length();        byte b[]=new byte[fileLength];        int len=inputStream.read(b);        inputStream.read(b);        inputStream.close();   //关闭输出流        System.out.println(&quot;读取的内容：&quot;+new String(b));    }}</code></pre><p><strong>Demo3.java</strong></p><pre><code class="java">package com.java.chap14.sec03;import java.io.File;import java.io.FileInputStream;import java.io.InputStream;/** * @author Yan * @date 2019/7/31 14:36 */public class Demo3 {    public static void main(String[] args) throws Exception {        File file=new File(&quot;D://测试文件.txt&quot;);        InputStream inputStream=new FileInputStream(file);   //实例化FileInputStream        int fileLength= (int) file.length();        byte b[]=new byte[fileLength];        int temp=0;        int len=0;        while ((temp=inputStream.read())!=-1){            //一个字节一个字节读取，放到b字节数组里            b[len++]= (byte) temp;        }        inputStream.close();   //关闭输出流        System.out.println(&quot;读取的内容：&quot;+new String(b));    }}</code></pre><ol start="2"><li>OutputStream 写入文件</li></ol><p>代码示例：     </p><p><strong>Demo4.java</strong></p><pre><code class="java">package com.java.chap14.sec03;import java.io.File;import java.io.FileOutputStream;import java.io.OutputStream;/** * @author Yan * @date 2019/7/31 15:38 */public class Demo4 {    public static void main(String[] args) throws Exception {        File file=new File(&quot;D://测试文件.txt&quot;);        OutputStream outputStream=new FileOutputStream(file);        String str=&quot;你好，我好，大家好&quot;;        byte b[]=str.getBytes();        outputStream.write(b);   //将b字节数组写入到输出流中        outputStream.close();   //关闭输出流    }}</code></pre><p><strong>Demo5.java</strong></p><pre><code class="java">package com.java.chap14.sec03;import java.io.File;import java.io.FileOutputStream;import java.io.OutputStream;/** * @author Yan * @date 2019/7/31 15:38 */public class Demo5 {    public static void main(String[] args) throws Exception {        File file=new File(&quot;D://测试文件.txt&quot;);        OutputStream outputStream=new FileOutputStream(file,true);  //true追加        String str=&quot;你好，我好，大家好&quot;;        byte b[]=str.getBytes();        outputStream.write(b);   //将b字节数组写入到输出流中        outputStream.close();   //关闭输出流    }}</code></pre><ol start="3"><li>BufferedInputStream和BufferedOutputStream</li></ol><p>代码示例：    </p><pre><code class="java">package com.java.chap14.sec03;import java.io.*;/** * @author Yan * @date 2019/7/31 22:31 */public class Demo6 {    /**     * 缓冲     *     * @throws Exception     */    public static void bufferStream() throws Exception {        //定义一个带缓冲的字节输入流        BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(&quot;D://实验报告//android//Android应用开发实验指导书.doc&quot;));        //定义一个带缓冲的字节输出流        BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(new FileOutputStream(&quot;D://复制的文件2.doc&quot;));        int b = 0;        Long startTime = System.currentTimeMillis();  //开始时间        while ((b = bufferedInputStream.read()) != -1) {            bufferedOutputStream.write(b);        }        bufferedInputStream.close();        bufferedOutputStream.close();        Long endTime = System.currentTimeMillis();   //结束时间        System.out.println(&quot;缓冲花费的时间：&quot; + (endTime - startTime));    }    /**     * 非缓冲     *     * @throws Exception     */    public static void stream() throws Exception {        InputStream inputStream = new FileInputStream(&quot;D://实验报告//android//Android应用开发实验指导书.doc&quot;);  //定义一个输入流        OutputStream outputStream = new FileOutputStream(&quot;D://复制的文件.doc&quot;);        int b = 0;        Long startTime = System.currentTimeMillis();  //开始时间        while ((b = inputStream.read()) != -1) {            outputStream.write(b);        }        inputStream.close();        outputStream.close();        Long endTime = System.currentTimeMillis();   //结束时间        System.out.println(&quot;非缓冲花费的时间：&quot; + (endTime - startTime));    }    public static void main(String[] args) throws Exception {        stream();        bufferStream();    }}</code></pre><ol start="4"><li>缓冲和非缓冲的区别及性能对比</li></ol><h2 id="字符输入、输出流"><a href="#字符输入、输出流" class="headerlink" title="字符输入、输出流"></a>字符输入、输出流</h2><ol><li>Reader读取文件</li></ol><p>代码示例：    </p><p><strong>Demo1.java</strong></p><pre><code class="java">package com.java.chap14.sec04;import java.io.File;import java.io.FileReader;import java.io.Reader;/** * @author Yan * @date 2019/7/31 23:00 */public class Demo1 {    public static void main(String[] args) throws Exception {        File file = new File(&quot;D://测试文件.txt&quot;);        Reader reader=new FileReader(file);        char c[]=new char[1024];   //字符数组        int len=reader.read(c);        reader.close();   //关闭输入流        System.out.println(&quot;读取的内容是：&quot;+new String(c,0,len));    }}</code></pre><p><strong>Demo2.java</strong></p><pre><code class="java">package com.java.chap14.sec04;import java.io.File;import java.io.FileReader;import java.io.Reader;/** * @author Yan * @date 2019/7/31 23:04 */public class Demo2 {    public static void main(String[] args) throws Exception {        File file = new File(&quot;D://测试文件.txt&quot;);        Reader reader=new FileReader(file);        char c[]=new char[1024];   //字符数组        int temp=0;        int len=0;        while ((temp=reader.read())!=-1){            c[len++]= (char) temp;        }        reader.close();   //关闭输入流        System.out.println(&quot;读取的内容是：&quot;+new String(c,0,len));    }}</code></pre><ol start="2"><li>Writer写入文件</li></ol><p>代码示例：     </p><p><strong>Demo3.java</strong></p><pre><code class="java">package com.java.chap14.sec04;import java.io.*;/** * @author Yan * @date 2019/7/31 23:06 */public class Demo3 {    public static void main(String[] args) throws Exception {        File file = new File(&quot;D://测试文件.txt&quot;);        Writer out = new FileWriter(file);        String str = &quot;我爱中华&quot;;        out.write(str);   //将字符串写入输出流        out.close();   //关闭输出流    }}</code></pre><p><strong>Demo4.java</strong></p><pre><code class="java">package com.java.chap14.sec04;import java.io.File;import java.io.FileWriter;import java.io.Writer;/** * @author Yan * @date 2019/7/31 23:06 */public class Demo4 {    public static void main(String[] args) throws Exception {        File file = new File(&quot;D://测试文件.txt&quot;);        Writer out = new FileWriter(file,true);        String str = &quot;我爱中华&quot;;        out.write(str);   //将字符串写入输出流        out.close();   //关闭输出流    }}</code></pre><h3 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h3><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://www.java1234.com/" target="_blank" rel="noopener">Java知识分享网</a></li><li><a href="https://www.bilibili.com/video/av45829913" target="_blank" rel="noopener">Java入门到精通-基础篇</a><br><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">op=>operation: Hello World.java(Javac 编译)op1=>operation: Hello World.class(Java 运行)op2=>operation: 执行并运行结果e=>endop->op1->op2</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;代码仓库地址&quot;&gt;&lt;a href=&quot;#代码仓库地址&quot; class=&quot;headerlink&quot; title=&quot;代码仓库地址&quot;&gt;&lt;/a&gt;代码仓库地址&lt;/h1&gt;&lt;p&gt;欢迎下载：&lt;a href=&quot;https://github.com/yanxin152133/java&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;运行环境：    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IntelliJ IDEA 2019.1.3(Ultimate Edition)&lt;/li&gt;
&lt;li&gt;jdk 1.8.0_211&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;Java8手册&quot;&gt;&lt;a href=&quot;#Java8手册&quot; class=&quot;headerlink&quot; title=&quot;Java8手册&quot;&gt;&lt;/a&gt;Java8手册&lt;/h1&gt;&lt;p&gt;文件名为&lt;strong&gt;jdk1.8.CHM&lt;/strong&gt;即为Java8手册。&lt;/p&gt;
&lt;p&gt;打不开参考下面链接：    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/qq_14998713/article/details/52155834&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;解决win10中无法打开CHM文件的方法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;Java-基础&quot;&gt;&lt;a href=&quot;#Java-基础&quot; class=&quot;headerlink&quot; title=&quot;Java 基础&quot;&gt;&lt;/a&gt;Java 基础&lt;/h1&gt;&lt;h1 id=&quot;Java简介&quot;&gt;&lt;a href=&quot;#Java简介&quot; class=&quot;headerlink&quot; title=&quot;Java简介&quot;&gt;&lt;/a&gt;Java简介&lt;/h1&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
      <category term="基础" scheme="http://yoursite.com/categories/Java/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>整合Swagger</title>
    <link href="http://yoursite.com/2019/07/13/Spring%20Boot%20%E6%95%B4%E5%90%88Swagger/"/>
    <id>http://yoursite.com/2019/07/13/Spring Boot 整合Swagger/</id>
    <published>2019-07-13T12:40:56.543Z</published>
    <updated>2019-07-13T12:48:58.192Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Swagger 是一款RESTFUL接口的文档在线自动生成+功能测试功能软件。本文简单介绍了在项目中集成swagger的方法和一些常见问题。 如果想深入分析项目源码，了解更多内容，见参考资料。Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。总体目标是使客户端和文件系统作为服务器以同样的速度来更新。文件的方法，参数和模型紧密集成到服务器端的代码，允许API来始终保持同步。Swagger 让部署管理和使用功能强大的API从未如此简单。</p></blockquote><a id="more"></a><h1 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h1><h2 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h2><pre><code>        &lt;!-- swagger api文档 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;io.springfox&lt;/groupId&gt;            &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;            &lt;version&gt;2.6.1&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;io.springfox&lt;/groupId&gt;            &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;            &lt;version&gt;2.6.1&lt;/version&gt;        &lt;/dependency&gt;</code></pre><h2 id="SwaggerConfig-java"><a href="#SwaggerConfig-java" class="headerlink" title="SwaggerConfig.java"></a>SwaggerConfig.java</h2><pre><code>package com.cleanhome.service.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;/** * @author Yan * @date 2019/6/10 13:58 * * swaggerui配置文件 */@Configuration@EnableSwagger2public class SwaggerConfig {    /**     * 创建API应用     * apiInfo() 增加API相关信息     * 通过select()函数返回一个ApiSelectorBuilder实例,用来控制哪些接口暴露给Swagger来展现，     * 本例采用指定扫描的包路径来定义指定要建立API的目录。     *     * @return     */    @Bean    public Docket createRestApi() {        return new Docket(DocumentationType.SWAGGER_2)                .apiInfo(apiInfo())                .select()                .apis(RequestHandlerSelectors.basePackage(&quot;com.cleanhome.service.controller&quot;))                .paths(PathSelectors.any())                .build();    }    /**     * 创建该API的基本信息（这些基本信息会展现在文档页面中）     * 访问地址：http://项目实际地址/swagger-ui.html     * @return     */    private ApiInfo apiInfo() {        return new ApiInfoBuilder()                .title(&quot;XXXX&quot;)                .description(&quot;XXXX&quot;)                .termsOfServiceUrl(&quot;https://yanxin152133.github.io/&quot;)                .contact(&quot;yan&quot;)                .version(&quot;1.0&quot;)                .build();    }}</code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><pre><code>package com.cleanhome.service.controller;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import com.cleanhome.service.bean.EjCustomer;import com.cleanhome.service.service.impl.IEjCustomerServiceImpl;import com.cleanhome.service.utils.Message;import com.cleanhome.service.utils.MessageUtil;import io.swagger.annotations.Api;import io.swagger.annotations.ApiImplicitParam;import io.swagger.annotations.ApiImplicitParams;import io.swagger.annotations.ApiOperation;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.propertyeditors.CustomDateEditor;import org.springframework.web.bind.WebDataBinder;import org.springframework.web.bind.annotation.*;import org.springframework.web.context.request.WebRequest;import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.Date;import java.util.List;import java.util.Map;/** * @author Yan、ysq * @date 2019/6/11 8:40 * 顾客 * 主要功能： * 1.查询顾客的所有信息 * 2.查询顾客数量 * 3.添加顾客信息 * 4.根据编号进行删除顾客信息 * 5.根据编号进行更新操作 */@RestController@RequestMapping(&quot;/customer&quot;)@Api(value = &quot;/customer&quot;, description = &quot;顾客信息管理&quot;)public class EjCustomerController {    Logger logger = LoggerFactory.getLogger(EjCustomerController.class);    @Autowired    private IEjCustomerServiceImpl ejCustomerService;    @InitBinder    public void initBinder(WebDataBinder binder, WebRequest request) {        //转换日期        DateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);        binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, true));// CustomDateEditor为自定义日期编辑器    }    //查询顾客的所有信息    @ApiOperation(value = &quot;查询顾客的所有信息&quot;)    @GetMapping(&quot;findAll&quot;)    public Message findAll() {        List&lt;EjCustomer&gt; list = ejCustomerService.findAll();        logger.info(&quot;查询顾客所有信息成功&quot;);        return MessageUtil.success(&quot;查询顾客所有信息成功&quot;, list);    }    //查询顾客数量    @ApiOperation(value = &quot;查询顾客数量&quot;)    @GetMapping(&quot;findCustomer_Num&quot;)    public Message findCustomer_Num() {        int num = ejCustomerService.findCustomer_Num();        logger.info(&quot;查询顾客数量成功&quot;);        return MessageUtil.success(&quot;查询顾客数量成功&quot;, num);    }    //查询当天新增顾客量    @ApiOperation(value = &quot;查询当天新增顾客量&quot;)    @GetMapping(&quot;TodayCustomerNum&quot;)    public Message TodayCustomerNum() {        int num = ejCustomerService.TodayCustomerNum();        logger.info(&quot;查询当天新增顾客量成功&quot;);        return MessageUtil.success(&quot;查询当天新增顾客量成功&quot;, num);    }    //添加顾客信息    @ApiOperation(value = &quot;添加顾客信息&quot;)    @PostMapping(&quot;insert&quot;)    @ApiImplicitParams({            @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;id&quot;, value = &quot;顾客编号&quot;, required = false, dataType = &quot;Integer&quot;),            @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;account&quot;, value = &quot;顾客账号&quot;, required = true, dataType = &quot;Long&quot;),            @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;password&quot;, value = &quot;顾客账号密码&quot;, required = true, dataType = &quot;String&quot;),            @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;realname&quot;, value = &quot;顾客真实姓名&quot;, required = true, dataType = &quot;String&quot;),            @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;status&quot;, value = &quot;状态&quot;, required = true, dataType = &quot;String&quot;),            @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;photo&quot;, value = &quot;顾客头像&quot;, required = true, dataType = &quot;String&quot;),            @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;telephone&quot;, value = &quot;顾客联系方式&quot;, required = true, dataType = &quot;String&quot;),            @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;register_time&quot;, value = &quot;顾客注册时间&quot;, required = true, dataType = &quot;java.util.Date&quot;)    })    public Message insert(EjCustomer ejCustomer) throws Exception {        boolean isValid = ejCustomerService.isExits(ejCustomer.getAccount());        if (isValid) {            try {                ejCustomerService.insert(ejCustomer);                logger.info(&quot;添加顾客信息成功&quot;);                return MessageUtil.success(&quot;添加顾客信息成功&quot;);            } catch (Exception e) {                e.printStackTrace();                return MessageUtil.error(e.getMessage());            }        } else {            logger.warn(&quot;添加顾客信息失败&quot;);            return MessageUtil.error(&quot;error&quot;);        }    }    //根据顾客id删除用户信息    @ApiOperation(value = &quot;根据顾客id删除顾客信息&quot;)    @GetMapping(&quot;deleteById&quot;)    @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;id&quot;, value = &quot;顾客编号&quot;, required = true, dataType = &quot;Integer&quot;)    public Message deleteById(Integer id) throws Exception {        try {            ejCustomerService.deleteById(id);            logger.info(&quot;顾客编号为&quot; + id + &quot;删除成功&quot;);            return MessageUtil.success(&quot;删除顾客信息成功&quot;);        } catch (Exception e) {            e.printStackTrace();            logger.warn(&quot;顾客信息删除失败&quot;);            return MessageUtil.error(e.getMessage());        }    }    //根据顾客id进行更新操作    @ApiOperation(value = &quot;根据顾客id进行更新&quot;)    @PostMapping(&quot;updateById&quot;)    @ApiImplicitParams({            @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;id&quot;, value = &quot;顾客编号&quot;, required = true, dataType = &quot;Integer&quot;),            @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;account&quot;, value = &quot;顾客账号&quot;, required = false, dataType = &quot;Long&quot;),            @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;password&quot;, value = &quot;顾客账号密码&quot;, required = false, dataType = &quot;String&quot;),            @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;realname&quot;, value = &quot;顾客真实姓名&quot;, required = false, dataType = &quot;String&quot;),            @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;status&quot;, value = &quot;状态&quot;, required = false, dataType = &quot;String&quot;),            @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;photo&quot;, value = &quot;顾客头像&quot;, required = false, dataType = &quot;String&quot;),            @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;telephone&quot;, value = &quot;顾客联系方式&quot;, required = false, dataType = &quot;String&quot;),    })    public Message updateById(EjCustomer ejCustomer) throws Exception{        try {            ejCustomerService.updateById(ejCustomer);            logger.info(&quot;顾客编号&quot;+ejCustomer.getId()+&quot;更新成功&quot;);            return MessageUtil.success(&quot;更新顾客信息成功&quot;);        }catch (Exception e){            e.printStackTrace();            logger.warn(&quot;顾客信息更新失败&quot;);            return MessageUtil.error(e.getMessage());        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Swagger 是一款RESTFUL接口的文档在线自动生成+功能测试功能软件。本文简单介绍了在项目中集成swagger的方法和一些常见问题。 如果想深入分析项目源码，了解更多内容，见参考资料。Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。总体目标是使客户端和文件系统作为服务器以同样的速度来更新。文件的方法，参数和模型紧密集成到服务器端的代码，允许API来始终保持同步。Swagger 让部署管理和使用功能强大的API从未如此简单。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://yoursite.com/categories/Spring-Boot/"/>
    
      <category term="Swagger" scheme="http://yoursite.com/categories/Spring-Boot/Swagger/"/>
    
    
      <category term="Spring Boot" scheme="http://yoursite.com/tags/Spring-Boot/"/>
    
      <category term="Swagger" scheme="http://yoursite.com/tags/Swagger/"/>
    
  </entry>
  
  <entry>
    <title>缺陷跟踪</title>
    <link href="http://yoursite.com/2019/07/10/%E7%BC%BA%E9%99%B7%E8%B7%9F%E8%B8%AA/"/>
    <id>http://yoursite.com/2019/07/10/缺陷跟踪/</id>
    <published>2019-07-10T03:41:31.838Z</published>
    <updated>2019-07-18T14:53:43.348Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h1><p><strong>开发各阶段缺陷放大图</strong>    </p><p><img src="https://live.staticflickr.com/65535/48230009166_9535028fe4_z.jpg" alt><br><a id="more"></a><br><strong>同行评审</strong>        </p><ul><li>同行评审的种类<ul><li>正式评审</li><li>技术审查</li><li>走查</li></ul></li></ul><p><strong>同行评审方式的选择</strong>        </p><ul><li>工作产品刚勾画，起草时—走查</li><li>完成了某一个单独的章节时—技术审查</li><li>整个产品完成时—正式评审</li></ul><p><strong>软件缺陷发现</strong>         </p><ul><li>同行评审</li><li>软件测试</li><li>管理评审</li><li>PPQA发现</li><li>项目组内部发现</li><li>客户反馈</li></ul><p><strong>软件缺陷生命周期</strong><br>软件缺陷生命周期主要由四个阶段组成：    </p><ul><li>识别</li><li>调查</li><li>改正</li><li>总结</li></ul><p><strong>缺陷度量</strong>     </p><ul><li>缺陷度量：CMMI第四级（量化管理级）的软件组织会根据已收集的缺陷数据，采用统计过程控制（Statistical Process Control,SPC)的方法建立软件过程能力基线（Process Capability Baseline，PCB），定量地刻划出软件或过程的特点，进行量化管理。     </li><li><p>SPC:利用统计方法对过程中的各个阶段进行控制，从而达到改进与保证质量的目的；强调以全过程的预防为主；方法是建立控制图</p></li><li><p>PCB：用基线形式量化地表示过程能力；PCB是个不断随着数据累积校正的过程，本身数据收集必须遵循客观、准确、事实，确保组织基线可以持续为各项目研发作为参考标准；运用PCB有助于对过程的分析和改进；</p></li><li><p>PCB是一组能力指标，是过程实际能力的具体体现。通常包括期望值（Mean）、控制上限（Upper Control Limit，UCL）、控制下限（Low Control Limit，LCL）。以缺陷密度为例， Mean描述了未来项目的缺陷密度的预期值，UCL和LCL描述了未来项目的缺陷密度的合理变化范围。</p></li><li>这样的过程能力基线可用来：<br>(1)帮助未来的项目设立量化的项目质量目标；<br>(2)理解和控制未来项目的实际结果。      </li></ul><p><strong>软件缺陷跟踪管理流程</strong>     </p><ul><li>总体流程    </li></ul><p><img src="https://live.staticflickr.com/65535/48230226367_ea82bd2d77_z.jpg" alt="总体流程"></p><ul><li>提交流程</li></ul><p><img src="https://live.staticflickr.com/65535/48230150476_9c63e6e2f0_z.jpg" alt="提交流程"></p><ul><li>修复流程</li></ul><p><img src="https://live.staticflickr.com/65535/48230149591_5d240288b8_z.jpg" alt="修复流程"></p><ul><li>验证流程</li></ul><p><img src="https://live.staticflickr.com/65535/48230219452_8c70aa0c9a_z.jpg" alt="验证流程"></p><ul><li>拒绝流程</li></ul><p><img src="https://live.staticflickr.com/65535/48230147771_5b10ccc80d_z.jpg" alt="拒绝流程"></p><ul><li>争议处理流程</li></ul><p><img src="https://live.staticflickr.com/65535/48230218987_a525c632fb_z.jpg" alt="争议处理流程"></p><ul><li>缺陷挂起流程</li></ul><p><img src="https://live.staticflickr.com/65535/48230148446_2240e906ec_z.jpg" alt="挂起流程"></p><p><strong>缺陷状态</strong><br><strong>常用软件缺陷状态</strong>     </p><table><thead><tr><th>编号</th><th>缺陷状态</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>提交（Submitted或New）</td><td>已提交的缺陷</td></tr><tr><td>2</td><td>打开（Open或Active）</td><td>经审查后确认的缺陷，等待处理</td></tr><tr><td>3</td><td>拒绝（Rejected、Refuse或Not a bug）</td><td>经审查确认不是缺陷、不需要修复或不需要提交</td></tr><tr><td>4</td><td>修复（Resolved或Fixed）</td><td>或为Fixed。缺陷已被修复</td></tr><tr><td>5</td><td>关闭（Closed或Inactive）</td><td>经审查确认已被修复的缺陷，可将其关闭</td></tr><tr><td>6</td><td>推迟（Later、Pending或Deferred）</td><td>当前无法修复，以后条件具备时再解决，但要确定修复的日期</td></tr><tr><td>7</td><td>重新打开（Reopen)</td><td>经过修复的缺陷未通过验证测试，或已关闭的缺陷重新出现</td></tr></tbody></table><p><strong>软件缺陷报告</strong><br>“5C”原则：     </p><ul><li>内容正确(Correct)：每个组成部分的描述正确，不会引起误解。</li><li>内容清晰(Clear)：每个组成部分的描述清晰，易于理解。</li><li>步骤简洁(Concise)：只包含必不可少的信息，不包括任何多余的内容。</li><li>结构完整(Complete)：包含复现该缺陷的完整步骤和其他本质信息。</li><li>风格一致（Consistent）：按照一致的格式书写全部缺陷报告。</li></ul><p><strong>优秀的缺陷报告</strong>     </p><table><thead><tr><th style="text-align:left">重现步骤</th></tr></thead><tbody><tr><td style="text-align:left">(1) 打开编辑文字的软件     （2）创建一个新文档（这个文档可以录入文字）    （3）在这个文档里随意录入一两行文字（任意）    （4）选中录入的一两行文字，选择Font菜单，然后选择Arial字体格式     （5）一两行文字变成了无意义的乱字符</td></tr><tr><td style="text-align:left"><strong>期望结果</strong></td></tr><tr><td style="text-align:left">当用户选择已录入的文字并改变文字格式时，文本应该正确显示选中的文字格式，不会显示成乱字符</td></tr><tr><td style="text-align:left"><strong>实际结果</strong></td></tr><tr><td style="text-align:left">这是字体格式的问题，如果把文字格式改变成Arial前保存文件，缺陷不会出现。缺陷仅发生在Win98，且改变文字格式成其他字体格式时正常。</td></tr></tbody></table><p><strong>缺陷工具</strong>：</p><ul><li>Bugzilla是一款免费、跨平台的开源缺陷跟踪系统，最初是专门为Unix定制开发的，目前也可在windows、Mac OS平台安装使用，在wins操作系统下的安装和配置略为复杂。bugzilla历史悠久、功能强大、受到很多企业用户的欢迎。</li><li>Mantis是一款开源的基于PHP的轻量级跟踪系统，简洁灵活，安装容易，扩展性强，其实用性足以满足中小型项目的缺陷管理和跟踪需要。</li><li>禅道：集产品管理、项目管理、质量管理、文档管理、组织管理和事务管理于一体，避免了一个团队使用多个工具，较bugfree功能更全面。</li><li>TestCenter是一款集测试需求、测试用例、测试过程、测试结果、以及测试报告管理的测试管理工具。</li><li>BugFree基于浏览器，简单、方便、易用的免费、开源的缺陷管理工具。</li></ul><h1 id="大题"><a href="#大题" class="headerlink" title="大题"></a>大题</h1><p><strong>注入-发现矩阵实例</strong>     </p><table><thead><tr><th>缺陷注入阶段/缺陷发现阶段</th><th>需求阶段</th><th>概要设计阶段</th><th>详细设计阶段</th><th>编码阶段</th><th>单元测试阶段</th><th>集成测试阶段</th><th>系统测试阶段</th><th>现场阶段</th><th>注入合计</th></tr></thead><tbody><tr><td>需求评审</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>概要设计审查</td><td>49</td><td>681</td><td></td><td></td><td></td><td></td><td></td><td></td><td>730</td></tr><tr><td>详细设计审查</td><td>6</td><td>42</td><td>681</td><td></td><td></td><td></td><td></td><td></td><td>729</td></tr><tr><td>代码审查</td><td>12</td><td>28</td><td>114</td><td>941</td><td></td><td></td><td></td><td></td><td>1095</td></tr><tr><td>单元测试</td><td>21</td><td>43</td><td>43</td><td>223</td><td>2</td><td></td><td></td><td></td><td>332</td></tr><tr><td>集成测试</td><td>20</td><td>41</td><td>61</td><td>261</td><td>——</td><td>4</td><td></td><td></td><td>387</td></tr><tr><td>系统测试</td><td>6</td><td>8</td><td>24</td><td>72</td><td>——</td><td>——</td><td>1</td><td></td><td>111</td></tr><tr><td>现场</td><td>8</td><td>16</td><td>16</td><td>40</td><td>——</td><td>——</td><td>——</td><td>1</td><td>81</td></tr><tr><td>发现合计</td><td>122</td><td>859</td><td>939</td><td>1537</td><td>2</td><td>4</td><td>1</td><td>1</td><td>3465</td></tr><tr><td>本阶段缺陷移除率</td><td>——</td><td>74%</td><td>61%</td><td>55%</td><td>36%</td><td>67%</td><td>58%</td><td></td><td></td></tr></tbody></table><p>思路：<br>单元测试：<br>332/（122+859+939+1537+2-730-729-1095）x100%=36%</p><p><strong>故障树</strong><br>参考：<a href="https://wenku.baidu.com/view/abfa08eb19e8b8f67c1cb978.html" target="_blank" rel="noopener">故障树PPT</a></p><p><strong>故障树分析</strong><br><strong>逻辑门</strong><br><img src="https://wiki.mbalib.com/w/images/e/e0/%E6%95%85%E9%9A%9C%E6%A0%91%E5%88%86%E6%9E%902.jpg" alt></p><p>例题<br><img src="https://live.staticflickr.com/65535/48231308961_eeca32738a_z.jpg" alt>    </p><p>使用MOCUS算法确定最小割集。首先画出一个足够大的矩阵表格，然后按下面的步骤填充矩阵：     </p><ol><li>将故障事件门的字符放在左上角（0，0）单元格</li><li>将每个门的字符用其下方较低级别的门或基本事件的字符或数字替换，重复此过程。</li><li>对于或门：将字符写成<strong>一竖排</strong>（<strong>也就是竖着写</strong>）；对于与门：将字符写成<strong>一横排</strong>。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简答题&quot;&gt;&lt;a href=&quot;#简答题&quot; class=&quot;headerlink&quot; title=&quot;简答题&quot;&gt;&lt;/a&gt;简答题&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;开发各阶段缺陷放大图&lt;/strong&gt;    &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://live.staticflickr.com/65535/48230009166_9535028fe4_z.jpg&quot; alt&gt;&lt;br&gt;
    
    </summary>
    
      <category term="期末复习" scheme="http://yoursite.com/categories/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="缺陷跟踪" scheme="http://yoursite.com/categories/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E7%BC%BA%E9%99%B7%E8%B7%9F%E8%B8%AA/"/>
    
    
      <category term="期末复习" scheme="http://yoursite.com/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="缺陷跟踪" scheme="http://yoursite.com/tags/%E7%BC%BA%E9%99%B7%E8%B7%9F%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>软件测试</title>
    <link href="http://yoursite.com/2019/07/06/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2019/07/06/软件测试/</id>
    <published>2019-07-06T05:24:49.898Z</published>
    <updated>2019-07-18T14:52:36.149Z</updated>
    
    <content type="html"><![CDATA[<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p><strong>1. 你怎样组建一支新的测试团队，包含一些什么岗位，如果要去招聘，开出什么条件？</strong><br><a id="more"></a><br>参考：<br>首先，测试团队包含的成员（即工作岗位）</p><ul><li><p>测试经理<br>测试部门的负责人。<br>主要职责：</p><ul><li>对外：<ol><li>公司内团队之间的沟通</li><li>向上沟通、汇报、日常作业</li><li>人才招募</li><li>外部影响力（公司内外）</li></ol></li><li>对内<ol><li>团队管理与建设</li><li>项目管理</li><li>人才培养</li><li>目标拆解、执行、调整、跟进</li></ol></li></ul></li><li><p>测试架构师<br>测试技术的负责人，主要承担教练职责，是测试部门的技术核心，涵盖产品测试技术、自动化测试技术、专项测试技术、交付测试技术等方向。<br>主要负责：测试技术管理、测试技术调研、测试技术应用、测试人员的技术培养等。</p></li><li><p>核心测试人员<br>测试任务的主要执行者，主要负责核心测试任务的落地执行、重要测试技术的落地实践、测试管理要求的有效实施。<br>中等职级、业务专家或擅长某一方向技术。</p></li><li><p>一般测试人员<br>测试任务的主要辅助执行者，主要负责一般测试任务的落地执行、一般测试技术的落地实践、测试管理要求的有效实施。<br>中低等职级。      </p></li><li><p>测试项目负责人<br>类似于项目经理。工作重点在于沟通和协调。</p></li><li><p>外包测试人员<br>视为人力，作为一些特殊项目的补充。</p></li><li><p>测试实习生<br>除了做一些特殊时期的补充外，是选择和提前培养优秀应届生的途径之一。</p></li></ul><p>其次，招聘条件（<strong>仅供参考</strong>）<br>任职要求：      </p><ol><li>计算机相关专业，本科及以上学历，3年及以上测试经验，有互联网、SaaS平台产品测试经验者优先；</li><li>具备一定的编程能力，熟练掌握Java/C/C++或各类脚本语言中一种，熟悉MySQL等数据库；</li><li>熟悉Linux操作系统，有自动化测试经验，能独立设计用例并编写代码实现自动化测试；</li><li>熟练测试理论与方法，对互联网质量保证领域有强烈的兴趣；</li><li>具有较强的业务分析能力，较好的沟通表达和综合协调能力，对质量保证有深刻理解；</li><li>具备撰写自动化测试工具以及搭建自动化测试平台的实战经验者优先。</li></ol><p><strong>参考链接</strong>：    </p><ul><li><a href="https://blog.csdn.net/kaka1121/article/details/89213243" target="_blank" rel="noopener">如何搭建测试团队（研发同理)</a></li></ul><p><strong>2. 如果你作为测试项目负责人，你为什么要对软件测试过程进行管理？测试过程管理的原则，测试过程管理的目标</strong><br>参考：<br>对软件测试过程进行管理的原因：</p><ul><li>能够使规定时间内完成所需完成的测试任务。</li></ul><p>测试过程管理原则：<br>①有关测试需求；②测试计划先行；③建立任务优先级；④建立客观的评估标准；⑤尽早测试；⑥全面测试；⑦全过程测试；⑧独立的、迭代的测试。</p><p>测试过程管理目标：尽可能早地找出软件缺陷，并保证其得以修复。</p><p><strong>参考链接</strong>：</p><ul><li><a href="http://202.38.64.11/~shizhu/zlbz/10.pdf" target="_blank" rel="noopener">测试过程管理</a></li><li><a href="https://wenku.baidu.com/view/d9971e29b4daa58da0114abf.html" target="_blank" rel="noopener">测试过程管理</a>  </li></ul><p><strong>3. 白盒测试策略</strong><br>定义：<br>白盒测试也称结构测试或逻辑驱动测试，是一种测试用例设计方法，它从程序的控制结构导出测试用例。（测试用例由测试输入数据以及与之对应的输出结果组成。）</p><p>白盒测试使用被测单元内部如何工作的信息，允许测试人员对程序内部逻辑结构及有关信息来设计和选择测试用例，对程序的逻辑路径进行测试。基于一个应用代码的内部逻辑知识，测试是基于覆盖全部代码、分支、路径、条件。</p><p>策略：</p><ul><li>桌前检查</li><li>模块测试</li><li>代码评审</li><li>同行评审</li><li>代码走查</li><li>静态分析    </li></ul><p>其他参考：</p><ul><li><a href="https://www.cnblogs.com/Ming8006/p/5798186.html" target="_blank" rel="noopener">白盒测试：理论基础</a></li></ul><p><strong>4. 掌握功能测试需求分析确定测试优先级</strong><br>参考：</p><ul><li><a href="https://www.cnblogs.com/mrtester/p/10271346.html" target="_blank" rel="noopener">快速划分测试用例优先级</a></li></ul><p><strong>5. 掌握性能测试需求分析会用80-20原理计算负载量</strong><br>书本例题：     </p><ul><li>测试强度估算<br>80-20原理：每个工作日中80%的业务在20%的时间内完成。<br>举例：<br>每年业务量集中在8个月，每个月20个工作日，每个工作日8个小时即每天80%的业务在1.6小时完成<br>去年全年处理业务约100万笔，其中15%的业务处理中每笔业务需对应用服务器提交7次请求；其中70%的业务处理中每笔业务需对应用服务器提交5次请求；其余15%的业务处理中每笔业务需对应用服务器提交3次请求。根据以往统计结果，每年的业务增量为15%，考虑到今后3年业务发展的需要，测试需按现有业务量的两倍进行。      </li></ul><p>每年总的请求数：<br>（100x15%x7+100x70%x5+100x15%x3）x2=1000万次/年</p><p>每天请求数：<br>1000/160=6.25万次/天</p><p>每秒请求数：<br>（62500x80%）/(8x20%x3600)=8.68次/秒<br>即服务器处理请求的能力应达到9次/秒。</p><p><strong>6. 设计功能测试用例</strong><br>测试用例模板（<strong>仅供参考</strong>）</p><table><thead><tr><th>项目/软件</th><th>XXX</th><th>程序版本</th><th>XXX</th></tr></thead><tbody><tr><td>功能模块名</td><td>Login</td><td>编制人</td><td>XXXX</td></tr><tr><td>用例编号</td><td>XXXX</td><td>编制时间</td><td>XXXX</td></tr><tr><td>相关的用例</td><td>无</td><td></td><td></td></tr><tr><td>功能特性</td><td>用户身份验证</td><td></td><td></td></tr><tr><td>测试目的</td><td>验证是否输入合法的信息，允许合法登录，阻止非法登录</td><td></td><td></td></tr><tr><td>预置条件</td><td>无</td><td>特殊规格说明</td><td>如数据库访问权限</td></tr><tr><td>参考信息</td><td>需求说明中关于“登录”的说明</td><td></td><td></td></tr><tr><td>测试数据</td><td>用户名=yiii密码=1</td><td></td><td></td></tr></tbody></table><table><thead><tr><th>操作步骤</th><th>操作描述</th><th>数据</th><th>期望结果</th><th>预期结果</th><th>实际结果</th><th>测试状态</th></tr></thead><tbody><tr><td>1</td><td>输入用户名称按“登录”按钮</td><td>用户名=yiyh密码为空</td><td>显示警告信息，请输入用户名和密码</td><td></td><td></td><td></td></tr><tr><td>2</td><td>输入密码，按“登录”按钮</td><td>用户名为空密码=1</td><td>显示警告信息请输入用户名和密码</td><td></td><td></td><td></td></tr><tr><td>测试人员</td><td></td><td>开发人员</td><td></td><td></td><td>项目负责人</td><td></td></tr></tbody></table><p><strong>操作步骤需要写出所有情况</strong></p><p><strong>7. I/O接口测试，局部数据结构测试</strong><br><strong>检查模块接口是否正确</strong><br>CheckList:     </p><ul><li>输入的实际参数与形式参数是否一致<ul><li>个数、属性、量纲</li></ul></li><li>调用其他模块的实际参数与被调模块的形参是否一致<ul><li>个数、属性、量纲</li></ul></li><li>全程变量的定义在各模块是否一致</li><li>外部输入、输出<ul><li>文件、缓冲区、错误处理</li></ul></li><li>其他</li></ul><p><strong>当一个模块执行外部I/O操作时，必须进行附加的接口测试</strong>    </p><ul><li>文件属性是否正确</li><li>OPEN/CLOSE语句是否正确？</li><li>格式规约是否和I/O语句匹配？</li><li>缓冲区大小是否和记录大小匹配？</li><li>文件是否在打开之前被使用？</li><li>是否处理了文件结束条件？</li><li>是否处理了I/O错误？</li><li>在输出信息里时候有文本错误？</li></ul><p><strong>模块的局部数据结构是经常出现的错误源。应当设计测试用例以发现下列类型的错误</strong>     </p><ul><li>不正确或不一致的类型描述</li><li>错误的初始化或缺省值</li><li>不正确的（拼写错误的或被截断的）变量名字</li><li>不一致的数据类型</li><li>下溢、上溢和地址错误<br>除了局部数据结构，全局数据对模块的影响在单元测试过程中应当进行审查。</li></ul><p><strong>检查局部数据结构完整性</strong><br>Checklist:     </p><ul><li>不适合或不相容的类型说明</li><li>变量无初值</li><li>变量初始化或默认值有错</li><li>不正确的变量名或从来未被使用过</li><li>出现上溢或下溢和地址异常</li><li>其他</li></ul><p><strong>8. 怎样对一段Java代码进行测试，找出代码错误</strong><br>参考：<br>单元测试的步骤：    </p><ul><li>理解需求和设计</li><li>概览源代码</li><li>精读源代码</li><li>设计测试用例</li><li>搭建单元测试环境</li><li>执行测试</li><li>补充和完善测试用例</li><li>分析结果，给出评价</li></ul><p>参考链接：   </p><ul><li><a href="https://wenku.baidu.com/view/6e4cc466bd64783e08122b38.html" target="_blank" rel="noopener">单元测试的步骤</a>     </li></ul><p><strong>9. 进行项目测试计划时间安排的时候，怎样才算是合理的时间安排？</strong><br>参考：<br>测试计划时间安排上遵守：趋势收敛的原则，越到后面，周期越短，问题应该越少。那么测试执行的原则就是：尽可能的把问题都暴露在前面，这样才能保证测试时间上呈收敛趋势。       </p><p>做测试计划时，测试轮次的安排，一般根据不同的项目来定，小项目2+1或者1+1，大项目3+1或者2+1。<br>举例说明：假如现有一项目，测试总时间为10天，需要分3轮进行测试。<br>那么测试时间的安排我们采取4、3、2的原则。<br>第一轮（4天）：全面覆盖所有用例；<br>第二轮（3天）：基本上是基本功能全覆盖（故要刷筛选好一级用例），回归问题单，缺陷比较多的模块功能全覆盖；<br>第三轮（2天）：基本上是回归问题单+基本功能全覆盖（执行一级用例）。<br>还有1天留着备用，若第3轮测试有未关闭的bug，需要再加一轮，用于回归问题。</p><p>以上就是常见测试计划安排模式：3+1模式。</p><p>参考链接：</p><ul><li><a href="https://blog.csdn.net/rachel_luo/article/details/7444480" target="_blank" rel="noopener">如何合理安排测试时间</a></li><li><a href="https://zhidao.baidu.com/question/163643937.html" target="_blank" rel="noopener">软件测试的测试计划是如何计算测试时间</a></li></ul><p><strong>10. 如果时间紧迫了，测试范围怎样裁剪？</strong><br>参考：   </p><ul><li><p>网上资料  </p><ul><li>部分不重要的需求可以裁剪，不进行测试</li><li>对测试范围按照重要性和风险进行优先级评定，优先测试重要的和风险大的</li></ul></li><li><p>课本</p><ul><li>优先级最高的需求功能（优先级如何确定）</li><li>新功能和编码改动较大（提高性能表现）的旧功能</li><li>经常容易出现问题部分的功能</li><li>一些经常被用户使用的功能和配置</li></ul></li></ul><p><strong>11. QTP自动化测试的时候，怎样提高测试脚本执行效率？</strong><br>参考：     </p><ul><li>使用VBS文件来启动QTP</li><li>把变量和函数定义放到外部VBS文件，而不要放在Action中</li><li>通过AOM控制QTP重启来解决QTP内存泄露问题</li><li>尽量不要使用wait，而使用.sync或exist语句</li><li>使用with语句可以让代码更清晰，而且效率更好</li><li>使用OR要比DP快点</li><li>不要保存image和movie到测试结果中</li><li>把运行模式设置为fast</li><li>通过AOM控制QTP</li><li>在调用Action时使用相对路径</li></ul><p><strong>参考链接</strong>：     </p><ul><li><a href="https://zhidao.baidu.com/question/569838608.html" target="_blank" rel="noopener">QTP：如何优化测试脚本 提高测试效率 以及脚本结构化</a></li><li><a href="http://www.voidcn.com/article/p-wopghvwx-hm.html" target="_blank" rel="noopener">如何让你的QTP脚本执行效率更高？</a></li></ul><p><strong>12. 理解性能测试的指标和性能测试给出的结果曲线</strong><br>参考：<br><strong>性能测试的指标</strong>     </p><ul><li>bs结构程序一般会关注的通用指标如下：     <ul><li>Web服务器指标指标：<ul><li>Avg Rps: 平均每秒钟响应次数=总请求时间 / 秒数；</li><li>Avg time to last byte per terstion （mstes）：平均每秒业务脚本的迭代次数，有人会把这两者混淆；</li><li>Successful Rounds：成功的请求；</li><li>Failed Rounds ：失败的请求；</li><li>Successful Hits ：成功的点击次数；</li><li>Failed Hits ：失败的点击次数；</li><li>Hits Per Second ：每秒点击次数；</li><li>Successful Hits Per Second ：每秒成功的点击次数；</li><li>Failed Hits Per Second ：每秒失败的点击次数；</li><li>Attempted Connections ：尝试链接数；   </li></ul></li></ul></li><li>cs结构程序，由于一般软件后台通常为数据库，所以我们更注重数据库的测试指标：      <ul><li>User 0 Connections ：用户连接数，也就是数据库的连接数量；</li><li>Number of deadlocks：数据库死锁；</li><li>Buffer Cache hit ：数据库Cache的命中情况</li></ul></li></ul><p><strong>性能测试给出的结果曲线</strong><br><strong>参考</strong><a href="https://blog.csdn.net/zzh920625/article/details/51000172" target="_blank" rel="noopener">LoadRunner性能测试工具—（三）测试结果样例分析</a></p><p><strong>13. 如果让你负责性能测试，你会按照什么思路开展工作？</strong><br>参考：<br>性能测试的方法是通过模拟生产运行的业务压力量和使用场最组合,测试系统的性能是否满足生产的性能要求。即在特定的运行条件下验证系统的能力状况。主要强调在特定的软硬件环境、特定的测试业务场景下,获得系统的各个性能指标。<br>而身为一个软件测试工程师应根据以下步骤开展工作：     </p><ol><li>制定目标和分析系统</li><li>选择测试度量的方法</li><li>学习的相关技术和工具</li><li>制定评估标准</li><li>设计测试用例</li><li>运行测试用例</li><li>分析测试结果</li></ol><h1 id="课本补充"><a href="#课本补充" class="headerlink" title="课本补充"></a>课本补充</h1><p><strong>有关软件测试的作用</strong>      </p><ul><li>产品质量的保证</li><li>控制成本的关键</li><li>软件可靠性确认</li><li>让企业具备国际竞争的实力</li></ul><p><strong>QA、QC、QM</strong>     </p><ul><li>QA 质量保证</li><li>QC 质量控制</li><li>QM 质量管理</li></ul><p><strong>软件测试人才需求快速增长的体现</strong>     </p><ul><li>中国软件产业正在快速增长，需要大量软件相关人才。</li><li>软件企业的发展要求测试人才达到一个合适的比例</li><li>软件企业开始认识到软件测试对于提高软件质量的重要性，开始重视软件测试。</li></ul><p><strong>软件测试技术的内容</strong><br>软件测试包括：     </p><ul><li>测试计划、测试流程、测试策略、设计测试用例、执行测试、撰写测试报告</li><li>单元测试、集成测试、系统测试、确认测试</li><li>手工测试、自动化测试</li><li>测试工具、缺陷管理和维护工具</li><li>编写操作手册、功能手册、系统管理手册、培训手册</li><li>维护文档、维护测试环境、分析问题、归纳推理能力</li></ul><p><strong>测试用例的组成</strong></p><ul><li><strong>用例标识</strong></li><li><strong>用例名称</strong></li><li><strong>被测功能</strong></li><li><strong>用例目的</strong></li><li><strong>数据准备</strong></li><li><strong>测试步骤</strong></li><li><strong>预期结果</strong></li><li><strong>实际结果</strong></li><li><strong>测试人员</strong></li><li><strong>测试日期</strong></li></ul><p><strong>编写测试用例的注意事项</strong><br>要解决4W问题     </p><ul><li>why</li><li>when</li><li>who</li><li>what</li></ul><p><strong>测试用例说明包含的要素</strong>      </p><ul><li>标识符</li><li>测试项</li><li>输入说明</li><li>输出说明</li><li>环境要求</li><li>特殊要求</li><li>用例依赖性</li></ul><p><strong>测试的三大原则</strong><br><strong>1. 尽早测试</strong><br><strong>2. 连续测试</strong><br><strong>3. 自动化测试</strong></p><p><strong>软件测试职业素质</strong>     </p><ul><li>软件测试员的目标：<br>——发现潜在的软件缺陷</li><li>软件测试员应具备的素质：</li></ul><ol><li>具有探索精神</li><li>具有创造性</li><li>坚持不懈的精神</li><li>故障排除专家</li><li>判断准确</li><li>追求完美</li><li>沟通能力</li></ol><p><strong>软件危机内在的原因</strong>     </p><ul><li>在软件开发过程中，软件缺陷的积累和放大效应是导致软件危机的主要原因</li><li>人员和其他资源的投入导致开发成本急剧增加，带有缺陷的开发成果导致开发质量大幅下降，反复无常的修改导致开发效率严重底下</li><li>因此，迫切地需要规范化地过程来制约软件开发的无序性，便产生了软件工程。</li></ul><p><strong>怎样写测试计划</strong>     </p><ul><li>确定内容<ul><li>总的测试计划</li><li>分阶段的测试计划</li><li>参考测试模板</li></ul></li><li>考虑以下问题<ul><li>测试问题</li><li>测试策略</li><li>测试技术</li><li>测试组织</li><li>测试准备</li></ul></li></ul><p><strong>测试计划的用途</strong></p><ul><li>为测试中的管理工作和技术工作提供指导</li><li>确定达到测试目标和测试目的的必要的测试类型和范围</li><li>概述有效使用资源的时间和活动的时间顺序安排</li><li>通过建立需求跟踪矩阵，为可能的、最高水平的测试覆盖提供保证</li><li>概述测试程序脚本的详细内容，描述如何执行测试程序脚本</li><li>概述测试所需的人员、财力、设备和工具资源</li></ul><p><strong>测试计划的作用</strong>     </p><ul><li>避免测试的“事件驱动”</li><li>使测试工作和整个开发工作融合起来</li><li>资源和变更事先作为一个可控制的风险</li></ul><p><strong>测试需求分析</strong>      </p><ul><li>什么时候进行测试需求分析<br>在开始测试设计之前确定测试需求</li><li>测试需求分析做什么？<br>清晰地定义测试需求并形成文档，使所有工作人员理解测试工作的基础</li><li>测试需求分析的目的是什么？<br>识别验证系统所需的不同类型的测试，在哪个测试阶段完成。</li></ul><p><strong>白盒测试能做什么？</strong></p><ul><li>保证模块内的所有独立路径至少执行一次</li><li>执行所有逻辑判定为真和为假的情况</li><li>在循环可操作范围内，执行所有边界循环</li><li>运用内部数据结构以保证其有效性</li></ul><p><strong>单元测试方法</strong><br>在对每个模块进行单元测试时，需要考虑它和周围模块之间的相互联系。为模拟这一联系，在进行单元测试时，必须设置若干个辅助测试模块，这些辅助模块分为两种：     </p><ul><li><p>驱动模块。相当于被测模块的主程序，用以模拟被测模块的上级模块，用于接收测试数据，并把这些数据传送给被测模块，启动被测模块，最后输出实测结果。</p></li><li><p>桩模块。相当于被测模块调用的子模块，用以模拟被测模块的下级模块。</p></li></ul><p><strong>测试评估</strong>     </p><ul><li>软件测试的主要评测方法包括覆盖评测和质量评测。     <ul><li>覆盖评测是对测试完全程度的评测，它建立在测试覆盖基础上<br>测试覆盖是由<ul><li>测试需求和</li><li>测试用例的覆盖或</li><li>已执行代码的覆盖表示的</li></ul></li></ul></li></ul><ul><li>质量评测是对测试对象（系统或测试的应用程序）的可靠性、稳定性以及性能的评测。质量建立在对测试结果的评估和对测试过程中确定的缺陷及缺陷修复的分析的基础上。    </li></ul><p><strong>功能测试一般什么时候执行</strong>     </p><ul><li>白盒测试可以在编码的早期进行</li><li>功能测试主要在后期执行</li></ul><p><strong>功能测试的两种策略</strong>      </p><ul><li>顺序测试每个程序特性的功能</li><li>一个模块一个模块的测试，即每个功能在其最先调用的地方测试</li></ul><p><strong>功能测试的特点</strong>     </p><ul><li><p>优点</p><ul><li>对于较大的代码单元来说（子系统甚至系统级），黑盒测试效率高</li><li>测试人员不需要了解实现的细节，包括特定的编程语言</li><li>测试人员和编码人员是彼此独立的</li><li>从用户的视角进行测试，很容易被理解和接受</li><li>有助于暴露任何规格不一致或有歧义的问题</li><li>测试用例设计可以在规格完成之后马上进行</li></ul></li><li><p>缺点</p><ul><li>覆盖率较低，大概只能达到总代码量的30%</li><li>自动化测试的复用性较低</li><li>没有清晰的和简明的规格，测试用例是很难设计的</li></ul></li></ul><p><strong>测试需求和用户需求的区别</strong>     </p><ul><li>测试范围变化</li><li>实现方式变化</li><li>用测试策略去过滤用户需求</li></ul><p><strong>标准手工功能测试和实用手工功能测试的比较</strong>      </p><ul><li>标准软件开发生命周期</li><li>实际软件开发生命周期</li><li>标准手工功能测试的过程</li><li>实用手工功能测试的过程</li><li>实用手工功能测试的关注重点</li></ul><p><strong>良好的测试用例的特征</strong>     </p><ul><li>可以最大程度地找出软件隐藏的缺陷</li><li>可以最高效率地找出软件缺陷</li><li>可以最大程度地满足测试覆盖要求</li><li>既不过分复杂，也不能过分简单</li><li>使软件缺陷的表现可以清楚的判定</li><li>不包含重复的测试用例</li><li>测试用例的内容清晰、格式一致、分类组织管理</li></ul><p><strong>为什么设计良好的（最佳）的测试用例</strong>    </p><ul><li>输入量太大</li><li>输出结果太多</li><li>软件实现途径太多</li><li>软件缺陷的标准不同</li><li>完全测试是不可能的</li></ul><p><strong>性能测试的类型</strong>      </p><ul><li>并发（竞争）测试</li><li>负载测试</li><li>压力测试</li><li>大数据量测试</li><li>疲劳测试</li><li>可靠性测试</li><li>基准测试</li><li>配置测试</li></ul><p><strong>性能测试的目标（问题：为了实现目标怎么选择性能测试类型）</strong>    </p><ul><li>评价系统当前性能</li><li>寻找瓶颈，优化性能</li><li>预测系统未来性能，可扩展性</li><li>系统的参数配置</li><li>发现一些软件算法方面的缺陷</li><li>产品评估/选型</li></ul><p><strong>性能测试关注的内容</strong>      </p><ul><li>是否满足需求</li><li>并发用户数/吞吐量</li><li>平均响应时间</li><li>服务器资源占用情况</li><li>故障恢复时间</li></ul><p><strong>负载量分析的步骤</strong>    </p><ul><li>识别性能测试的目标<ul><li>与最终客户一起定义</li><li>文档化以确保一致</li></ul></li><li>定义负载量<ul><li>识别关键业务功能</li><li>定义场景如何被执行</li><li>近似的数据访问模式</li><li>识别用户类型和特性</li></ul></li><li>选择测量点</li><li>编写负载量分析文档<ul><li>用来创建有效的测试场景</li></ul></li><li>与最终客户一起复审（获得负载量模型的认可）</li></ul><p><strong>软件安全性测试的方法</strong>    </p><ul><li>功能测试（专门设计的安全功能）</li><li>漏洞扫描</li><li>模拟攻击实验</li><li>侦听技术</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;思考题&quot;&gt;&lt;a href=&quot;#思考题&quot; class=&quot;headerlink&quot; title=&quot;思考题&quot;&gt;&lt;/a&gt;思考题&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;1. 你怎样组建一支新的测试团队，包含一些什么岗位，如果要去招聘，开出什么条件？&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="期末复习" scheme="http://yoursite.com/categories/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="软件测试" scheme="http://yoursite.com/categories/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="软件测试" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
      <category term="期末复习" scheme="http://yoursite.com/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>软件工程</title>
    <link href="http://yoursite.com/2019/07/04/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/07/04/软件工程/</id>
    <published>2019-07-04T07:09:11.097Z</published>
    <updated>2019-07-18T14:52:20.246Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h1><h1 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h1><p><strong>1. 社会、健康、安全、法律、文化、环境对软件工程有什么影响？（举例子说明）</strong></p><a id="more"></a><p>答：    </p><ul><li><p><a href="https://baike.baidu.com/item/%E5%8D%93%E8%B6%8A%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%95%99%E8%82%B2%E5%9F%B9%E5%85%BB%E8%AE%A1%E5%88%92/4942299?fr=aladdin" target="_blank" rel="noopener">卓越工程师教育培养计划</a></p></li><li><p>金融危机会导致软件业风险的不确定增加。等等。。。</p></li><li><p><a href="http://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CMFD&amp;dbname=CMFD0506&amp;filename=2005142505.nh&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEd2aHVOOXRmSVlYYzhMZUQ4UFpmdzMxdz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!&amp;v=MjYzODBGckNVUkxPZlllUm1GeS9uVTdyUFYxMjdHN0s4SE5UTXFwRWJQSVI4ZVgxTHV4WVM3RGgxVDNxVHJXTTE=" target="_blank" rel="noopener">软件工程监理体系建设及其对软件产业影响研究</a></p></li><li><p>知识产权</p></li><li><p><a href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%8E%AF%E5%A2%83" target="_blank" rel="noopener">软件工程环境</a></p></li><li><p>996ICU</p></li><li><p>隐私保护等等。</p></li></ul><p><strong>2. 以下是否是软件需求项？什么类别的需求项？</strong>        </p><ul><li>目标软件必须用Java语言实现。<br><strong>约束性需求</strong></li><li>目标软件必须有一个主控模块和分别移动、照相和岩石采集控制的三个子模块组成。<br><strong>否</strong></li><li>目标软件必须在0.5秒内响应外部事件。<br><strong>非功能需求-性能需求</strong></li><li>当目标软件与用户交互时，必须使用特定的菜单和对话框。<br><strong>否</strong></li></ul><p><strong>3. 比较黑盒测试和白盒测试的优缺点。</strong><br>答：    </p><ul><li>黑盒测试的优点</li></ul><ol><li>比较简单，不需要了解程序内部的代码及实现。</li><li>与软件的内部实现无关。</li><li>从用户角度出发，能很容易的知道用户会用到哪些功能，会遇到哪些问题。</li><li>基于软件开发文档，所以也能知道软件实现了文档中的哪些功能。</li><li>在做软件自动化测试时较为方便。</li></ol><ul><li>黑盒测试的缺点</li></ul><ol><li>不可能覆盖所有的代码，覆盖率较低，大概只能达到总代码量的30%。</li><li>自动化测试的复用性较低。</li></ol><ul><li>白盒测试的优点</li></ul><ol><li>帮助软件测试人员增大代码的覆盖，提高代码的质量，发现代码中隐藏的问题。</li></ol><ul><li>白盒测试的缺点</li></ul><ol><li>程序运行会有很多不同的路径，不可能测试所有的运行路径。</li><li>测试基于代码，只能测试开发人员做的对不对，而不能知道设计的正确与否，可能会漏掉一些功能需求。</li><li>系统庞大时，测试开销会非常大。</li></ol><p><strong>4. 软件生存期模型各个模型的适用范围</strong><br>答：     </p><ul><li><p>瀑布模型<br>适用范围：需求明确，小规模软件开发。</p></li><li><p>快速原型模型<br>适用范围：用户需求不明确，需要通过构建原型来清楚地了解用户的真实需求。</p></li><li><p>增量模型<br>适用范围：软件开发周期较长的软件，有持续的合作。</p></li><li><p>螺旋模型<br>适用范围：内部软件开发的大规模软件项目。</p></li><li><p>喷泉模型<br>适用模型：面向对象的软件开发过程。</p></li></ul><p><strong>5. 为什么要进行软件项目管理</strong><br>参考：<br>任何项目都需要管理，只有认真地管理才能使项目成功地达到预期的目标。<br>预期的目标应该包括以下方面：     </p><ol><li>达到项目预期的软件产品功能和性能要求，使用户认为这样的软件产品正是自己所期待的，也就是说软件产品达到了用户已认可的需求规格说明的要求。</li><li>时限要求。</li><li>项目开销限制在预算之内。</li></ol><p>同时软件项目管理涉及的几个主要方面是人员、产品、过程和项目，即所谓的4P(People、Produce、Process、Project).    </p><ol><li><p>开发人员<br>项目管理是对软件工作的管理，但归根结底是对人员行为的管理，就是对人员的管理。人的因素是软件工程的核心因素，对于这一核心因素的把握决定着项目的成败。<br>在项目的人员管理上需要考虑的几个问题是：<br>1). 利益相关方<br>2). 团队负责人<br>3). 团队集体</p></li><li><p>产品<br>软件工程是软件项目的成果和预期的目标，然而，软件这种无形的产品在开发出来以前，要想准确地描述它的规模、工作量，甚至他的功能和性能是困难的。除此以外，软件需求的稳定性问题更增加了项目工作的难度。    </p></li></ol><ul><li>产品的工作环境</li><li>产品的功能和性能</li><li>产品工作处理的是什么数据，经他处理后得到什么数据。 </li></ul><ol start="3"><li><p>过程<br>过程在软件工程项目中是重要的因素，它决定着项目中开展哪些活动以及对活动的要求和开展活动的顺序。</p></li><li><p>项目<br>项目管理的任务是如何利用已有的资源，组织实施既定的项目，提交给用户适用的产品。在此我们将项目管理要开展的主要工作分为3类：<br>1). 计划与计划管理，其中包括：项目策划及计划制定；项目估算；风险分析及风险管理；进度管理；计划跟踪与监督。<br>2). 资源管理，包括：人员管理；成本管理。<br>3). 成果要求管理，包括：需求管理；配置管理；质量管理。</p></li></ol><p><strong>从开发人员、产品、过程、项目四个方面进行论述</strong> </p><p><strong>6. 为什么软件维护的费用一直那么高</strong><br>参考：<br>软件维护不仅针对程序代码，而且还针对软件定义、开发的各个阶段生成的文档。而软件在设计阶段很难预料到这个软件交给谁，在什么时候进行什么样的维护工作。软件维护的依据只能靠软件文档和有关的设计信息。这样，软件维护人员不得不花费大量的劳动，用于软件系统的再分析和对软件信息的理解。因此软件的维护费用也就一直高居不下。</p><p><strong>7. 软件生命周期，各个过程主要工作</strong><br>答：     </p><ul><li>可行性分析（研究）与计划阶段<br>要确定该软件的开发目标和总的要求，要进行可行性分析、投资收益分析、制定开发计划，并完成可行性分析报告、开发文档等文档（输出）。</li><li>需求分析阶段<br>由系统分析人员对被设计的系统进行系统分析，确定对该软件的各项功能、性能需求和设计约束，确定对文档编制的要求，作为本阶段工作的结果，输出有：软件需求规格说明(也称为：软件需求说明、软件规格说明)、数据要求说明和初步的用户手册应该编写出来。</li><li>设计阶段<br>系统设计人员和程序设计人员应该在反复理解软件需求的基础上，提出多个设计，分析每个设计能履行的功能并进行相互比较，最后确定一个设计，包括该软件的结构、模块(或CSCI)的划分、功能的分配，以及处理流程。<br>系统比较复杂的情况下，设计阶段应分解成概要设计阶段和详细设计阶段两个步骤。在一般情况下，完成的文档包括：结构设计说明、详细设计说明和测试计划初稿。 </li><li>实现阶段<br>要完成源程序的编码、编译(或汇编)和排错调试得到无语法错的程序清单，要开始编写进度日报、周报和月报(是否要有日报或周报，取决于项目的重要性和规模)，并且要完成用户手册、操作手册等面向用户的文档的编写工作，还要完成测试计划的编制。</li><li>测试阶段<br>该程序将被全面地测试，已编制的文档将被检查审阅。一般要完成测试分析报告。作为开发工作的结束，所生产的程序、文档以及开发工作本身将逐项被评价，最后写出项目开发总结报告。</li><li>运行与维护阶段<br>软件将在运行使用中不断地被维护，根据新提出的需求进行必要而且可能的扩充和删改、更新和升级。软件维护分为改正性维护、适应性维护和预防性维护，分别对应于前面的三个问题。<br>改正性维护就是修改原有的缺陷、适应性维护就是使软件适应新的软硬件环境，预防性维护就是把今天的技术用在昨天的软件上，以期软件在明天还能使用。</li></ul><p><strong>8. 为什么程序员在进行单元测试时多以白盒测试为主，而软件测试工程师在进行系统集成测试多以黑盒测试为主？</strong><br>参考：<br>白盒测试方法按照程序内部的结构测试程序，检验程序中的每条通路是否都能按预定要求正确工作，而不顾它的功能。 </p><p>黑盒测试并不涉及程序的内部结构和内容特性，主要根据规格说明，只依靠被测试程序的输入和输出之间关系或程序的功能来设计测试用例。</p><h1 id="论述题"><a href="#论述题" class="headerlink" title="论述题"></a>论述题</h1><p><strong>1.  用户最终要执行的使用的最终产品写出来的代码，只要在开发阶段做的好，产品就是一定成功的？</strong></p><p><strong>2. 软件在交付的时候，如果软件在运行的时候没有问题就是高质量的软件</strong></p><p><strong>3. 从用户得到的原始需求不用分析就可以作为软件设计阶段的依据。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;软件工程&quot;&gt;&lt;a href=&quot;#软件工程&quot; class=&quot;headerlink&quot; title=&quot;软件工程&quot;&gt;&lt;/a&gt;软件工程&lt;/h1&gt;&lt;h1 id=&quot;简答题&quot;&gt;&lt;a href=&quot;#简答题&quot; class=&quot;headerlink&quot; title=&quot;简答题&quot;&gt;&lt;/a&gt;简答题&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;1. 社会、健康、安全、法律、文化、环境对软件工程有什么影响？（举例子说明）&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="期末复习" scheme="http://yoursite.com/categories/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="软件工程" scheme="http://yoursite.com/categories/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="期末复习" scheme="http://yoursite.com/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="软件工程" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>操作系统</title>
    <link href="http://yoursite.com/2019/07/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2019/07/01/操作系统/</id>
    <published>2019-07-01T05:28:14.873Z</published>
    <updated>2019-07-18T14:53:58.674Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h1 id="信号量解决进程同步问题"><a href="#信号量解决进程同步问题" class="headerlink" title="信号量解决进程同步问题"></a>信号量解决进程同步问题</h1><p>例题：<br>桌子上有一只盘子，最多可容纳两个水果，每次只能放入或取出一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，两个儿子专等吃盘子中的橘子，两个女儿专等吃盘子中的苹果。请用信号量操作来实现爸爸、妈妈、儿子、女儿之间的同步与互斥关系。<br><a id="more"></a></p><pre><code>semaphore s=2,so=0,sa=0;//s表示盘空，so表示橘子，sa表示苹果。CobeginVoid father(void){while(1){p(s);put apple();v(sa);}}Void mother(void){while(1){p(s);put orange();v (so);}}Void son(void){while(1){p(so);eat orange();v(s);}}Void daughter(void){while(1){p(sa);eat apple();v(s);}}Coend</code></pre><p>PV操作参考<a href="https://blog.csdn.net/speedme/article/details/17597373" target="_blank" rel="noopener">进程同步之信号量机制（pv操作）及三个经典同步问题</a></p><h1 id="作业调度算法（先来先服务算法、短作业优先算法），计算周转时间、带权周转时间、平均周转时间、平均带权周转时间"><a href="#作业调度算法（先来先服务算法、短作业优先算法），计算周转时间、带权周转时间、平均周转时间、平均带权周转时间" class="headerlink" title="作业调度算法（先来先服务算法、短作业优先算法），计算周转时间、带权周转时间、平均周转时间、平均带权周转时间"></a>作业调度算法（先来先服务算法、短作业优先算法），计算周转时间、带权周转时间、平均周转时间、平均带权周转时间</h1><blockquote><p><strong>周转时间=完成时间-提交时间</strong><br><strong>带权周转时间=周转时间/执行时间</strong><br><strong>平均周转时间=每个周转时间之和/作业总数</strong><br><strong>平均带权周转时间=每个带权周转时间之和/作业总数</strong></p></blockquote><p>例题：求解下表中4个作业在FCFS（先来先服务算法）和SJF（短作业优先算法）调度算法下的调度次序、周转时间、带权周转时间、平均周转时间、平均带权周转时间。     </p><table><thead><tr><th>作业</th><th>提交时间</th><th>执行时间</th><th>开始时间</th><th>完成时间</th><th>周转时间</th><th>带权周转时间</th></tr></thead><tbody><tr><td>1</td><td>8.00</td><td>2.00</td><td></td><td></td><td></td><td></td></tr><tr><td>2</td><td>8.50</td><td>0.50</td><td></td><td></td><td></td><td></td></tr><tr><td>3</td><td>9.00</td><td>0.10</td><td></td><td></td><td></td><td></td></tr><tr><td>4</td><td>9.50</td><td>0.20</td><td></td><td></td><td></td></tr></tbody></table><p>先来先服务调度算法   </p><table><thead><tr><th>作业</th><th>提交时间</th><th>运行时间</th><th>开始时间</th><th>完成时间</th><th>周转时间</th><th>带权周转时间</th><th>执行顺序</th></tr></thead><tbody><tr><td>1</td><td>8.00</td><td>2.00</td><td>8.00</td><td>10.00</td><td>2.00</td><td>1</td><td>1</td></tr><tr><td>2</td><td>8.50</td><td>0.50</td><td>10.00</td><td>10.50</td><td>2.00</td><td>4</td><td>2</td></tr><tr><td>3</td><td>9.00</td><td>0.10</td><td>10.50</td><td>10.60</td><td>1.60</td><td>16</td><td>3</td></tr><tr><td>4</td><td>9.50</td><td>0.20</td><td>10.60</td><td>10.80</td><td>1.30</td><td>6.5</td><td>4</td></tr></tbody></table><p>平均周转时间=1.725<br>平均带权周转时间=6.875    </p><p>短作业优先调度算法    </p><table><thead><tr><th>作业</th><th>提交时间</th><th>运行时间</th><th>开始时间</th><th>完成时间</th><th>周转时间</th><th>带权周转时间</th><th>执行顺序</th></tr></thead><tbody><tr><td>1</td><td>8.00</td><td>2.00</td><td>8.00</td><td>10.00</td><td>2.00</td><td>1</td><td>1</td></tr><tr><td>2</td><td>8.50</td><td>0.50</td><td>10.30</td><td>10.80</td><td>2.30</td><td>4.6</td><td>4</td></tr><tr><td>3</td><td>9.00</td><td>0.10</td><td>10.00</td><td>10.10</td><td>1.10</td><td>11</td><td>2</td></tr><tr><td>4</td><td>9.50</td><td>0.20</td><td>10.10</td><td>10.30</td><td>0.80</td><td>4</td><td>3</td></tr></tbody></table><p>平均周转时间=1.55<br>平均带权周转时间=5.15  </p><h2 id="先来先服务算法"><a href="#先来先服务算法" class="headerlink" title="先来先服务算法"></a>先来先服务算法</h2><p>先来先服务根据作业的提交时间来执行作业，提交的时间早则首先被执行。  </p><h2 id="短作业优先算法"><a href="#短作业优先算法" class="headerlink" title="短作业优先算法"></a>短作业优先算法</h2><p>根据执行时间来作为执行顺序，同时第一个到达的作业要首先被执行，之后再根据运行时间的长短来执行，短的则优先执行。</p><h1 id="资源分配图的简化"><a href="#资源分配图的简化" class="headerlink" title="资源分配图的简化"></a>资源分配图的简化</h1><h2 id="资源分配图"><a href="#资源分配图" class="headerlink" title="资源分配图"></a>资源分配图</h2><blockquote><p>在资源分配图中，通常使用圆圈来表示每个进程，用方框表示每种资源类型。由于同一资源类型可能有多个实例，所以在矩形中用圆点数表示实例数。</p></blockquote><table><thead><tr><th>实例</th><th>说明</th></tr></thead><tbody><tr><td><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://live.staticflickr.com/65535/48137904561_1566c16720_b.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure></td><td>进程P1申请一个R1类资源</td></tr><tr><td><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://live.staticflickr.com/65535/48137934688_b1c78b1d52_b.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure></td><td>系统分配一个R1类资源给进程P1，此时系统还剩下2个R1类资源</td></tr><tr><td><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://live.staticflickr.com/65535/48137934578_5fb04c383b_b.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure></td><td>进程P1申请2个R类资源</td></tr><tr><td><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://live.staticflickr.com/65535/48137904261_696b992a7d_b.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure></td><td>系统分配2个R1类资源给进程P1，此时系统还剩下1个R1类资源</td></tr><tr><td><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://live.staticflickr.com/65535/48137904261_696b992a7d_b.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure></td><td>系统分配一个R1类资源给进程P2，然后分配一个R1类资源给进程P1，最后进程P1收到一个R1类资源又继续申请一个R1类资源，此时系统还剩下一个R1类资源可以分配给进程P1，<strong>但是还没有分配给P1</strong></td></tr><tr><td><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://live.staticflickr.com/65535/48137996962_d2ae9b9b64_b.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure></td><td>系统分配一个R1类资源给进程P2，然后又分配一个R1类资源给进程P1，最后进程P1收到一个R1类资源又继续申请一个R1类资源，此时系统已经没有R1类资源可以分配给进程P1，于是<strong>进程P1收到阻塞</strong></td></tr></tbody></table><p>例题：<br><img src="https://live.staticflickr.com/65535/48138130057_feaf5dfa2d_b.jpg" alt></p><ul><li>第一步：先看R1资源，它有三个箭头是向外的，因此它一共给进程分配了3个资源，此时，R1没有空闲的资源剩余。      </li><li>第二步：再看R2资源，它有一个箭头是向外的，因此它一共给进程分配了1个资源，此时，R2还剩余一个空闲的资源没分配。         </li><li>第三步：看完资源，再来看进程，先看进程P2，它只申请一个R1资源，但此时R1资源已经用光了，所以，进程P2进入阻塞状态，因此，进程P2暂时不能化成孤立的点。        </li><li>第四步：再看进程P1，它只申请一个R2资源，此时，系统还剩余一个R2资源没分配，因此，可以满足P1的申请。这样，进程P1便得到了它的全部所需资源，所以它不会进入阻塞状态，可以一直运行，等它运行完后，我们再把它的所有的资源释放。相当于：可以把P1的所有的边去掉，变成一个孤立的点，如下图所示：       </li></ul><p><img src="https://live.staticflickr.com/65535/48138067208_2331e8f977_b.jpg" alt></p><ul><li>第五步：进程P1运行完后，释放其所占有的资源（2个R1资源和1个R2资源），系统回收这些资源后，空闲的资源便变成2个R1资源和1个R2资源，由于进程P2一直在申请一个R1资源，所以此时，系统能满足它的申请。这样，进程P2便得到了它的全部所需资源，所以它不会进入阻塞状态，可以一直运行，等它运行完后，我们再把它的所有的资源释放。相当于：可以把P2的所有的边都去掉，化成一个孤立的点，变成下图：       </li></ul><p><img src="https://live.staticflickr.com/65535/48138036656_e274780171_b.jpg" alt></p><p>由于这个资源分配图可完全简化，因此，不会产生死锁。<br>而如果资源分配图中的点，最终不能够化成孤立的点，则进程资源图不能够完全简化，从而会发生死锁。      </p><h1 id="分页地址变换"><a href="#分页地址变换" class="headerlink" title="分页地址变换"></a>分页地址变换</h1><blockquote><p>地址变换处理</p><ul><li>得到页号：自动将逻辑地址分为页号和页内地址</li><li>用页号查页表，得到块号</li><li>将块号与页内地址拼接，即得物理地址</li></ul></blockquote><h2 id="分页存储逻辑地址转物理地址"><a href="#分页存储逻辑地址转物理地址" class="headerlink" title="分页存储逻辑地址转物理地址"></a>分页存储逻辑地址转物理地址</h2><p>例题：<br>已知某个分页系统，页面大小为1K(即1024字节)，某一个作业有4个页面，分别装入到主存的第3、4、6、8块中，求逻辑地址2100对应的物理地址。  </p><ul><li>第一步：求逻辑地址的页号 = 2100/1024=2 （整除）</li><li>第二步：求页内偏移量 = 2100 % 1024 =52 （取余）</li><li>第三步：产生页表：</li></ul><table><thead><tr><th>页号</th><th>块号</th></tr></thead><tbody><tr><td>0</td><td>3</td></tr><tr><td>1</td><td>4</td></tr><tr><td>2</td><td>6</td></tr><tr><td>3</td><td>8</td></tr></tbody></table><ul><li>第四步：根据逻辑地址的页号查出物理地址的页框号/帧号：<br>如上图，逻辑地址的第2页对应物理地址的第6页。</li><li>第五步：求出物理地址 = 6*1024 + 52 = 6196</li></ul><p>设有8页的逻辑地址空间，每页有1024个字节，它们被映射到32块的物理存储区，那么逻辑地址的有效位是多少，物理地址至少多少位？</p><p>逻辑地址：8x1024=2^3x2^10=2^13<br>物理地址：32x1024=2^5x2^10=2^15<br>逻辑地址的有效位是13，物理地址的有效位是15.      </p><h2 id="十六进制逻辑地址转物理地址"><a href="#十六进制逻辑地址转物理地址" class="headerlink" title="十六进制逻辑地址转物理地址"></a>十六进制逻辑地址转物理地址</h2><p>一分页存储管理系统中逻辑地址长度为16位，页面大小为4KB字节，现有一逻辑地址为2F6AH，且第0、1、2页依次存放在物理块5、10、11中。求逻辑地址2F6AH对应的物理地址      </p><p>解：    </p><ul><li>第一步：将逻辑地址2F6AH转换为二进制为：0010 1111 0110 1010     </li><li>第二步：由于页面大小为4KB字节，（4KB=2的12次方）。所以逻辑地址的后12位为“页内地址”(也叫做页内偏移量)      </li><li>第三步：由于逻辑地址的后12位为页内地址，所以剩下的前4位为页号：即0010为页号      </li><li>第四步：根据页表可知，0010(十进制为2)对于的页框号为11(二进制为1011)<br>所以最终的物理地址为：1011 1111 0110 1010<br>即BF6AH</li></ul><h1 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h1><blockquote><p>定义：选择换出页面的算法<br>评价依据：页面更换频率（缺页率）。 <strong>缺页率=缺页次数/页面总访问次数</strong></p></blockquote><h2 id="最佳置换算法（OPT）"><a href="#最佳置换算法（OPT）" class="headerlink" title="最佳置换算法（OPT）"></a>最佳置换算法（OPT）</h2><p>最佳置换算法所选择淘汰的页面是<strong>最长（未来）时间内不再被访问的页面</strong>。</p><p>例如：<br>系统为某进程分配3个物理块，进程访问页面的顺序是0，7，6，5，7，4，7，3，5，4，7，4，5，6，5，7，6，0，7，6。</p><table><thead><tr><th>访问页面</th><th>0</th><th>7</th><th>6</th></tr></thead><tbody><tr><td>物理块</td><td>0</td><td>0</td><td>0</td></tr><tr><td></td><td></td><td>7</td><td>7</td></tr><tr><td></td><td></td><td></td><td>6</td></tr></tbody></table><p>接下来下一个进入的数字是5，然后需要淘汰最久不被访问的页面。</p><p><strong>首先，需要看0，7，6的哪个是最久不被访问的页面。<br>0在第18次再次访问。<br>7在第5次再次被访问。<br>6在第14次再次被访问。</strong><br>因此需要淘汰<strong>0</strong>。</p><p>按照如上的规律，可以得到以下的结果。     </p><table><thead><tr><th>访问页面</th><th>0</th><th>7</th><th>6</th><th>5</th><th>7</th><th>4</th><th>7</th><th>3</th><th>5</th><th>4</th><th>7</th><th>4</th><th>5</th><th>6</th><th>5</th><th>7</th><th>6</th><th>0</th><th>7</th><th>6</th></tr></thead><tbody><tr><td>物理块</td><td>0</td><td>0</td><td>0</td><td>5</td><td>5</td><td>5</td><td>5</td><td>5</td><td>5</td><td>5</td><td>5</td><td>5</td><td>5</td><td>5</td><td>5</td><td>5</td><td>5</td><td>0</td><td>0</td><td>0</td></tr><tr><td></td><td></td><td>7</td><td>7</td><td>7</td><td>7</td><td>7</td><td>7</td><td>3</td><td>3</td><td>3</td><td>7</td><td>7</td><td>7</td><td>7</td><td>7</td><td>7</td><td>7</td><td>7</td><td>7</td><td>7</td></tr><tr><td></td><td></td><td></td><td>6</td><td>6</td><td>6</td><td>4</td><td>4</td><td>4</td><td>4</td><td>4</td><td>4</td><td>4</td><td>4</td><td>6</td><td>6</td><td>6</td><td>6</td><td>6</td><td>6</td><td>6</td></tr><tr><td>缺页中断</td><td>x</td><td>x</td><td>x</td><td>x</td><td></td><td>x</td><td></td><td>x</td><td></td><td></td><td>x</td><td></td><td></td><td>x</td><td></td><td></td><td></td><td>x</td><td></td><td></td></tr></tbody></table><p>缺页率：9/20*100%=36%     </p><p><strong>缺页中断：在请求分页系统中，可以通过查询页表中的状态位来确定所要访问的页面是否存在于内存中。每当所要访问的页面不在内存时，会产生一次缺页中断，此时操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存。</strong></p><p><strong>通俗的讲也就是每次往物理块中添加数据就会产生一次缺页中断。</strong></p><h2 id="先进先出页面置换算法（FIFO）"><a href="#先进先出页面置换算法（FIFO）" class="headerlink" title="先进先出页面置换算法（FIFO）"></a>先进先出页面置换算法（FIFO）</h2><p>先进先出页面置换算法淘汰的页面是<strong>淘汰最先进入内存的页面</strong>。</p><table><thead><tr><th>访问页面</th><th>6</th><th>0</th><th>1</th><th>2</th><th>0</th><th>3</th><th>0</th><th>4</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>物理块</td><td>6</td><td>6</td><td>6</td><td>2</td><td>2</td><td>2</td><td>2</td><td>4</td><td>4</td><td>4</td></tr><tr><td></td><td></td><td>0</td><td>0</td><td>0</td><td>0</td><td>3</td><td>3</td><td>3</td><td>2</td><td>2</td></tr><tr><td></td><td></td><td></td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>3</td></tr><tr><td>缺页中断</td><td>x</td><td>x</td><td>x</td><td>x</td><td></td><td>x</td><td>x</td><td>x</td><td>x</td><td>x</td></tr></tbody></table><p>缺页率：9/10*100%=90%  </p><h2 id="最近最久未使用置换算法（LRU）"><a href="#最近最久未使用置换算法（LRU）" class="headerlink" title="最近最久未使用置换算法（LRU）"></a>最近最久未使用置换算法（LRU）</h2><p>最近最久未使用置换算法淘汰的页面是<strong>淘汰最近最久未使用的页面</strong>。    </p><table><thead><tr><th>访问页面</th><th>2</th><th>3</th><th>2</th><th>1</th><th>5</th><th>2</th><th>4</th><th>5</th><th>3</th><th>2</th><th>5</th><th>2</th></tr></thead><tbody><tr><td>物理块</td><td>2</td><td>3</td><td>2</td><td>1</td><td>5</td><td>2</td><td>4</td><td>5</td><td>3</td><td>2</td><td>5</td><td>2</td></tr><tr><td></td><td></td><td>2</td><td>3</td><td>2</td><td>1</td><td>5</td><td>2</td><td>4</td><td>5</td><td>3</td><td>2</td><td>5</td></tr><tr><td></td><td></td><td></td><td></td><td>3</td><td>2</td><td>1</td><td>5</td><td>2</td><td>4</td><td>5</td><td>3</td><td>3</td></tr><tr><td>缺页中断</td><td>x</td><td>x</td><td></td><td>x</td><td>x</td><td></td><td>x</td><td></td><td>x</td><td>x</td><td></td><td></td></tr></tbody></table><p>缺页率：7/12*100%=58.3%</p><p>堆栈实现LRU：<br><strong>系统使用特殊的堆栈来存放内存中每一个页面的页号。每当访问一页时就调整一次，即把被访问页面的页号从栈中移出再压入栈顶。因此，栈顶始终是最新被访问页面的页号。当发生缺页中断时，总是淘汰栈底页号所对应的页面</strong>。</p><h1 id="磁盘的调度算法"><a href="#磁盘的调度算法" class="headerlink" title="磁盘的调度算法"></a>磁盘的调度算法</h1><h2 id="先来先服务（FCFS）"><a href="#先来先服务（FCFS）" class="headerlink" title="先来先服务（FCFS）"></a>先来先服务（FCFS）</h2><p>先来先服务算法是<strong>根据进程请求访问磁盘的先后顺序进行调度</strong>。<br>例题：<br>某一磁盘请求序列（磁盘号）：98，183，37，122，14，124，65，61.按照先来先服务磁盘调度对磁盘进行请求服务，假设当前磁头在53道上，则磁臂总移动倒数为多少？     </p><table><thead><tr><th>下一个磁道</th><th>移动磁道数</th></tr></thead><tbody><tr><td>98</td><td>45</td></tr><tr><td>183</td><td>85</td></tr><tr><td>37</td><td>146</td></tr><tr><td>122</td><td>85</td></tr><tr><td>14</td><td>108</td></tr><tr><td>124</td><td>110</td></tr><tr><td>65</td><td>59</td></tr><tr><td>61</td><td>4</td></tr></tbody></table><p>总移动磁道数=45+85+146+85+108+110+59+4=642.    </p><h2 id="最短寻道时间优先磁盘调度算法（SSTF）"><a href="#最短寻道时间优先磁盘调度算法（SSTF）" class="headerlink" title="最短寻道时间优先磁盘调度算法（SSTF）"></a>最短寻道时间优先磁盘调度算法（SSTF）</h2><p>最短寻道时间优先磁盘调度算法是<strong>每次都优先满足当前磁头位置最近的磁道访问请求</strong>。</p><p>例题：<br>若干个等待访问磁盘者依次要访问的磁道为19，43，40，4，79，11，76，当前磁头位于42号柱面，若用最短寻道时间优先磁盘调度算法，则访问序列是什么？<br>思路：将要访问的磁道与当前磁头所在柱面相减并取绝对值，绝对值越小的优先访问。     </p><p>访问序列为40，43，19，11，4，76，79.     </p><h2 id="扫描算法（SCAN）"><a href="#扫描算法（SCAN）" class="headerlink" title="扫描算法（SCAN）"></a>扫描算法（SCAN）</h2><ul><li>考虑当前移动方向，一直移动到最外/内层磁道时，折返，进行反方向移动。就好比电梯。</li><li>寻道方向：…，里-&gt;外，外-&gt;里，….;</li></ul><p>若干个等待访问磁盘者依次要访问的磁道为86,147,91,177,94,150,102,175,130，当前磁头位于143号柱面，<strong>刚刚处理完125号柱面</strong>，使用SCAN算法则访问序列是什么？    </p><p>答：     </p><ul><li>当前方向：从143向<strong>磁道号增加的方向</strong></li><li>依次访问：147，150，175，177</li><li>反方向：130，102，94，91，86（<strong>电梯原理</strong>）</li></ul><h2 id="循环扫描（CSCAN）"><a href="#循环扫描（CSCAN）" class="headerlink" title="循环扫描（CSCAN）"></a>循环扫描（CSCAN）</h2><ul><li>循环扫描</li><li>寻道方向：…..,里-&gt;外，里-&gt;外，….。或者相反。</li></ul><p>若干个等待访问磁盘者依次要访问的磁道为86,147,91,177,94,150,102,175,130，当前磁头位于143号柱面，<strong>刚刚处理完125号柱面</strong>，使用CSCAN算法则访问序列是什么？     </p><p>答：     </p><ul><li>当前方向：从143向<strong>磁道号增加的方向</strong></li><li>依次访问：147，150，175，177</li><li>再从0开始增加方向：<strong>86，91，94，102，130</strong></li></ul><h1 id="磁盘空间分配"><a href="#磁盘空间分配" class="headerlink" title="磁盘空间分配"></a>磁盘空间分配</h1><h2 id="多级索引分配"><a href="#多级索引分配" class="headerlink" title="多级索引分配"></a>多级索引分配</h2><p>例题：<br>设一个盘块大小为1k,每个盘块号占4Byte,若系统采用2级索引，求文件的最大长度。</p><p>答:<br>每个索引块最多可存放1k/4=256个盘块号；<br>采用2级索引是，一个文件最多可拥有的数据块数为256x256=2^6x2^10=64k<br>文件的最长长度为64kx1k=64m.</p><h2 id="混合索引分配"><a href="#混合索引分配" class="headerlink" title="混合索引分配"></a>混合索引分配</h2><p>存放在某磁盘上的文件系统采用混合索引分配方式，其中FCB由6个地址项构成，前四个地址项是直接寻址方式，第五个地址项是一次间接寻址方式，第六个地址项是二次间接寻址。若每个盘块的大小为1KB，盘块号用4个字节描述。那么：      </p><p>（1）源文件系统允许文件的最大长度是多少？<br>（2）将文件的字节偏移量800、8193和819300 转换为物理块号和块内偏移。<br>答：<br>（1）每个盘块能存放的盘块号的个数：1024/4=256<br>文件系统允许的文件最大长度：<br>（4+256+256x256）x1K=65796KB</p><p>（2）    </p><ul><li>800/1024商0余800，因为0&lt;4，所以，第一个地址项中存放的块号即为其所在物理块号，块内偏移800。</li><li>8193/1024商8余1，4&lt;=8&lt;4+256，所以一次间接寻址，8-4=4，读第五个地址项中存放的块号物理块的内容，其内容中的第五个块号即为其所在物理块号，块内偏移1。</li><li>819300/1024商800余100，4+256&lt;=800&lt;4+256+256x256，所以二次间接寻址，800-(4+256)=540，540/256商2余28，读第六个地址项中存放的块号的物理块的内容，再读其内容中的第三个块号所在物理块的内容，其内容的第29个块号即为其所在物理块号，块内偏移为100。</li></ul><h1 id="磁盘空间的管理位置分配"><a href="#磁盘空间的管理位置分配" class="headerlink" title="磁盘空间的管理位置分配"></a>磁盘空间的管理位置分配</h1><h2 id="位示图"><a href="#位示图" class="headerlink" title="位示图"></a>位示图</h2><p>位示图：用二进制的一位表示磁盘中一个盘块的使用情况。     </p><ul><li>“0”，对应块是空闲块；</li><li>“1”，对应块已被分配出去。</li></ul><h3 id="盘块分配"><a href="#盘块分配" class="headerlink" title="盘块分配"></a>盘块分配</h3><p>(1) 顺序扫描位示图，从中找出一个或一组其值为“0”的二进制位(“0”表示空闲)。<br>(2) 将所找到的一个或一组二进制位， 转换成与之相应的盘块号。假定找到的其值为“0”的二进制位，位于位示的第i行、第j列，则其相应的盘块号应按下式计算：<br>b=n(i-1)+j<br>式中， n代表每行的位数。<br>(3) 修改位示图， 令map［i,j］=1。       </p><h3 id="盘块的回收"><a href="#盘块的回收" class="headerlink" title="盘块的回收"></a>盘块的回收</h3><p>(1) 将回收盘块的盘块号转换成位示图中的行号和列号。 转换公式为：<br>  i=(b-1)DIV n+1<br>  j=(b-1)MOD n+1<br>(2) 修改位示图。 令map ［i,j］=0。      </p><p>例题：<br>有一计算机系统采用如下图所示的位示图（行号、列号都从0开始编号）来管理空闲盘块。如果盘块从1开始编号，每个盘块的大小为1KB。 （1）现要为文件分配两个盘块，试具体说明分配过程。 （2）若要释放磁盘的第300块，应如何处理？<br><img src="https://live.staticflickr.com/65535/48149676471_a93daca589_b.jpg" alt><br><img src="https://live.staticflickr.com/65535/48149764307_54ccba2583_b.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统&quot;&gt;&lt;a href=&quot;#操作系统&quot; class=&quot;headerlink&quot; title=&quot;操作系统&quot;&gt;&lt;/a&gt;操作系统&lt;/h1&gt;&lt;h1 id=&quot;信号量解决进程同步问题&quot;&gt;&lt;a href=&quot;#信号量解决进程同步问题&quot; class=&quot;headerlink&quot; title=&quot;信号量解决进程同步问题&quot;&gt;&lt;/a&gt;信号量解决进程同步问题&lt;/h1&gt;&lt;p&gt;例题：&lt;br&gt;桌子上有一只盘子，最多可容纳两个水果，每次只能放入或取出一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，两个儿子专等吃盘子中的橘子，两个女儿专等吃盘子中的苹果。请用信号量操作来实现爸爸、妈妈、儿子、女儿之间的同步与互斥关系。&lt;br&gt;
    
    </summary>
    
      <category term="期末复习" scheme="http://yoursite.com/categories/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="期末复习" scheme="http://yoursite.com/tags/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot整合Druid</title>
    <link href="http://yoursite.com/2019/06/08/Spring%20Boot%20%E6%95%B4%E5%90%88Druid/"/>
    <id>http://yoursite.com/2019/06/08/Spring Boot 整合Druid/</id>
    <published>2019-06-08T06:18:16.866Z</published>
    <updated>2019-06-30T05:43:06.735Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-Boot整合Druid"><a href="#Spring-Boot整合Druid" class="headerlink" title="Spring Boot整合Druid"></a>Spring Boot整合Druid</h1><a id="more"></a><h2 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h2><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.1.5.RELEASE&lt;/version&gt;        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;    &lt;/parent&gt;    &lt;groupId&gt;com.example&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-06-data-jdbc&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;name&gt;spring-boot-06-data-jdbc&lt;/name&gt;    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;    &lt;properties&gt;        &lt;java.version&gt;1.8&lt;/java.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;scope&gt;runtime&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;!--引入druid数据源--&gt;        &lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;            &lt;artifactId&gt;druid&lt;/artifactId&gt;            &lt;version&gt;1.1.17&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre><h2 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a>application.yml</h2><pre><code>spring:  datasource:    driver-class-name: com.mysql.cj.jdbc.Driver    url: jdbc:mysql://localhost:3306/jdbc    username: root    password: root    type: com.alibaba.druid.pool.DruidDataSource    #   数据源其他配置    initialSize: 5    minIdle: 5    maxActive: 20    maxWait: 60000    timeBetweenEvictionRunsMillis: 60000    minEvictableIdleTimeMillis: 300000    validationQuery: SELECT 1 FROM DUAL    testWhileIdle: true    testOnBorrow: false    testOnReturn: false    poolPreparedStatements: true    #   配置监控统计拦截的filters，去掉后监控界面sql无法统计，&#39;wall&#39;用于防火墙    filters: stat,wall    maxPoolPreparedStatementPerConnectionSize: 20    useGlobalDataSourceStat: true    connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500</code></pre><h2 id="DruidConfig-java"><a href="#DruidConfig-java" class="headerlink" title="DruidConfig.java"></a>DruidConfig.java</h2><pre><code>package com.example.springboot.config;import com.alibaba.druid.pool.DruidDataSource;import com.alibaba.druid.support.http.StatViewServlet;import com.alibaba.druid.support.http.WebStatFilter;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.boot.web.servlet.FilterRegistrationBean;import org.springframework.boot.web.servlet.ServletRegistrationBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import javax.sql.DataSource;import java.util.Arrays;import java.util.HashMap;import java.util.Map;/** * @author Yan * @date 2019/6/8 13:46 */@Configurationpublic class DruidConfig {    @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)    @Bean    public DataSource druid(){        return  new DruidDataSource();    }    //配置Druid的监控    //1、配置一个管理后台的Servlet    @Bean    public ServletRegistrationBean statViewServlet(){        ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), &quot;/druid/*&quot;);        Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;();        initParams.put(&quot;loginUsername&quot;,&quot;admin&quot;);        initParams.put(&quot;loginPassword&quot;,&quot;123456&quot;);        initParams.put(&quot;allow&quot;,&quot;&quot;);//默认就是允许所有访问        initParams.put(&quot;deny&quot;,&quot;192.168.15.21&quot;);  //拒绝哪些ip访问        bean.setInitParameters(initParams);        return bean;    }    //2、配置一个web监控的filter    @Bean    public FilterRegistrationBean webStatFilter(){        FilterRegistrationBean bean = new FilterRegistrationBean();        bean.setFilter(new WebStatFilter());        Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;();        initParams.put(&quot;exclusions&quot;,&quot;*.js,*.css,/druid/*&quot;);        bean.setInitParameters(initParams);        bean.setUrlPatterns(Arrays.asList(&quot;/*&quot;));        return  bean;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Spring-Boot整合Druid&quot;&gt;&lt;a href=&quot;#Spring-Boot整合Druid&quot; class=&quot;headerlink&quot; title=&quot;Spring Boot整合Druid&quot;&gt;&lt;/a&gt;Spring Boot整合Druid&lt;/h1&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://yoursite.com/categories/Spring-Boot/"/>
    
      <category term="整合Druid" scheme="http://yoursite.com/categories/Spring-Boot/%E6%95%B4%E5%90%88Druid/"/>
    
    
      <category term="Spring Boot" scheme="http://yoursite.com/tags/Spring-Boot/"/>
    
      <category term="整合Druid" scheme="http://yoursite.com/tags/%E6%95%B4%E5%90%88Druid/"/>
    
  </entry>
  
  <entry>
    <title>个人觉得比较好的一些插件</title>
    <link href="http://yoursite.com/2019/05/26/%E6%8F%92%E4%BB%B6/"/>
    <id>http://yoursite.com/2019/05/26/插件/</id>
    <published>2019-05-26T03:54:10.288Z</published>
    <updated>2019-05-08T13:36:55.386Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Visual-Studio-Code"><a href="#Visual-Studio-Code" class="headerlink" title="Visual Studio Code"></a>Visual Studio Code</h1><h2 id="Chinese-Simplified-Language-Pack-for-Visual-Studio-Code"><a href="#Chinese-Simplified-Language-Pack-for-Visual-Studio-Code" class="headerlink" title="Chinese (Simplified) Language Pack for Visual Studio Code"></a>Chinese (Simplified) Language Pack for Visual Studio Code</h2><p>适用于 VS Code 的中文（简体）语言包。     </p><p><img src="https://live.staticflickr.com/7810/47599193841_ce5cc251fe.jpg" alt="Chinese (Simplified) Language Pack for Visual Studio Code"></p><a id="more"></a><h2 id="Markdown-Preview-Enhanced"><a href="#Markdown-Preview-Enhanced" class="headerlink" title="Markdown Preview Enhanced"></a>Markdown Preview Enhanced</h2><p>Markdown Preview Enhanced 是一款为 Atom 以及 Visual Studio Code 编辑器编写的超级强大的 Markdown 插件。 这款插件意在让你拥有飘逸的 Markdown 写作体验。    </p><p><img src="https://user-images.githubusercontent.com/1908863/28227953-eb6eefa4-68a1-11e7-8769-96ea83facf3b.png" alt="Markdown Preview Enhanced"></p><h2 id="City-Lights-Icon-package"><a href="#City-Lights-Icon-package" class="headerlink" title="City Lights Icon package"></a>City Lights Icon package</h2><p>一个美化 Visual Studio Code 图标的插件。</p><p><img src="https://raw.githubusercontent.com/yummygum/city-lights-icons-vsc/master/city-lights-icon-preview.gif" alt="City Lights Icon package"></p><h1 id="浏览器插件"><a href="#浏览器插件" class="headerlink" title="浏览器插件"></a>浏览器插件</h1><h2 id="广告净化器"><a href="#广告净化器" class="headerlink" title="广告净化器"></a>广告净化器</h2><p>免费高效的广告过滤工具：可以过滤烦人的视频广告、弹窗广告、大横幅广告等网页广告，让你清爽浏览网页。    </p><p>下载地址：<a href="https://chrome.google.com/webstore/detail/%E5%B9%BF%E5%91%8A%E5%87%80%E5%8C%96%E5%99%A8/cbiaicifbmeokbhollcjfeaoakmppfeh?hl=zh-CN" target="_blank" rel="noopener">谷歌浏览器</a>   <a href="https://www.yiclear.com/download/" target="_blank" rel="noopener">火狐浏览器</a></p><h2 id="Convertio"><a href="#Convertio" class="headerlink" title="Convertio"></a>Convertio</h2><p>一个文件转换器。<br>网址：<a href="https://convertio.co/zh/" target="_blank" rel="noopener">https://convertio.co/zh/</a></p><h1 id="适用于Chrome的Web服务器"><a href="#适用于Chrome的Web服务器" class="headerlink" title="适用于Chrome的Web服务器"></a>适用于Chrome的Web服务器</h1><h2 id="Web-Server-for-Chrome"><a href="#Web-Server-for-Chrome" class="headerlink" title="Web Server for Chrome"></a>Web Server for Chrome</h2><p>适用于Chrome的Web服务器使用HTTP通过网络从本地文件夹提供网页。可离线运行。</p><p><img src="https://live.staticflickr.com/65535/33926865808_92c256c9fb_z.jpg" alt="Web Server for Chrome"></p><p><img src="https://live.staticflickr.com/65535/32860400467_9b3c5a39ba_z.jpg" alt="Web Server for Chrome"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Visual-Studio-Code&quot;&gt;&lt;a href=&quot;#Visual-Studio-Code&quot; class=&quot;headerlink&quot; title=&quot;Visual Studio Code&quot;&gt;&lt;/a&gt;Visual Studio Code&lt;/h1&gt;&lt;h2 id=&quot;Chinese-Simplified-Language-Pack-for-Visual-Studio-Code&quot;&gt;&lt;a href=&quot;#Chinese-Simplified-Language-Pack-for-Visual-Studio-Code&quot; class=&quot;headerlink&quot; title=&quot;Chinese (Simplified) Language Pack for Visual Studio Code&quot;&gt;&lt;/a&gt;Chinese (Simplified) Language Pack for Visual Studio Code&lt;/h2&gt;&lt;p&gt;适用于 VS Code 的中文（简体）语言包。     &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://live.staticflickr.com/7810/47599193841_ce5cc251fe.jpg&quot; alt=&quot;Chinese (Simplified) Language Pack for Visual Studio Code&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="插件" scheme="http://yoursite.com/categories/%E6%8F%92%E4%BB%B6/"/>
    
    
      <category term="插件" scheme="http://yoursite.com/tags/%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu18.04 安装 Docker</title>
    <link href="http://yoursite.com/2019/05/26/Ubuntu18.04%20%E5%AE%89%E8%A3%85%20Docker/"/>
    <id>http://yoursite.com/2019/05/26/Ubuntu18.04 安装 Docker/</id>
    <published>2019-05-26T03:54:10.201Z</published>
    <updated>2019-08-12T05:02:48.233Z</updated>
    
    <content type="html"><![CDATA[<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h1 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h1><p>Docker CE 支持以下版本的 Ubuntu 操作系统：</p><ul><li>Artful 17.10(Docker CE 17.11 Edge)</li><li>Zesty 17.04</li><li>Xenial 16.04(LTS)</li><li>Trusty 14.04(LTS)</li></ul><p>推荐使用 LTS 版本的，在Ubuntu发行版中，LTS是长期支持版本，会更稳定。<br><a id="more"></a></p><h1 id="卸载旧版本"><a href="#卸载旧版本" class="headerlink" title="卸载旧版本"></a>卸载旧版本</h1><p>旧版本的 Docker 称为 docker 或者 docker-engine，使用以下命令卸载旧版本： </p><pre><code>sudo apt-get remove docker \               docker-engine \               docker.io</code></pre><h1 id="安装与验证"><a href="#安装与验证" class="headerlink" title="安装与验证"></a>安装与验证</h1><p>从 Ubuntu 14.04 开始，一部分内核模块移到了可选内核模块包 (linux-image-extra-*) ，以减少内核软件包的体积。正常安装的系统应该会包含可选内核模块包，而一些裁剪后的系统可能会将其精简掉。AUFS 内核驱动属于可选内核模块的一部分，作为推荐的 Docker 存储层驱动，一般建议安装可选内核模块包以使用 AUFS。    </p><p>如果系统没有安装可选内核模块的话，可以执行下面的命令来安装可选内核模块包：(操作均为普通用户下)     </p><pre><code>sudo apt-get updatesudo apt-get install \    linux-image-extra-$(uname -r) \    linux-image-extra-virtual</code></pre><p>Ubuntu 16.04 + 上的 Docker CE 默认使用 overlay2 存储层驱动,无需手动配置。    </p><h2 id="使用APT安装"><a href="#使用APT安装" class="headerlink" title="使用APT安装"></a>使用APT安装</h2><p>由于 apt 源使用 HTTPS 以确保软件下载过程中不被篡改。因此，我们首先需要添加使用 HTTPS 传输的软件包以及 CA 证书。      </p><pre><code>sudo apt-get updatesudo apt-get install \    apt-transport-https \    ca-certificates \    curl \    software-properties-common</code></pre><p>鉴于国内网络问题，强烈建议使用国内源，官方源请在注释中查看。<br>为了确认所下载软件包的合法性，需要添加软件源的 GPG 密钥。     </p><pre><code>(任选其一即可)curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -官方源curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</code></pre><p>然后，我们需要向 source.list 中添加 Docker 软件源     </p><pre><code>sudo add-apt-repository \    &quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu \    $(lsb_release -cs) \    stable&quot;# 官方源# $ sudo add-apt-repository \#    &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \#    $(lsb_release -cs) \#    stable&quot;</code></pre><h2 id="安装-Docker-CE"><a href="#安装-Docker-CE" class="headerlink" title="安装 Docker CE"></a>安装 Docker CE</h2><pre><code>sudo apt updatesudo apt install docker-ce</code></pre><h2 id="建立-docker-用户组"><a href="#建立-docker-用户组" class="headerlink" title="建立 docker 用户组"></a>建立 docker 用户组</h2><p>建立docker组:   </p><pre><code>sudo groupadd docker</code></pre><p>将当前用户加入docker组：    </p><pre><code>sudo usermod -aG docker $USER</code></pre><h2 id="更换国内Docker仓库"><a href="#更换国内Docker仓库" class="headerlink" title="更换国内Docker仓库"></a>更换国内Docker仓库</h2><p>创建文件：       </p><pre><code>sudo vim /etc/docker/daemon.json</code></pre><p>加入以下内容：     </p><pre><code>{  &quot;registry-mirrors&quot;: [    &quot;https://docker.mirrors.ustc.edu.cn&quot;  ]}</code></pre><p>然后重启系统。    </p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>输入以下命令：       </p><pre><code>docker run hello-world</code></pre><p>若输出以下内容则为成功。          </p><pre><code>Unable to find image &#39;hello-world:latest&#39; locallylatest: Pulling from library/hello-worldca4f61b1923c: Pull completeDigest: sha256:be0cd392e45be79ffeffa6b05338b98ebb16c87b255f48e297ec7f98e123905cStatus: Downloaded newer image for hello-world:latestHello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.    (amd64) 3. The Docker daemon created a new container from that image which runs the    executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it    to your terminal.To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bashShare images, automate workflows, and more with a free Docker ID: https://cloud.docker.com/For more examples and ideas, visit: https://docs.docker.com/engine/userguide/</code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.codingfanlt.xyz/2018/10/17/Ubuntu-%E4%B8%8B%E5%AE%89%E8%A3%85-Docker/#more" target="_blank" rel="noopener">Ubuntu 下安装 Docker</a><br><a href="https://yeasy.gitbooks.io/docker_practice/install/ubuntu.html" target="_blank" rel="noopener">Docker —— 从入门到实践</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h1&gt;&lt;h1 id=&quot;系统要求&quot;&gt;&lt;a href=&quot;#系统要求&quot; class=&quot;headerlink&quot; title=&quot;系统要求&quot;&gt;&lt;/a&gt;系统要求&lt;/h1&gt;&lt;p&gt;Docker CE 支持以下版本的 Ubuntu 操作系统：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Artful 17.10(Docker CE 17.11 Edge)&lt;/li&gt;
&lt;li&gt;Zesty 17.04&lt;/li&gt;
&lt;li&gt;Xenial 16.04(LTS)&lt;/li&gt;
&lt;li&gt;Trusty 14.04(LTS)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;推荐使用 LTS 版本的，在Ubuntu发行版中，LTS是长期支持版本，会更稳定。&lt;br&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
      <category term="安装" scheme="http://yoursite.com/categories/Docker/%E5%AE%89%E8%A3%85/"/>
    
    
      <category term="Docker安装" scheme="http://yoursite.com/tags/Docker%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>Spring MVC和MyBatis开发环境准备</title>
    <link href="http://yoursite.com/2019/05/26/Spring%20MVC%E5%92%8CMyBatis%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/"/>
    <id>http://yoursite.com/2019/05/26/Spring MVC和MyBatis开发环境准备/</id>
    <published>2019-05-26T03:54:10.189Z</published>
    <updated>2019-05-26T10:51:54.221Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-MVC和MyBatis开发环境准备"><a href="#Spring-MVC和MyBatis开发环境准备" class="headerlink" title="Spring MVC和MyBatis开发环境准备"></a>Spring MVC和MyBatis开发环境准备</h1><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ol><li>jdk</li><li>Intellij IDEA</li><li>Tomcat</li><li>Maven</li><li>MySql<a id="more"></a></li></ol><h2 id="JDK-安装"><a href="#JDK-安装" class="headerlink" title="JDK 安装"></a>JDK 安装</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>JDK建议使用1.8及以上的版本。<br>官方下载路径：<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">jdk下载路地址</a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>双击下载软件，一路单击下一步即可。     </p><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p><strong>Windows</strong>：右击【我的电脑】→【属性】→【高级系统设置】→【环境变量】→【系统变量】→【新建】，接着如下图所示：<br><img src="https://farm8.staticflickr.com/7873/40480682053_903c92b01b_b.jpg" alt="java_home"></p><p>在【系统变量】的path中添加 <strong>%JAVA_HOME%\bin</strong>。</p><p>验证，如下图所示：<br><img src="https://farm8.staticflickr.com/7860/40480681993_9a639b1dc2_b.jpg" alt="java"></p><h2 id="Intellij-IDEA"><a href="#Intellij-IDEA" class="headerlink" title="Intellij IDEA"></a>Intellij IDEA</h2><p>下载路径：<a href="https://www.jetbrains.com/idea/download/download-thanks.html?platform=windows" target="_blank" rel="noopener">indea U</a></p><h3 id="激活（针对学生的免费使用计划）"><a href="#激活（针对学生的免费使用计划）" class="headerlink" title="激活（针对学生的免费使用计划）"></a>激活（针对学生的免费使用计划）</h3><p>参考：<a href="https://blog.csdn.net/iemdm1110/article/details/53365881" target="_blank" rel="noopener">Intellij IDEA的下载和使用（针对学生的免费使用计划）</a></p><h2 id="Tomcat的安装与配置"><a href="#Tomcat的安装与配置" class="headerlink" title="Tomcat的安装与配置"></a>Tomcat的安装与配置</h2><h3 id="下载-1"><a href="#下载-1" class="headerlink" title="下载"></a>下载</h3><p>下载链接：<a href="https://www-us.apache.org/dist/tomcat/tomcat-8/v8.5.39/bin/apache-tomcat-8.5.39-windows-x64.zip" target="_blank" rel="noopener">Tomcat 8.0</a><br>其他版本可以查看该页面：<a href="https://tomcat.apache.org/download-80.cgi" target="_blank" rel="noopener">下载页面</a>     </p><p>下载完成后对文件进行解压，<strong>解压路径自行设置</strong>。</p><h3 id="Intellij-IDEA-配置-Tomcat"><a href="#Intellij-IDEA-配置-Tomcat" class="headerlink" title="Intellij IDEA 配置 Tomcat"></a>Intellij IDEA 配置 Tomcat</h3><p>步骤如下图：      </p><p><img src="https://farm8.staticflickr.com/7860/33570544738_4981576891_b.jpg" alt><br><img src="https://farm8.staticflickr.com/7818/33570544808_63d536cc3e_b.jpg" alt><br><img src="https://farm8.staticflickr.com/7896/40480762723_6bce0e2c84_b.jpg" alt><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://farm8.staticflickr.com/7917/33570544928_cabdb4f7d0_b.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure>      </p><h2 id="Maven-的安装和配置"><a href="#Maven-的安装和配置" class="headerlink" title="Maven 的安装和配置"></a>Maven 的安装和配置</h2><p>下载地址：<a href="https://maven.apache.org/download.cgi" target="_blank" rel="noopener">Maven</a>       </p><p><img src="https://farm8.staticflickr.com/7921/46730276854_36b53e43c4_b.jpg" alt="Maven">      </p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ol><li>在Maven的安装目录新建文件夹repository,用来作为本地仓库。</li><li>如下图：<br><img src="https://farm8.staticflickr.com/7899/47400537232_e6978ba63f_b.jpg" alt>       </li></ol><h2 id="MySql"><a href="#MySql" class="headerlink" title="MySql"></a>MySql</h2><p>参考：<a href="http://www.runoob.com/mysql/mysql-install.html" target="_blank" rel="noopener">MySQL 安装| 菜鸟教程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Spring-MVC和MyBatis开发环境准备&quot;&gt;&lt;a href=&quot;#Spring-MVC和MyBatis开发环境准备&quot; class=&quot;headerlink&quot; title=&quot;Spring MVC和MyBatis开发环境准备&quot;&gt;&lt;/a&gt;Spring MVC和MyBatis开发环境准备&lt;/h1&gt;&lt;h2 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;headerlink&quot; title=&quot;准备&quot;&gt;&lt;/a&gt;准备&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;jdk&lt;/li&gt;
&lt;li&gt;Intellij IDEA&lt;/li&gt;
&lt;li&gt;Tomcat&lt;/li&gt;
&lt;li&gt;Maven&lt;/li&gt;
&lt;li&gt;MySql
    
    </summary>
    
      <category term="SSM" scheme="http://yoursite.com/categories/SSM/"/>
    
      <category term="开发环境准备" scheme="http://yoursite.com/categories/SSM/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/"/>
    
    
      <category term="Spring MVC和MyBatis开发环境准备" scheme="http://yoursite.com/tags/Spring-MVC%E5%92%8CMyBatis%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/"/>
    
  </entry>
  
  <entry>
    <title>qtp破解</title>
    <link href="http://yoursite.com/2019/05/26/qtp/"/>
    <id>http://yoursite.com/2019/05/26/qtp/</id>
    <published>2019-05-26T03:54:10.169Z</published>
    <updated>2019-04-20T14:22:35.124Z</updated>
    
    <content type="html"><![CDATA[<h1 id="qtp安装与破解"><a href="#qtp安装与破解" class="headerlink" title="qtp安装与破解"></a>qtp安装与破解</h1><p>准备：</p><ul><li>QTP 10.0</li><li>破解文件<a id="more"></a><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2></li></ul><p>链接: <a href="https://pan.baidu.com/s/19TGLWjd_znKFM8RZkj1ITg" target="_blank" rel="noopener">https://pan.baidu.com/s/19TGLWjd_znKFM8RZkj1ITg</a> 提取码: 9wjv</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://live.staticflickr.com/65535/46735361215_83283715cc.jpg" alt="qtp" title>                </div>                <div class="image-caption">qtp</div>            </figure><p>选择 <strong>QTP10.iso</strong>,解压后点击文件目录中的 <strong>setup.exe</strong>,双击运行。<br>按照图片顺序进行操作。   </p><p><img src="https://live.staticflickr.com/65535/40684441953_317366f332.jpg" alt></p><p><img src="https://live.staticflickr.com/65535/40684441833_c75926247c.jpg" alt></p><p><img src="https://live.staticflickr.com/65535/40684441463_f2dd1a0d8a.jpg" alt></p><p><img src="https://live.staticflickr.com/65535/40684441383_e54b1aae08.jpg" alt></p><p><img src="https://live.staticflickr.com/65535/46735360805_7d747db5fc.jpg" alt></p><p><img src="https://live.staticflickr.com/65535/40684441273_cd0bda4b8a.jpg" alt></p><p><img src="https://live.staticflickr.com/65535/40684441043_0636ac9c5f.jpg" alt></p><p><img src="https://live.staticflickr.com/65535/46735360575_702bbd5e7d.jpg" alt></p><p><img src="https://live.staticflickr.com/65535/40684440933_6a15dbbafe.jpg" alt></p><p><img src="https://live.staticflickr.com/65535/46735360435_1b00578c95.jpg" alt></p><p><img src="https://live.staticflickr.com/65535/40684440783_c657959660.jpg" alt></p><p><img src="https://live.staticflickr.com/65535/46735360325_ca3acbf638.jpg" alt></p><p><img src="https://live.staticflickr.com/65535/46735360275_571ab8de4e.jpg" alt></p><p><img src="https://live.staticflickr.com/65535/40684440503_e69cee4487.jpg" alt></p><h2 id="破解"><a href="#破解" class="headerlink" title="破解"></a>破解</h2><p>1.在<strong>c:\program files\common files\mercury interactive</strong>目录下新建一个文件夹：<strong>License Manager</strong><br>注：<strong>64位操作系统</strong>在<strong>c:\program files(x86)\common files\mercury interactive</strong>以下步骤以此类推。</p><p>2.将下载的文件中的<strong>qtp破解</strong>解压，将<strong>mgn-mqt8.2.exe</strong>复制到qtp的安装路径的<strong>bin文件夹中</strong>，然后以管理员身份运行。</p><p>3.打开<strong>c:\program files\common files\mercury interactive\License Manager</strong>中的<strong>lservrc</strong>文件。</p><p>4.将<strong>lservrc</strong>文件中的内容（<strong>将”QuickTestPro”之前的所有字符复制进去，不包括”QuickTestPro”字符</strong>）粘贴到如下图中。</p><p><img src="https://live.staticflickr.com/65535/40684440503_e69cee4487.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;qtp安装与破解&quot;&gt;&lt;a href=&quot;#qtp安装与破解&quot; class=&quot;headerlink&quot; title=&quot;qtp安装与破解&quot;&gt;&lt;/a&gt;qtp安装与破解&lt;/h1&gt;&lt;p&gt;准备：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;QTP 10.0&lt;/li&gt;
&lt;li&gt;破解文件
    
    </summary>
    
      <category term="软件测试" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
      <category term="qtp" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/qtp/"/>
    
    
      <category term="软件测试" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
      <category term="qtp" scheme="http://yoursite.com/tags/qtp/"/>
    
  </entry>
  
  <entry>
    <title>LoadRunner</title>
    <link href="http://yoursite.com/2019/05/26/LoadRunner/"/>
    <id>http://yoursite.com/2019/05/26/LoadRunner/</id>
    <published>2019-05-26T03:54:10.137Z</published>
    <updated>2019-05-11T06:14:47.837Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LoadRunner-11-0"><a href="#LoadRunner-11-0" class="headerlink" title="LoadRunner 11.0"></a>LoadRunner 11.0</h1><h2 id="准备："><a href="#准备：" class="headerlink" title="准备："></a>准备：</h2><ul><li>LoadRunner 11.0 安装包</li><li>LoadRunner 11.0 破解相关文件</li></ul><a id="more"></a><h2 id="下载："><a href="#下载：" class="headerlink" title="下载："></a>下载：</h2><ul><li>LoadRunner 11.0 安装包（迅雷下载）：<a href="http://www.genilogix.com/downloads/loadrunner/loadrunner-11.iso" target="_blank" rel="noopener">http://www.genilogix.com/downloads/loadrunner/loadrunner-11.iso</a></li><li><a href="https://link.jianshu.com/?t=https://pan.baidu.com/s/1nu9r7tf" target="_blank" rel="noopener">LoadRunner 11.0 破解相关文件</a></li></ul><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><ol><li><p>打开<strong>LoadRunner 11.0 安装包</strong>文件夹，点击<strong>setup.exe</strong>。  </p></li><li><p>点击<strong>LoadRunner完整安装程序</strong>，接着按提示进行下去，当它提示缺省文件的时候可以直接打开“附加组件”进入“Monitor Probe for Microsoft COM+ Server Components”这个文件夹，运行“Com_Plus_Probe.exe”文件即可。       </p></li><li><p>安装成功即进入主界面，进入的时候会有一个提示框出现，意思就是你拥有10天的试用权限。     </p></li></ol><h2 id="破解"><a href="#破解" class="headerlink" title="破解"></a>破解</h2><ol><li><p>打开<strong>LoadRunner 11.0 破解相关文件</strong>，将<strong>mlr5lprg.dll</strong>和<strong>lm70.dll</strong>这两个文件<strong>复制替换</strong>到<strong>LoadRunner安装目录的/bin文件下</strong>。</p></li><li><p>以管理员身份运行<strong>deletelicense.exe</strong></p></li><li><p>管理员身份运行LoadRunner。</p></li><li><p>点击“configuration-&gt;loadRunner License”进入界面，现在你就可以new你自己的license了。下面是不同数量并发的代码：<br>10000个并发：AEABEXFR-YTIEKEKJJMFKEKEKWBRAUNQJU-KBYGB<br>提供一个超级license 最高支持6.5w个并发：AEACFSJI-YJKJKJJKEJIJD-BCLBR。</p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.51cto.com/kinghinds/908502" target="_blank" rel="noopener">loadRunner 安装及破解</a></p><p><a href="https://www.jianshu.com/p/b3b5f24d7877" target="_blank" rel="noopener">LoadRunner 11.0安装+汉化+破解</a></p><p><a href="https://blog.csdn.net/u010298501/article/details/36199745" target="_blank" rel="noopener">loadRunner破解不成功的几个原因</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;LoadRunner-11-0&quot;&gt;&lt;a href=&quot;#LoadRunner-11-0&quot; class=&quot;headerlink&quot; title=&quot;LoadRunner 11.0&quot;&gt;&lt;/a&gt;LoadRunner 11.0&lt;/h1&gt;&lt;h2 id=&quot;准备：&quot;&gt;&lt;a href=&quot;#准备：&quot; class=&quot;headerlink&quot; title=&quot;准备：&quot;&gt;&lt;/a&gt;准备：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;LoadRunner 11.0 安装包&lt;/li&gt;
&lt;li&gt;LoadRunner 11.0 破解相关文件&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="软件测试" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
      <category term="LoadRunner" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/LoadRunner/"/>
    
    
      <category term="软件测试" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
      <category term="LoadRunner" scheme="http://yoursite.com/tags/LoadRunner/"/>
    
  </entry>
  
  <entry>
    <title>Hexo主题casper使用教程</title>
    <link href="http://yoursite.com/2019/05/26/Hexo%E4%B8%BB%E9%A2%98casper%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/05/26/Hexo主题casper使用教程/</id>
    <published>2019-05-26T03:54:07.007Z</published>
    <updated>2019-04-17T14:08:16.453Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo主题casper使用教程"><a href="#Hexo主题casper使用教程" class="headerlink" title="Hexo主题casper使用教程"></a>Hexo主题casper使用教程</h1><p>demo     </p><p><img src="https://live.staticflickr.com/65535/46905122234_0ab308a723.jpg" alt="casper"></p><a id="more"></a><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><pre><code>git clone https://github.com/xzhih/hexo-theme-casper.git themes/hexo-casper</code></pre><h2 id="更改主题为casper"><a href="#更改主题为casper" class="headerlink" title="更改主题为casper"></a>更改主题为casper</h2><p>把<strong>Hexo根目录</strong>的配置文件<strong>_config.yml</strong>中的<strong>theme</strong>改为<strong>hexo-casper</strong>。</p><h2 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h2><p>建议先备份以下再执行下面的操作。     </p><pre><code>cd themes/casper git pull</code></pre><h2 id="添加统一的文章模板参数"><a href="#添加统一的文章模板参数" class="headerlink" title="添加统一的文章模板参数"></a>添加统一的文章模板参数</h2><p>把下面的内容添加到<strong>Hexo根目录</strong>下的<strong>scaffolds/post.md</strong>。</p><pre><code>cover_img:     # 在文章摘要上显示feature_img:   # 在文章详细页面上置顶description:   # 文章描述keywords:      # 关键字</code></pre><h2 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h2><p>编辑<strong>themes/hexo-casper/_config.yml</strong>进行配置。    </p><pre><code># Configrss:            # linkfavicon: https://i.loli.net/2017/11/26/5a19c0b50432e.pngblog_logo: header_image: https://i.loli.net/2017/11/26/5a19c56faa29f.jpgbio: This is a demopost_toc: true# 菜单menu:  About: /about  Archives: /archives  # 其他的可以按照上面的模板添加# 作者author_image:   # 链接author_bio:     # 描述author_location: # 地址# 社交链接social:  facebook: https://www.facebook.com  twitter: https://www.twitter.com  twitter: https://twitter.com  facebook: https://facebook  telegram:  bilibili:  youtube:# 插件（显示在网站底部）widgets:  recent_posts: true  category: true  tagcloud: true  # 这是个简洁的主题，我认为3个就够了# 文章图片相册（点击图片可以放大）# https://github.com/sachinchoolur/lightgallery.jslightgallery: true# 懒加载# 首页已经默认开启，其他页面在此开启# https://github.com/dinbror/blazylazyload: true# 搜索功能local_search: true# Valine 评论系统# https://valine.js.orgcomment: falsevaline:  notify: false # mail notifier , https://github.com/xCss/Valine/wiki   verify: false # Verification code  appId: # your leancloud application appid  appKey: # your leancloud application appkey  placeholder: Just go go # comment box placeholder  avatar: mm # gravatar style  pageSize: 10 # pagination size# PWA # 你需要在 hexo 目录的 source 文件夹里创建一个 manifest.json 文件manifest: falseservice_workers: falsenavColor: &#39;3c484e&#39;# Baidu 链接提交baidu: false# Google AnalyticsgoogleAnalytics: falseGA_TRACKING_ID: UA-XXXXXXXXXX-1</code></pre><h2 id="本地搜索功能"><a href="#本地搜索功能" class="headerlink" title="本地搜索功能"></a>本地搜索功能</h2><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><pre><code>npm install hexo-generator-search --save</code></pre><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>在<strong>Hexo根目录</strong>下中的<strong>_config.yml</strong>进行配置。    </p><pre><code>search：   path：search.xml    field：post    content：true</code></pre><p>path-文件路径。默认为search.xml。如果文件扩展名为.json，则输出格式为JSON。否则将导出XML格式文件。<br>filed-要搜索的文件范围。   </p><ul><li>post（默认）-所有帖子  </li><li>page -所有页面    </li><li>all -所有帖子和页面    </li></ul><p>content-是否包含每篇文章的全部内容。默认为true。如果false，生成的结果仅覆盖没有主体的标题和其他元信息。</p><h3 id="排除索引"><a href="#排除索引" class="headerlink" title="排除索引"></a>排除索引</h3><p>要将某个帖子或页面排除在索引之外，您只需indexing: false在其前端的顶部插入设置，例如：     </p><pre><code>title: &quot;Code Highlight&quot;date: &quot;2014-03-15 20:17:16&quot;tags: highlightcategories: Demodescription: &quot;A collection of Hello World applications from helloworld.org.&quot;toc: trueindexing: false---</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Hexo主题casper使用教程&quot;&gt;&lt;a href=&quot;#Hexo主题casper使用教程&quot; class=&quot;headerlink&quot; title=&quot;Hexo主题casper使用教程&quot;&gt;&lt;/a&gt;Hexo主题casper使用教程&lt;/h1&gt;&lt;p&gt;demo     &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://live.staticflickr.com/65535/46905122234_0ab308a723.jpg&quot; alt=&quot;casper&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
      <category term="Hexo主题casper使用教程" scheme="http://yoursite.com/categories/Hexo/Hexo%E4%B8%BB%E9%A2%98casper%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Hexo主题casper使用教程" scheme="http://yoursite.com/tags/Hexo%E4%B8%BB%E9%A2%98casper%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>hexo-theme-indigo</title>
    <link href="http://yoursite.com/2019/05/26/hexo-theme-indigo/"/>
    <id>http://yoursite.com/2019/05/26/hexo-theme-indigo/</id>
    <published>2019-05-26T03:54:06.999Z</published>
    <updated>2019-04-16T14:29:05.240Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hexo-theme-indigo-主题"><a href="#hexo-theme-indigo-主题" class="headerlink" title="hexo-theme-indigo 主题"></a>hexo-theme-indigo 主题</h1><p>demo<br><img src="https://live.staticflickr.com/65535/47569038422_0c51df8041.jpg" alt="hexo-theme-indigo"></p><a id="more"></a><h2 id="主题安装"><a href="#主题安装" class="headerlink" title="主题安装"></a>主题安装</h2><p>安装需确认Hexo版本在 3.0 以上，以及Node版本在6.x以上，在Hexo根目录，执行以下命令：     </p><pre><code>git clone git@github.com:yscoder/hexo-theme-indigo.git themes/indigo</code></pre><h2 id="切换主题"><a href="#切换主题" class="headerlink" title="切换主题"></a>切换主题</h2><p>在Hexo根目录下的_config.yml文件中修改，如下：     </p><pre><code>theme: indigo</code></pre><p>注：记得保存。</p><h2 id="依赖安装"><a href="#依赖安装" class="headerlink" title="依赖安装"></a>依赖安装</h2><h3 id="Less"><a href="#Less" class="headerlink" title="Less"></a>Less</h3><p>主题默认使用 less 作为 css 预处理工具。    </p><pre><code>npm install hexo-renderer-less --save</code></pre><h3 id="Feed"><a href="#Feed" class="headerlink" title="Feed"></a>Feed</h3><p>用于生成 rss。       </p><pre><code>npm install hexo-generator-feed --save</code></pre><h3 id="Json-content"><a href="#Json-content" class="headerlink" title="Json-content"></a>Json-content</h3><p>用于生成静态站点数据，用作站内搜索的数据源。      </p><pre><code>npm install hexo-generator-json-content --save</code></pre><h3 id="QRCode-可选"><a href="#QRCode-可选" class="headerlink" title="QRCode(可选)"></a>QRCode(可选)</h3><p>用于生成微信分享二维码。<br>可选，不安装时会请求 jiathis Api 生成二维码。    </p><pre><code>npm install hexo-helper-qrcode --save</code></pre><h2 id="开启分类页"><a href="#开启分类页" class="headerlink" title="开启分类页"></a>开启分类页</h2><p>仅 card theme 支持。     </p><pre><code>hexo new page categories</code></pre><p>修改 hexo/source/categories/index.md 的元数据     </p><pre><code>layout: categoriescomments: false---</code></pre><h2 id="开启标签页"><a href="#开启标签页" class="headerlink" title="开启标签页"></a>开启标签页</h2><pre><code>hexo new page tags</code></pre><p>修改 hexo/source/tags/index.md 的元数据</p><pre><code>layout: tagscomments: false---</code></pre><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="文章截断"><a href="#文章截断" class="headerlink" title="文章截断"></a>文章截断</h3><p>在Markdown中加<!-- more -->      </p><h3 id="添加多个标签"><a href="#添加多个标签" class="headerlink" title="添加多个标签"></a>添加多个标签</h3><pre><code>tags: [a, b, c]</code></pre><p>或     </p><pre><code>tags:   - a  - b  - c</code></pre><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><pre><code>categories: [a, b, c]</code></pre><h3 id="更改站点配色"><a href="#更改站点配色" class="headerlink" title="更改站点配色"></a>更改站点配色</h3><p>编辑 themes\indigo\source\css_partial\variable.less，更改对应的颜色变量。<br>配色参考：<a href="http://www.materialpalette.com/" target="_blank" rel="noopener">Material Design Color Palette Generator</a><br>注意：使用自定义配色时需把主题配置中的 cdn 关闭，cdn: false。     </p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>参考：<a href="https://github.com/yscoder/hexo-theme-indigo/wiki/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">https://github.com/yscoder/hexo-theme-indigo/wiki/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98</a></p><h2 id="站点配置"><a href="#站点配置" class="headerlink" title="站点配置"></a>站点配置</h2><p>编辑站点配置文件 <strong>\themes\landscape</strong>的<strong>_config.yml</strong>文件。    </p><h3 id="启动主题"><a href="#启动主题" class="headerlink" title="启动主题"></a>启动主题</h3><pre><code>theme: indigo</code></pre><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><h4 id="左侧菜单"><a href="#左侧菜单" class="headerlink" title="左侧菜单"></a>左侧菜单</h4><pre><code>menu:  home:    text: 主页    url: /  archives:    url: /archives  tags:    url: /tags  github:    url: https://github.com/yscoder    target: _blank  weibo:    url: http://www.weibo.com/ysweb    target: _blank  link:    text: 测试    url: /</code></pre><p>添加新菜单项时，在 menu 下增加子属性即可。属性说明如下：     </p><pre><code>menu: link:               # fontawesome图标，省略前缀，本主题前缀为 icon-，必须   text: About       # 菜单显示的文字，如果省略即默认与图标一致，首字母会转大写   url: /about       # 链接，绝对或相对路径，必须   target: _blank    # 是否跳出，省略则在当前页面打开</code></pre><h4 id="favicon"><a href="#favicon" class="headerlink" title="favicon"></a>favicon</h4><p>站点 logo，显示在浏览器当前标签页左上角。      </p><pre><code>favicon: /favicon.ico</code></pre><h4 id="头像"><a href="#头像" class="headerlink" title="头像"></a>头像</h4><p>位于左侧菜单上方     </p><pre><code>avatar: /img/logo.jpg</code></pre><h4 id="email"><a href="#email" class="headerlink" title="email"></a>email</h4><p>头像下方      </p><pre><code>email: 634206017@qq.com</code></pre><h4 id="color"><a href="#color" class="headerlink" title="color"></a>color</h4><p>设置 Android L Chrome 浏览器状态栏颜色，不需要可去除此项或设为 false。       </p><pre><code>color: &#39;#3F51B5&#39;</code></pre><h4 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h4><p>参考：<a href="https://github.com/yscoder/hexo-theme-indigo/wiki/%E9%85%8D%E7%BD%AE" target="_blank" rel="noopener">https://github.com/yscoder/hexo-theme-indigo/wiki/%E9%85%8D%E7%BD%AE</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;hexo-theme-indigo-主题&quot;&gt;&lt;a href=&quot;#hexo-theme-indigo-主题&quot; class=&quot;headerlink&quot; title=&quot;hexo-theme-indigo 主题&quot;&gt;&lt;/a&gt;hexo-theme-indigo 主题&lt;/h1&gt;&lt;p&gt;demo&lt;br&gt;&lt;img src=&quot;https://live.staticflickr.com/65535/47569038422_0c51df8041.jpg&quot; alt=&quot;hexo-theme-indigo&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
      <category term="hexo-theme-indigo" scheme="http://yoursite.com/categories/Hexo/hexo-theme-indigo/"/>
    
    
      <category term="hexo-theme-indigo" scheme="http://yoursite.com/tags/hexo-theme-indigo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo yilia 添加目录页面</title>
    <link href="http://yoursite.com/2019/05/26/Hexo%20yilia%20%E6%B7%BB%E5%8A%A0%E7%9B%AE%E5%BD%95%E9%A1%B5%E9%9D%A2/"/>
    <id>http://yoursite.com/2019/05/26/Hexo yilia 添加目录页面/</id>
    <published>2019-05-26T03:54:06.987Z</published>
    <updated>2018-12-17T14:02:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><p> 1.添加 categories 页面<br> 2.添加 categories 链接<br> 3.修改 yilia 主题<br> 4.多层分类<br> 5.效果<br> 6.参考文档</p><a id="more"></a><h2 id="1-添加-categories-页面"><a href="#1-添加-categories-页面" class="headerlink" title="1 添加 categories 页面"></a>1 添加 categories 页面</h2><h3 id="1-1-新建-categories-页面"><a href="#1-1-新建-categories-页面" class="headerlink" title="1.1 新建 categories 页面"></a>1.1 新建 categories 页面</h3><blockquote><p>输入命令： </p></blockquote><pre><code>hexo new page categories</code></pre><blockquote><p>该命令在 <strong>source</strong>  目录下生成一个 categories 目录，categories 目录下有一个 index.md 文件。  </p></blockquote><h3 id="1-2-修改-index-md-文件"><a href="#1-2-修改-index-md-文件" class="headerlink" title="1.2 修改 index.md 文件"></a>1.2 修改 index.md 文件</h3><pre><code>---title: 文章分类date: 2018-10-19 11:22:21type: &quot;categories&quot;layout: &quot;categories&quot;comments: false #关闭评论---</code></pre><h2 id="2-添加-categories-链接"><a href="#2-添加-categories-链接" class="headerlink" title="2 添加 categories 链接"></a>2 添加 categories 链接</h2><blockquote><p>若主题为 yilia ，则打开 yilia/_config.yml ，修改为：  </p></blockquote><pre><code>menu:  主页: /  相册: /  分类: /categories</code></pre><h2 id="3-修改-yilia-主题"><a href="#3-修改-yilia-主题" class="headerlink" title="3 修改 yilia 主题"></a>3 修改 yilia 主题</h2><h3 id="3-1-新建yilia-layout-categories-ejs"><a href="#3-1-新建yilia-layout-categories-ejs" class="headerlink" title="3.1 新建yilia/layout/categories.ejs"></a>3.1 新建yilia/layout/categories.ejs</h3><pre><code>&lt;article class=&quot;article article-type-post show&quot;&gt;  &lt;header class=&quot;article-header&quot;&gt;  &lt;h1 class=&quot;article-title&quot; itemprop=&quot;name&quot;&gt;    &lt;%= page.title %&gt;  &lt;/h1&gt;  &lt;/header&gt;  &lt;% if (site.categories.length){ %&gt;  &lt;div class=&quot;category-all-page article-type-post show&quot;&gt;    &lt;h3&gt;共计&amp;nbsp;&lt;%= site.categories.length %&gt;&amp;nbsp;个分类&lt;/h3&gt;    &lt;ul class=&quot;category-list&quot;&gt;    &lt;% site.categories.sort(&#39;name&#39;).each(function(item){ %&gt;      &lt;% if(item.posts.length){ %&gt;        &lt;li class=&quot;category-list-item&quot;&gt;          &lt;a href=&quot;&lt;%- config.root %&gt;&lt;%- item.path %&gt;&quot; title=&quot;&lt;%= item.name %&gt;&quot;&gt;&lt;%= item.name %&gt;&lt;sup&gt;[&lt;%= item.posts.length %&gt;]&lt;/sup&gt;&lt;/a&gt;        &lt;/li&gt;      &lt;% } %&gt;    &lt;% }); %&gt;    &lt;/ul&gt;  &lt;/div&gt;  &lt;% } %&gt;&lt;/article&gt;</code></pre><h3 id="3-2-修改-yilia-source-main-0cf68a-css，将下面的内容添加进去"><a href="#3-2-修改-yilia-source-main-0cf68a-css，将下面的内容添加进去" class="headerlink" title="3.2 修改 yilia\source\main.0cf68a.css，将下面的内容添加进去"></a>3.2 修改 yilia\source\main.0cf68a.css，将下面的内容添加进去</h3><pre><code>category-all-page {    margin: 30px 40px 30px 40px;    position: relative;    min-height: 70vh;  }  .category-all-page h2 {    margin: 20px 0;  }  .category-all-page .category-all-title {    text-align: center;  }  .category-all-page .category-all {    margin-top: 20px;  }  .category-all-page .category-list {    margin: 0;    padding: 0;    list-style: none;  }  .category-all-page .category-list-item-list-item {    margin: 10px 15px;  }  .category-all-page .category-list-item-list-count {    color: $grey;  }  .category-all-page .category-list-item-list-count:before {    display: inline;    content: &quot; (&quot;;  }  .category-all-page .category-list-item-list-count:after {    display: inline;    content: &quot;) &quot;;  }  .category-all-page .category-list-item {    margin: 10px 10px;  }  .category-all-page .category-list-count {    color: $grey;  }  .category-all-page .category-list-count:before {    display: inline;    content: &quot; (&quot;;  }  .category-all-page .category-list-count:after {    display: inline;    content: &quot;) &quot;;  }  .category-all-page .category-list-child {    padding-left: 10px;  }</code></pre><h2 id="4-多层分类"><a href="#4-多层分类" class="headerlink" title="4 多层分类"></a>4 多层分类</h2><h3 id="4-1-修改yilia-layout-categories-ejs为："><a href="#4-1-修改yilia-layout-categories-ejs为：" class="headerlink" title="4.1 修改yilia/layout/categories.ejs为："></a>4.1 修改yilia/layout/categories.ejs为：</h3><pre><code>&lt;article class=&quot;article article-type-post show&quot;&gt;  &lt;header class=&quot;article-header&quot; style=&quot;border-bottom: 1px solid #ccc&quot;&gt;  &lt;h1 class=&quot;article-title&quot; itemprop=&quot;name&quot;&gt;    &lt;%= page.title %&gt;  &lt;/h1&gt;  &lt;/header&gt;  &lt;% if (site.categories.length){ %&gt;  &lt;div class=&quot;category-all-page&quot;&gt;    &lt;h2&gt;共计&amp;nbsp;&lt;%= site.categories.length %&gt;&amp;nbsp;个分类&lt;/h2&gt;    &lt;%- list_categories(site.categories, {      show_count: true,      class: &#39;category-list-item&#39;,      style: &#39;list&#39;,      depth: 2,      separator: &#39;&#39;    }) %&gt;  &lt;/div&gt;  &lt;% } %&gt;&lt;/article&gt;</code></pre><h3 id="4-2-修改自己的文章"><a href="#4-2-修改自己的文章" class="headerlink" title="4.2 修改自己的文章"></a>4.2 修改自己的文章</h3><pre><code>---title: Hexo yilia 添加目录页面tags: Hexo yilia 添加目录toc: truecategories: [Hexo,创建目录]---</code></pre><h2 id="5-效果"><a href="#5-效果" class="headerlink" title="5 效果"></a>5 效果</h2><blockquote><p>如下图： </p></blockquote><p><img src="https://farm2.staticflickr.com/1914/30502562127_06a9af4659_b.jpg" alt="效果">  </p><h2 id="6-参考文档"><a href="#6-参考文档" class="headerlink" title="6 参考文档"></a>6 参考文档</h2><blockquote><p><a href="https://www.voidking.com/2018/06/11/deve-hexo-categories/#%E4%B9%A6%E7%AD%BE" target="_blank" rel="noopener">Hexo添加categories页面</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;步骤&quot;&gt;&lt;a href=&quot;#步骤&quot; class=&quot;headerlink&quot; title=&quot;步骤&quot;&gt;&lt;/a&gt;步骤&lt;/h1&gt;&lt;p&gt; 1.添加 categories 页面&lt;br&gt; 2.添加 categories 链接&lt;br&gt; 3.修改 yilia 主题&lt;br&gt; 4.多层分类&lt;br&gt; 5.效果&lt;br&gt; 6.参考文档&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
      <category term="创建目录" scheme="http://yoursite.com/categories/Hexo/%E5%88%9B%E5%BB%BA%E7%9B%AE%E5%BD%95/"/>
    
    
      <category term="Hexo yilia 添加目录" scheme="http://yoursite.com/tags/Hexo-yilia-%E6%B7%BB%E5%8A%A0%E7%9B%AE%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Hexo yilia 添加Valine</title>
    <link href="http://yoursite.com/2019/05/26/Hexo%20yilia%20%E6%B7%BB%E5%8A%A0Valine/"/>
    <id>http://yoursite.com/2019/05/26/Hexo yilia 添加Valine/</id>
    <published>2019-05-26T03:54:06.971Z</published>
    <updated>2018-10-21T04:49:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><p> 1.Valine 介绍<br> 2.注册LeanCloud<br> 3.配置<br> 4.参考文档</p><a id="more"></a><h2 id="Valine-介绍"><a href="#Valine-介绍" class="headerlink" title="Valine 介绍"></a>Valine 介绍</h2><blockquote><p>Valine- 一款快速、简洁且高效的无后端评论系统。  </p></blockquote><blockquote><p>Valine 诞生于2017年8月7日，是一款基于Leancloud的快速、简洁且高效的无后端评论系统。理论上支持但不限于静态博客，目前已有Hexo、Jekyll、Typecho、Hugo 等博客程序在使用Valine。  </p></blockquote><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><blockquote><p>快速<br>安全<br>Emoji 😉<br>无后端实现<br>MarkDown 全语法支持<br>轻量易用(~15kb gzipped)<br>文章阅读量统计 v1.2.0+</p></blockquote><h2 id="注册-LeanCloud"><a href="#注册-LeanCloud" class="headerlink" title="注册 LeanCloud"></a>注册 LeanCloud</h2><blockquote><p>注册 <a href="https://leancloud.cn/dashboard/login.html#/signup" target="_blank" rel="noopener">LeanCloud</a>  </p></blockquote><blockquote><p>注册完成后创建一个应用。然后打开设置-应用Key。如下图：  </p></blockquote><p><img src="https://farm2.staticflickr.com/1909/30501889127_29b161ac31_b.jpg" alt="key">  </p><blockquote><p>复制图中的 <strong>App ID</strong> <strong>App key</strong> <strong>Master Key</strong>  作为备用  </p></blockquote><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><blockquote><p><strong>_config.yml</strong>  </p></blockquote><pre><code>#6、Valine https://valine.js.orgvaline:  appid:  #Leancloud应用的appId appkey:  #Leancloud应用的appKey verify: false #验证码 notify: false #评论回复提醒 avatar: mm #评论列表头像样式：&#39;&#39;/mm/identicon/monsterid/wavatar/retro/hide placeholder: Just go go #评论框占位符</code></pre><blockquote><p><strong>layout/_partial/article.ejs</strong>  </p></blockquote><pre><code>   &lt;% if (theme.valine &amp;&amp; theme.valine.appid &amp;&amp; theme.valine.appkey){ %&gt;    &lt;section id=&quot;comments&quot; style=&quot;margin:10px;padding:10px;background:#fff;&quot;&gt;      &lt;%- partial(&#39;post/valine&#39;, {        key: post.slug,        title: post.title,        url: config.url+url_for(post.path)        }) %&gt;    &lt;/section&gt;  &lt;% } %&gt;&lt;% } %&gt;</code></pre><blockquote><p><strong>layout/_partial/post/valine.ejs</strong>  </p></blockquote><pre><code>&lt;div id=&quot;vcomment&quot; class=&quot;comment&quot;&gt;&lt;/div&gt; &lt;script src=&quot;//cdn1.lncld.net/static/js/3.0.4/av-min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;//unpkg.com/valine/dist/Valine.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;   var notify = &#39;&lt;%= theme.valine.notify %&gt;&#39; == true ? true : false;   var verify = &#39;&lt;%= theme.valine.verify %&gt;&#39; == true ? true : false;    window.onload = function() {        new Valine({            el: &#39;.comment&#39;,            notify: notify,            verify: verify,            app_id: &quot;&lt;%= theme.valine.appid %&gt;&quot;,            app_key: &quot;&lt;%= theme.valine.appkey %&gt;&quot;,            placeholder: &quot;&lt;%= theme.valine.placeholder %&gt;&quot;,            avatar:&quot;&lt;%= theme.valine.avatar %&gt;&quot;        });    }&lt;/script&gt;</code></pre><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><blockquote><p>1 <a href="https://www.bluelzy.com/articles/use_valine_for_your_blog.html" target="_blank" rel="noopener">为你的Hexo加上评论系统-Valine</a><br>2 <a href="https://github.com/litten/hexo-theme-yilia/pull/646" target="_blank" rel="noopener">新增对Valine评论系统的支持</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;步骤&quot;&gt;&lt;a href=&quot;#步骤&quot; class=&quot;headerlink&quot; title=&quot;步骤&quot;&gt;&lt;/a&gt;步骤&lt;/h1&gt;&lt;p&gt; 1.Valine 介绍&lt;br&gt; 2.注册LeanCloud&lt;br&gt; 3.配置&lt;br&gt; 4.参考文档&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
      <category term="Valine评论" scheme="http://yoursite.com/categories/Hexo/Valine%E8%AF%84%E8%AE%BA/"/>
    
    
      <category term="Hexo yilia Valine" scheme="http://yoursite.com/tags/Hexo-yilia-Valine/"/>
    
  </entry>
  
</feed>
